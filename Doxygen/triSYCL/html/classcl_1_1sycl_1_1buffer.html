<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>triSYCL implementation of OpenCL SYCL: cl::sycl::buffer&lt; T, Dimensions, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">triSYCL implementation of OpenCL SYCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecl.html">cl</a></li><li class="navelem"><a class="el" href="namespacecl_1_1sycl.html">sycl</a></li><li class="navelem"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="classcl_1_1sycl_1_1buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cl::sycl::buffer&lt; T, Dimensions, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>&lt;T, Dimensions, Mode, Target&gt;up data Data access and storage in SYCL  
 <a href="classcl_1_1sycl_1_1buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="accessor_8hpp_source.html">accessor.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cl::sycl::buffer&lt; T, Dimensions, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer__inherit__graph.png" border="0" usemap="#cl_1_1sycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="cl_1_1sycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map" id="cl_1_1sycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map">
<area shape="rect" id="node2" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html" title="cl::sycl::detail::shared\l_ptr_implementation\&lt; buffer\l\&lt; T, Dimensions, Allocator\l \&gt;, detail::buffer_waiter\&lt;\l T, Dimensions, Allocator \&gt; \&gt;" alt="" coords="221,5,416,91"/>
<area shape="rect" id="node4" href="group__debug__trace.html" title="cl::sycl::detail::debug\l\&lt; buffer\&lt; T, Dimensions,\l Allocator \&gt; \&gt;" alt="" coords="235,115,403,171"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for cl::sycl::buffer&lt; T, Dimensions, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer__coll__graph.png" border="0" usemap="#cl_1_1sycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="cl_1_1sycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map" id="cl_1_1sycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map">
<area shape="rect" id="node2" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html" title="cl::sycl::detail::shared\l_ptr_implementation\&lt; buffer\l\&lt; T, Dimensions, Allocator\l \&gt;, detail::buffer_waiter\&lt;\l T, Dimensions, Allocator \&gt; \&gt;" alt="" coords="325,31,520,116"/>
<area shape="rect" id="node4" href="classstd_1_1shared__ptr_3_01detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_01_4.html" title="shared_ptr\&lt; detail\l::buffer_waiter\&lt; T,\l Dimensions, Allocator \&gt; \&gt;" alt="" coords="5,85,184,141"/>
<area shape="rect" id="node5" href="group__debug__trace.html" title="cl::sycl::detail::debug\l\&lt; buffer\&lt; T, Dimensions,\l Allocator \&gt; \&gt;" alt="" coords="339,140,507,196"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abf509183b12f7183dd8b065c05d651bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#abf509183b12f7183dd8b065c05d651bd">value_type</a> = T</td></tr>
<tr class="memdesc:abf509183b12f7183dd8b065c05d651bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The STL-like types.  <a href="#abf509183b12f7183dd8b065c05d651bd">More...</a><br /></td></tr>
<tr class="separator:abf509183b12f7183dd8b065c05d651bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8326722c12afd6532d7cbf9f3e31ebc3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a8326722c12afd6532d7cbf9f3e31ebc3">reference</a> = <a class="el" href="classcl_1_1sycl_1_1buffer.html#abf509183b12f7183dd8b065c05d651bd">value_type</a> &amp;</td></tr>
<tr class="separator:a8326722c12afd6532d7cbf9f3e31ebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5529e4c07422297be4814e19e02def0f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a5529e4c07422297be4814e19e02def0f">const_reference</a> = const <a class="el" href="classcl_1_1sycl_1_1buffer.html#abf509183b12f7183dd8b065c05d651bd">value_type</a> &amp;</td></tr>
<tr class="separator:a5529e4c07422297be4814e19e02def0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac573e8eaa158a09ea84df760434d6f26"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ac573e8eaa158a09ea84df760434d6f26">allocator_type</a> = Allocator</td></tr>
<tr class="separator:ac573e8eaa158a09ea84df760434d6f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc8d8dc747f1a22a73b1355b0f5cf83a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#abc8d8dc747f1a22a73b1355b0f5cf83a">buffer</a> ()=default</td></tr>
<tr class="memdesc:abc8d8dc747f1a22a73b1355b0f5cf83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use default constructors so that we can create a new buffer copy from another one, with either a l-value or an r-value (for std::move() for example).  <a href="#abc8d8dc747f1a22a73b1355b0f5cf83a">More...</a><br /></td></tr>
<tr class="separator:abc8d8dc747f1a22a73b1355b0f5cf83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba20634eab3fa3d1a47d773dff29366"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a2ba20634eab3fa3d1a47d773dff29366">buffer</a> (const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r, Allocator allocator={})</td></tr>
<tr class="memdesc:a2ba20634eab3fa3d1a47d773dff29366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer of the given size with storage managed by the SYCL runtime.  <a href="#a2ba20634eab3fa3d1a47d773dff29366">More...</a><br /></td></tr>
<tr class="separator:a2ba20634eab3fa3d1a47d773dff29366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fec85df535a86586a83d2cbe1a7102"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a29fec85df535a86586a83d2cbe1a7102">buffer</a> (const T *host_data, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r, Allocator allocator={})</td></tr>
<tr class="memdesc:a29fec85df535a86586a83d2cbe1a7102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated host memory.  <a href="#a29fec85df535a86586a83d2cbe1a7102">More...</a><br /></td></tr>
<tr class="separator:a29fec85df535a86586a83d2cbe1a7102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9786890f239a982b072d634ee3eeeb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ae9786890f239a982b072d634ee3eeeb6">buffer</a> (T *host_data, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r, Allocator allocator={})</td></tr>
<tr class="memdesc:ae9786890f239a982b072d634ee3eeeb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated host memory.  <a href="#ae9786890f239a982b072d634ee3eeeb6">More...</a><br /></td></tr>
<tr class="separator:ae9786890f239a982b072d634ee3eeeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3205caa44c59fe4f0553861fdc81a80f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a3205caa44c59fe4f0553861fdc81a80f">buffer</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; &amp;host_data, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;buffer_range, <a class="el" href="namespacecl_1_1sycl.html#a0e818f1ac2ba5084b08dd41ca813ef28">cl::sycl::mutex_class</a> &amp;m, Allocator allocator={})</td></tr>
<tr class="memdesc:a3205caa44c59fe4f0553861fdc81a80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated memory, using the data in host_data.  <a href="#a3205caa44c59fe4f0553861fdc81a80f">More...</a><br /></td></tr>
<tr class="separator:a3205caa44c59fe4f0553861fdc81a80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac181c98d6676240ee42b0d3c22f12fc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ac181c98d6676240ee42b0d3c22f12fc3">buffer</a> (<a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; host_data, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;buffer_range, Allocator allocator={})</td></tr>
<tr class="memdesc:ac181c98d6676240ee42b0d3c22f12fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated memory, using the data in host_data.  <a href="#ac181c98d6676240ee42b0d3c22f12fc3">More...</a><br /></td></tr>
<tr class="separator:ac181c98d6676240ee42b0d3c22f12fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3109897dc50638c1dd38793605c8d53e"><td class="memTemplParams" colspan="2">template&lt;typename D  = std::default_delete&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a3109897dc50638c1dd38793605c8d53e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a3109897dc50638c1dd38793605c8d53e">buffer</a> (<a class="el" href="namespacecl_1_1sycl.html#a7297c7f7107f609a00c08c1808f4b765">unique_ptr_class</a>&lt; T, D &gt; &amp;&amp;host_data, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;buffer_range, Allocator allocator={})</td></tr>
<tr class="memdesc:a3109897dc50638c1dd38793605c8d53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer which is initialized by host_data.  <a href="#a3109897dc50638c1dd38793605c8d53e">More...</a><br /></td></tr>
<tr class="separator:a3109897dc50638c1dd38793605c8d53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52288588ec69fafceabfacad98fa1f40"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ValueType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt; </td></tr>
<tr class="memitem:a52288588ec69fafceabfacad98fa1f40"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a52288588ec69fafceabfacad98fa1f40">buffer</a> (InputIterator start_iterator, InputIterator end_iterator, Allocator allocator={})</td></tr>
<tr class="memdesc:a52288588ec69fafceabfacad98fa1f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new allocated 1D buffer initialized from the given elements ranging from first up to one before last.  <a href="#a52288588ec69fafceabfacad98fa1f40">More...</a><br /></td></tr>
<tr class="separator:a52288588ec69fafceabfacad98fa1f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48561f28439b7aecccd5926be126e2e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a48561f28439b7aecccd5926be126e2e3">buffer</a> (<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; T, Dimensions, Allocator &gt; &amp;b, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1id">id</a>&lt; Dimensions &gt; &amp;base_index, const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;sub_range, Allocator allocator={})</td></tr>
<tr class="memdesc:a48561f28439b7aecccd5926be126e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new sub-buffer without allocation to have separate accessors later.  <a href="#a48561f28439b7aecccd5926be126e2e3">More...</a><br /></td></tr>
<tr class="separator:a48561f28439b7aecccd5926be126e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198b3dc4305b1d112ee5bd2cb4b9a26d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a198b3dc4305b1d112ee5bd2cb4b9a26d">buffer</a> (cl_mem mem_object, <a class="el" href="group__execution.html#classcl_1_1sycl_1_1queue">queue</a> from_queue, <a class="el" href="classcl_1_1sycl_1_1event.html">event</a> available_event={}, Allocator allocator={})</td></tr>
<tr class="memdesc:a198b3dc4305b1d112ee5bd2cb4b9a26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer from an existing OpenCL memory object associated with a context after waiting for an event signaling the availability of the OpenCL data.  <a href="#a198b3dc4305b1d112ee5bd2cb4b9a26d">More...</a><br /></td></tr>
<tr class="separator:a198b3dc4305b1d112ee5bd2cb4b9a26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5d63a2931ac9dc650320487ac21a31"><td class="memTemplParams" colspan="2">template&lt;access::mode Mode, access::target Target = access::target::global_buffer&gt; </td></tr>
<tr class="memitem:a1e5d63a2931ac9dc650320487ac21a31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__data.html#classcl_1_1sycl_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, Target &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a1e5d63a2931ac9dc650320487ac21a31">get_access</a> (<a class="el" href="group__execution.html#classcl_1_1sycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:a1e5d63a2931ac9dc650320487ac21a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an accessor to the buffer with the required mode.  <a href="#a1e5d63a2931ac9dc650320487ac21a31">More...</a><br /></td></tr>
<tr class="separator:a1e5d63a2931ac9dc650320487ac21a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b25b30e20f4a2ebda0d58343949711a"><td class="memTemplParams" colspan="2">template&lt;access::mode Mode, access::target Target = access::target::host_buffer&gt; </td></tr>
<tr class="memitem:a9b25b30e20f4a2ebda0d58343949711a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__data.html#classcl_1_1sycl_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, Target &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a9b25b30e20f4a2ebda0d58343949711a">get_access</a> ()</td></tr>
<tr class="memdesc:a9b25b30e20f4a2ebda0d58343949711a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a host accessor to the buffer with the required mode.  <a href="#a9b25b30e20f4a2ebda0d58343949711a">More...</a><br /></td></tr>
<tr class="separator:a9b25b30e20f4a2ebda0d58343949711a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8471b53f94001e70de54c38e088822e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#ae8471b53f94001e70de54c38e088822e">get_range</a> () const </td></tr>
<tr class="memdesc:ae8471b53f94001e70de54c38e088822e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor.  <a href="#ae8471b53f94001e70de54c38e088822e">More...</a><br /></td></tr>
<tr class="separator:ae8471b53f94001e70de54c38e088822e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb46db7f86f0f153e8d67ffbd3cae5e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#abb46db7f86f0f153e8d67ffbd3cae5e3">get_count</a> () const </td></tr>
<tr class="memdesc:abb46db7f86f0f153e8d67ffbd3cae5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in the buffer.  <a href="#abb46db7f86f0f153e8d67ffbd3cae5e3">More...</a><br /></td></tr>
<tr class="separator:abb46db7f86f0f153e8d67ffbd3cae5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef172cb6ab104ef307e120260e19ed76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#aef172cb6ab104ef307e120260e19ed76">get_size</a> () const </td></tr>
<tr class="memdesc:aef172cb6ab104ef307e120260e19ed76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the buffer storage in bytes.  <a href="#aef172cb6ab104ef307e120260e19ed76">More...</a><br /></td></tr>
<tr class="separator:aef172cb6ab104ef307e120260e19ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4290e039c4fa36b99eef6411708ea9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a9d4290e039c4fa36b99eef6411708ea9">use_count</a> () const </td></tr>
<tr class="memdesc:a9d4290e039c4fa36b99eef6411708ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buffers that are shared/referenced.  <a href="#a9d4290e039c4fa36b99eef6411708ea9">More...</a><br /></td></tr>
<tr class="separator:a9d4290e039c4fa36b99eef6411708ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85670971c793b40a612ce48c76b12f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a85670971c793b40a612ce48c76b12f22">is_read_only</a> () const </td></tr>
<tr class="memdesc:a85670971c793b40a612ce48c76b12f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask for read-only status of the buffer.  <a href="#a85670971c793b40a612ce48c76b12f22">More...</a><br /></td></tr>
<tr class="separator:a85670971c793b40a612ce48c76b12f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d6f5eab3e26d0dd5dde0ecdf931ea0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#a26d6f5eab3e26d0dd5dde0ecdf931ea0">set_final_data</a> (<a class="el" href="namespacecl_1_1sycl.html#a8cc65d5e679773a053245819fa2a13de">weak_ptr_class</a>&lt; T &gt; finalData)</td></tr>
<tr class="memdesc:a26d6f5eab3e26d0dd5dde0ecdf931ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set destination of buffer data on destruction.  <a href="#a26d6f5eab3e26d0dd5dde0ecdf931ea0">More...</a><br /></td></tr>
<tr class="separator:a26d6f5eab3e26d0dd5dde0ecdf931ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;</a></td></tr>
<tr class="memitem:abac70d3827a5e125faebc6023ca69971 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#abac70d3827a5e125faebc6023ca69971">shared_ptr_implementation</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer__waiter">detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt; &gt; i)</td></tr>
<tr class="memdesc:abac70d3827a5e125faebc6023ca69971 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation directly as a shared pointer.  <a href="#abac70d3827a5e125faebc6023ca69971">More...</a><br /></td></tr>
<tr class="separator:abac70d3827a5e125faebc6023ca69971 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd3894f5c008f80d9b8226a0319b9f inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a97fd3894f5c008f80d9b8226a0319b9f">shared_ptr_implementation</a> (<a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer__waiter">detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt; *i)</td></tr>
<tr class="memdesc:a97fd3894f5c008f80d9b8226a0319b9f inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation takes the ownership from a raw pointer.  <a href="#a97fd3894f5c008f80d9b8226a0319b9f">More...</a><br /></td></tr>
<tr class="separator:a97fd3894f5c008f80d9b8226a0319b9f inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec148373cfaf7463a3723067bae566bb inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#aec148373cfaf7463a3723067bae566bb">shared_ptr_implementation</a> ()=default</td></tr>
<tr class="memdesc:aec148373cfaf7463a3723067bae566bb inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep all other constructors to have usual shared_ptr behaviour.  <a href="#aec148373cfaf7463a3723067bae566bb">More...</a><br /></td></tr>
<tr class="separator:aec148373cfaf7463a3723067bae566bb inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445f09096df761a4d48ba32ffdb57927 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a445f09096df761a4d48ba32ffdb57927">operator==</a> (const <a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer">buffer</a>&lt; T, Dimensions, Allocator &gt; &amp;other) const</td></tr>
<tr class="memdesc:a445f09096df761a4d48ba32ffdb57927 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#a445f09096df761a4d48ba32ffdb57927">More...</a><br /></td></tr>
<tr class="separator:a445f09096df761a4d48ba32ffdb57927 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ae04c4e59f9c8119b7a211fd403346 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#af4ae04c4e59f9c8119b7a211fd403346">operator&lt;</a> (const <a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer">buffer</a>&lt; T, Dimensions, Allocator &gt; &amp;other) const</td></tr>
<tr class="memdesc:af4ae04c4e59f9c8119b7a211fd403346 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inferior operator.  <a href="#af4ae04c4e59f9c8119b7a211fd403346">More...</a><br /></td></tr>
<tr class="separator:af4ae04c4e59f9c8119b7a211fd403346 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d54fda7a26b050675625e095291620 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a37d54fda7a26b050675625e095291620">hash</a> () const</td></tr>
<tr class="memdesc:a37d54fda7a26b050675625e095291620 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward the hashing for unordered containers to the implementation.  <a href="#a37d54fda7a26b050675625e095291620">More...</a><br /></td></tr>
<tr class="separator:a37d54fda7a26b050675625e095291620 inherit pub_methods_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa7af4601cd80726f31c011162e0a3876"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> = <a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html">detail::shared_ptr_implementation</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; T, Dimensions, Allocator &gt;, <a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer__waiter">detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt;&gt;</td></tr>
<tr class="separator:aa7af4601cd80726f31c011162e0a3876"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;</a></td></tr>
<tr class="memitem:a5da30706edae995aa3f51436de112c54 inherit pub_attribs_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer__waiter">detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a></td></tr>
<tr class="memdesc:a5da30706edae995aa3f51436de112c54 inherit pub_attribs_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation forward everything to this... implementation.  <a href="#a5da30706edae995aa3f51436de112c54">More...</a><br /></td></tr>
<tr class="separator:a5da30706edae995aa3f51436de112c54 inherit pub_attribs_structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt;<br />
class cl::sycl::buffer&lt; T, Dimensions, Allocator &gt;</h3>

<p>&lt;T, Dimensions, Mode, Target&gt;up data Data access and storage in SYCL </p>
<p>A SYCL buffer is a multidimensional variable length array (Ã  la C99 VLA or even Fortran before) that is used to store data to work on.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000061">Todo:</a></b></dt><dd>We have some read-write buffers and some read-only buffers, according to the constructor called. So we could have some static checking for correctness with the accessors used, but we do not have a way in the specification to have a read-only buffer type for this.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000062">Todo:</a></b></dt><dd>There is a naming inconsistency in the specification between buffer and accessor on T versus datatype</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000063">Todo:</a></b></dt><dd>Finish allocator implementation</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000064">Todo:</a></b></dt><dd>Think about the need of an allocator when constructing a buffer from other buffers</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd>Add constructors from arrays so that in C++17 the range and type can be infered from the constructor</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000066">Todo:</a></b></dt><dd>Add constructors from array_ref </dd></dl>

<p>Definition at line <a class="el" href="accessor_8hpp_source.html#l00027">27</a> of file <a class="el" href="accessor_8hpp_source.html">accessor.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac573e8eaa158a09ea84df760434d6f26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#ac573e8eaa158a09ea84df760434d6f26">allocator_type</a> =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00073">73</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5529e4c07422297be4814e19e02def0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#a5529e4c07422297be4814e19e02def0f">const_reference</a> =  const <a class="el" href="classcl_1_1sycl_1_1buffer.html#abf509183b12f7183dd8b065c05d651bd">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00072">72</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa7af4601cd80726f31c011162e0a3876"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> =  <a class="el" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html">detail::shared_ptr_implementation</a>&lt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt;T, Dimensions, Allocator&gt;, <a class="el" href="group__data.html#classcl_1_1sycl_1_1detail_1_1buffer__waiter">detail::buffer_waiter</a>&lt;T, Dimensions, Allocator&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00081">81</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8326722c12afd6532d7cbf9f3e31ebc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#a8326722c12afd6532d7cbf9f3e31ebc3">reference</a> =  <a class="el" href="classcl_1_1sycl_1_1buffer.html#abf509183b12f7183dd8b065c05d651bd">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00071">71</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf509183b12f7183dd8b065c05d651bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html#abf509183b12f7183dd8b065c05d651bd">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The STL-like types. </p>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00070">70</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abc8d8dc747f1a22a73b1355b0f5cf83a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use default constructors so that we can create a new buffer copy from another one, with either a l-value or an r-value (for std::move() for example). </p>
<p>Since we just copy the shared_ptr&lt;&gt; from the shared_ptr_implementation above, this is where/how the sharing magic is happening with reference counting in this case. </p>

<p>Referenced by <a class="el" href="buffer_8hpp_source.html#l00243">cl::sycl::buffer&lt; T, Dimensions, Allocator &gt;::buffer()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_abc8d8dc747f1a22a73b1355b0f5cf83a_icgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_abc8d8dc747f1a22a73b1355b0f5cf83a_icgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_abc8d8dc747f1a22a73b1355b0f5cf83a_icgraph" id="classcl_1_1sycl_1_1buffer_abc8d8dc747f1a22a73b1355b0f5cf83a_icgraph">
<area shape="rect" id="node2" href="classcl_1_1sycl_1_1buffer.html#a3109897dc50638c1dd38793605c8d53e" title="Create a new buffer which is initialized by host_data. " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2ba20634eab3fa3d1a47d773dff29366"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer of the given size with storage managed by the SYCL runtime. </p>
<p>The default behavior is to use the default host buffer allocator, in order to allow for host accesses. If the type of the buffer, has the const qualifier, then the default allocator will remove the qualifier to allow host access to the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00111">111</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="buffer__waiter_8hpp_source.html#l00080">cl::sycl::detail::waiter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                                                           {})</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    : <a class="code" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> { <a class="code" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                                        { r }) }</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;      {}</div><div class="ttc" id="group__data_html_ga8ab7a85d388ba8446c5435cdb1927102"><div class="ttname"><a href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">cl::sycl::detail::waiter</a></div><div class="ttdeci">auto waiter(detail::buffer&lt; T, Dimensions &gt; *b)</div><div class="ttdoc">Helper function to create a new buffer_waiter. </div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00080">buffer_waiter.hpp:80</a></div></div>
<div class="ttc" id="classcl_1_1sycl_1_1buffer_html_aa7af4601cd80726f31c011162e0a3876"><div class="ttname"><a href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">cl::sycl::buffer::implementation_t</a></div><div class="ttdeci">detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;&gt; implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00081">buffer.hpp:81</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a2ba20634eab3fa3d1a47d773dff29366_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a2ba20634eab3fa3d1a47d773dff29366_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a2ba20634eab3fa3d1a47d773dff29366_cgraph" id="classcl_1_1sycl_1_1buffer_a2ba20634eab3fa3d1a47d773dff29366_cgraph">
<area shape="rect" id="node2" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102" title="Helper function to create a new buffer_waiter. " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a29fec85df535a86586a83d2cbe1a7102"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#gac9d61f5d9836dfcb2cbfb41a895dc04b" title="The default buffer allocator used by the runtime, when no allocator is defined by the user...">cl::sycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The host address is const T, so the host accesses can be read-only.</p>
<p>However, the typename T is not const so the device accesses can be both read and write accesses. Since, the host_data is const, this buffer is only initialized with this memory and there is no write after its destruction, unless there is another final data address given after construction of the buffer. </p>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00136">136</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="buffer__waiter_8hpp_source.html#l00080">cl::sycl::detail::waiter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                               {})</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    : <a class="code" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> { <a class="code" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            { host_data, r }) }</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  {}</div><div class="ttc" id="group__data_html_ga8ab7a85d388ba8446c5435cdb1927102"><div class="ttname"><a href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">cl::sycl::detail::waiter</a></div><div class="ttdeci">auto waiter(detail::buffer&lt; T, Dimensions &gt; *b)</div><div class="ttdoc">Helper function to create a new buffer_waiter. </div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00080">buffer_waiter.hpp:80</a></div></div>
<div class="ttc" id="classcl_1_1sycl_1_1buffer_html_aa7af4601cd80726f31c011162e0a3876"><div class="ttname"><a href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">cl::sycl::buffer::implementation_t</a></div><div class="ttdeci">detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;&gt; implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00081">buffer.hpp:81</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a29fec85df535a86586a83d2cbe1a7102_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a29fec85df535a86586a83d2cbe1a7102_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a29fec85df535a86586a83d2cbe1a7102_cgraph" id="classcl_1_1sycl_1_1buffer_a29fec85df535a86586a83d2cbe1a7102_cgraph">
<area shape="rect" id="node2" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102" title="Helper function to create a new buffer_waiter. " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae9786890f239a982b072d634ee3eeeb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#gac9d61f5d9836dfcb2cbfb41a895dc04b" title="The default buffer allocator used by the runtime, when no allocator is defined by the user...">cl::sycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The memory is owned by the runtime during the lifetime of the object. Data is copied back to the host unless the user overrides the behavior using the set_final_data method. host_data points to the storage and values used by the buffer and range&lt;dimensions&gt; defines the size. </p>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00160">160</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="buffer__waiter_8hpp_source.html#l00080">cl::sycl::detail::waiter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                                                                         {})</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    : <a class="code" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> { <a class="code" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;            { host_data, r }) }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  {}</div><div class="ttc" id="group__data_html_ga8ab7a85d388ba8446c5435cdb1927102"><div class="ttname"><a href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">cl::sycl::detail::waiter</a></div><div class="ttdeci">auto waiter(detail::buffer&lt; T, Dimensions &gt; *b)</div><div class="ttdoc">Helper function to create a new buffer_waiter. </div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00080">buffer_waiter.hpp:80</a></div></div>
<div class="ttc" id="classcl_1_1sycl_1_1buffer_html_aa7af4601cd80726f31c011162e0a3876"><div class="ttname"><a href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">cl::sycl::buffer::implementation_t</a></div><div class="ttdeci">detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;&gt; implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00081">buffer.hpp:81</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_ae9786890f239a982b072d634ee3eeeb6_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_ae9786890f239a982b072d634ee3eeeb6_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_ae9786890f239a982b072d634ee3eeeb6_cgraph" id="classcl_1_1sycl_1_1buffer_ae9786890f239a982b072d634ee3eeeb6_cgraph">
<area shape="rect" id="node2" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102" title="Helper function to create a new buffer_waiter. " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3205caa44c59fe4f0553861fdc81a80f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a0e818f1ac2ba5084b08dd41ca813ef28">cl::sycl::mutex_class</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated memory, using the data in host_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#gac9d61f5d9836dfcb2cbfb41a895dc04b" title="The default buffer allocator used by the runtime, when no allocator is defined by the user...">cl::sycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The ownership of the host_data is shared between the runtime and the user. In order to enable both the user application and the SYCL runtime to use the same pointer, a <a class="el" href="namespacecl_1_1sycl.html#a0e818f1ac2ba5084b08dd41ca813ef28">cl::sycl::mutex_class</a> is used. The mutex m is locked by the runtime whenever the data is in use and unlocked otherwise. Data is synchronized with host_data, when the mutex is unlocked by the runtime.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>update the specification to replace the pointer by a reference and provide the constructor with and without a mutex </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00187">187</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="unimplemented_8hpp_source.html#l00025">cl::sycl::detail::unimplemented()</a>.</p>
<div class="fragment"><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;                               {}) {</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <a class="code" href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391">detail::unimplemented</a>();</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  }</div><div class="ttc" id="group__helpers_html_gabc18198696a1e2ec4ea6c231a8c90391"><div class="ttname"><a href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391">cl::sycl::detail::unimplemented</a></div><div class="ttdeci">void unimplemented()</div><div class="ttdoc">Display an &quot;unimplemented&quot; message. </div><div class="ttdef"><b>Definition:</b> <a href="unimplemented_8hpp_source.html#l00025">unimplemented.hpp:25</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a3205caa44c59fe4f0553861fdc81a80f_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a3205caa44c59fe4f0553861fdc81a80f_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a3205caa44c59fe4f0553861fdc81a80f_cgraph" id="classcl_1_1sycl_1_1buffer_a3205caa44c59fe4f0553861fdc81a80f_cgraph">
<area shape="rect" id="node2" href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391" title="Display an &quot;unimplemented&quot; message. " alt="" coords="200,5,399,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac181c98d6676240ee42b0d3c22f12fc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated memory, using the data in host_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>is the mutex used to protect the data access</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#gac9d61f5d9836dfcb2cbfb41a895dc04b" title="The default buffer allocator used by the runtime, when no allocator is defined by the user...">cl::sycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The ownership of the host_data is shared between the runtime and the user. In order to enable both the user application and the SYCL runtime to use the same pointer, a <a class="el" href="namespacecl_1_1sycl.html#a0e818f1ac2ba5084b08dd41ca813ef28">cl::sycl::mutex_class</a> is used.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000068">Todo:</a></b></dt><dd>add this mutex-less constructor to the specification </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00215">215</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="buffer__waiter_8hpp_source.html#l00080">cl::sycl::detail::waiter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;                               {})</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    : <a class="code" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> { <a class="code" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            { host_data, buffer_range }) }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  {}</div><div class="ttc" id="group__data_html_ga8ab7a85d388ba8446c5435cdb1927102"><div class="ttname"><a href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">cl::sycl::detail::waiter</a></div><div class="ttdeci">auto waiter(detail::buffer&lt; T, Dimensions &gt; *b)</div><div class="ttdoc">Helper function to create a new buffer_waiter. </div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00080">buffer_waiter.hpp:80</a></div></div>
<div class="ttc" id="classcl_1_1sycl_1_1buffer_html_aa7af4601cd80726f31c011162e0a3876"><div class="ttname"><a href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">cl::sycl::buffer::implementation_t</a></div><div class="ttdeci">detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;&gt; implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00081">buffer.hpp:81</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_ac181c98d6676240ee42b0d3c22f12fc3_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_ac181c98d6676240ee42b0d3c22f12fc3_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_ac181c98d6676240ee42b0d3c22f12fc3_cgraph" id="classcl_1_1sycl_1_1buffer_ac181c98d6676240ee42b0d3c22f12fc3_cgraph">
<area shape="rect" id="node2" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102" title="Helper function to create a new buffer_waiter. " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3109897dc50638c1dd38793605c8d53e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename D  = std::default_delete&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a7297c7f7107f609a00c08c1808f4b765">unique_ptr_class</a>&lt; T, D &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer which is initialized by host_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used to initialize the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#gac9d61f5d9836dfcb2cbfb41a895dc04b" title="The default buffer allocator used by the runtime, when no allocator is defined by the user...">cl::sycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The SYCL runtime receives full ownership of the host_data unique_ptr and there in effect there is no synchronization with the application code using host_data.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000069">Todo:</a></b></dt><dd>Update the API to add template &lt;typename D = std::default_delete&lt;T&gt;&gt; because the unique_ptr_class/std::unique_ptr have the destructor type as dependent </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00243">243</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="classcl_1_1sycl_1_1buffer.html#abc8d8dc747f1a22a73b1355b0f5cf83a">cl::sycl::buffer&lt; T, Dimensions, Allocator &gt;::buffer()</a>.</p>
<div class="fragment"><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                               {})</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  <span class="comment">// Just delegate to the constructor with normal pointer</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    : <a class="code" href="classcl_1_1sycl_1_1buffer.html#abc8d8dc747f1a22a73b1355b0f5cf83a">buffer</a>(host_data.get(), buffer_range, allocator) {</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="comment">// Then release the host_data memory</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    host_data.release();</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  }</div><div class="ttc" id="classcl_1_1sycl_1_1buffer_html_abc8d8dc747f1a22a73b1355b0f5cf83a"><div class="ttname"><a href="classcl_1_1sycl_1_1buffer.html#abc8d8dc747f1a22a73b1355b0f5cf83a">cl::sycl::buffer::buffer</a></div><div class="ttdeci">buffer()=default</div><div class="ttdoc">Use default constructors so that we can create a new buffer copy from another one, with either a l-value or an r-value (for std::move() for example). </div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a3109897dc50638c1dd38793605c8d53e_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a3109897dc50638c1dd38793605c8d53e_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a3109897dc50638c1dd38793605c8d53e_cgraph" id="classcl_1_1sycl_1_1buffer_a3109897dc50638c1dd38793605c8d53e_cgraph">
<area shape="rect" id="node2" href="classcl_1_1sycl_1_1buffer.html#abc8d8dc747f1a22a73b1355b0f5cf83a" title="Use default constructors so that we can create a new buffer copy from another one, with either a l&#45;value or an r&#45;value (for std::move() for example). " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a52288588ec69fafceabfacad98fa1f40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator , typename ValueType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>start_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new allocated 1D buffer initialized from the given elements ranging from first up to one before last. </p>
<p>The data is copied to an intermediate memory position by the runtime. Data is written back to the same iterator set if the iterator is not a const iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start_iterator</td><td>points to the first element to copy</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_iterator</td><td>points to just after the last element to copy</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#gac9d61f5d9836dfcb2cbfb41a895dc04b" title="The default buffer allocator used by the runtime, when no allocator is defined by the user...">cl::sycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000070">Todo:</a></b></dt><dd>Implement the copy back at buffer destruction</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000071">Todo:</a></b></dt><dd>Generalize this for n-D and provide column-major and row-major initialization</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000072">Todo:</a></b></dt><dd>a reason to have this nD is that set_final_data(weak_ptr_class&lt;T&gt; &amp; finalData) is actually doing this linearization anyway</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000073">Todo:</a></b></dt><dd>Allow read-only buffer construction too</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000074">Todo:</a></b></dt><dd>update the specification to deal with forward iterators instead and rewrite back only when it is non const and output iterator at least</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000075">Todo:</a></b></dt><dd>Allow initialization from ranges and collections Ã  la STL </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00290">290</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="buffer__waiter_8hpp_source.html#l00080">cl::sycl::detail::waiter()</a>.</p>
<div class="fragment"><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                               {}) :</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <a class="code" href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">implementation_t</a> { <a class="code" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            { start_iterator, end_iterator }) }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  {}</div><div class="ttc" id="group__data_html_ga8ab7a85d388ba8446c5435cdb1927102"><div class="ttname"><a href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102">cl::sycl::detail::waiter</a></div><div class="ttdeci">auto waiter(detail::buffer&lt; T, Dimensions &gt; *b)</div><div class="ttdoc">Helper function to create a new buffer_waiter. </div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00080">buffer_waiter.hpp:80</a></div></div>
<div class="ttc" id="classcl_1_1sycl_1_1buffer_html_aa7af4601cd80726f31c011162e0a3876"><div class="ttname"><a href="classcl_1_1sycl_1_1buffer.html#aa7af4601cd80726f31c011162e0a3876">cl::sycl::buffer::implementation_t</a></div><div class="ttdeci">detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;&gt; implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00081">buffer.hpp:81</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a52288588ec69fafceabfacad98fa1f40_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a52288588ec69fafceabfacad98fa1f40_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a52288588ec69fafceabfacad98fa1f40_cgraph" id="classcl_1_1sycl_1_1buffer_a52288588ec69fafceabfacad98fa1f40_cgraph">
<area shape="rect" id="node2" href="group__data.html#ga8ab7a85d388ba8446c5435cdb1927102" title="Helper function to create a new buffer_waiter. " alt="" coords="200,5,347,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a48561f28439b7aecccd5926be126e2e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; T, Dimensions, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1id">id</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classcl_1_1sycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new sub-buffer without allocation to have separate accessors later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>is the buffer with the real data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_index</td><td>specifies the origin of the sub-buffer inside the buffer b</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_range</td><td>specifies the size of the sub-buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd>To be implemented</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000077">Todo:</a></b></dt><dd>Update the specification to replace index by id </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00312">312</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="unimplemented_8hpp_source.html#l00025">cl::sycl::detail::unimplemented()</a>.</p>
<div class="fragment"><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                               {}) { <a class="code" href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391">detail::unimplemented</a>(); }</div><div class="ttc" id="group__helpers_html_gabc18198696a1e2ec4ea6c231a8c90391"><div class="ttname"><a href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391">cl::sycl::detail::unimplemented</a></div><div class="ttdeci">void unimplemented()</div><div class="ttdoc">Display an &quot;unimplemented&quot; message. </div><div class="ttdef"><b>Definition:</b> <a href="unimplemented_8hpp_source.html#l00025">unimplemented.hpp:25</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a48561f28439b7aecccd5926be126e2e3_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a48561f28439b7aecccd5926be126e2e3_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a48561f28439b7aecccd5926be126e2e3_cgraph" id="classcl_1_1sycl_1_1buffer_a48561f28439b7aecccd5926be126e2e3_cgraph">
<area shape="rect" id="node2" href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391" title="Display an &quot;unimplemented&quot; message. " alt="" coords="200,5,399,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a198b3dc4305b1d112ee5bd2cb4b9a26d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::<a class="el" href="classcl_1_1sycl_1_1buffer.html">buffer</a> </td>
          <td>(</td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>mem_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classcl_1_1sycl_1_1queue">queue</a>&#160;</td>
          <td class="paramname"><em>from_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcl_1_1sycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>available_event</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a buffer from an existing OpenCL memory object associated with a context after waiting for an event signaling the availability of the OpenCL data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mem_object</td><td>is the OpenCL memory object to use</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">from_queue</td><td>is the queue associated to the memory object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">available_event</td><td>specifies the event to wait for if non null</td></tr>
  </table>
  </dd>
</dl>
<p>Note that a buffer created from a cl_mem object will only have one underlying cl_mem for the lifetime of the buffer and use on an incompatible queue constitues an error.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000078">Todo:</a></b></dt><dd>To be implemented</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000079">Todo:</a></b></dt><dd>Improve the specification to allow CLHPP objects too </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00339">339</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598acb1529b5988261a81704f0f39d6c287b">cl::sycl::access::global_buffer</a>, and <a class="el" href="unimplemented_8hpp_source.html#l00025">cl::sycl::detail::unimplemented()</a>.</p>
<div class="fragment"><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                 {},</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;         Allocator allocator = {}) { <a class="code" href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391">detail::unimplemented</a>();  }</div><div class="ttc" id="group__helpers_html_gabc18198696a1e2ec4ea6c231a8c90391"><div class="ttname"><a href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391">cl::sycl::detail::unimplemented</a></div><div class="ttdeci">void unimplemented()</div><div class="ttdoc">Display an &quot;unimplemented&quot; message. </div><div class="ttdef"><b>Definition:</b> <a href="unimplemented_8hpp_source.html#l00025">unimplemented.hpp:25</a></div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classcl_1_1sycl_1_1buffer_a198b3dc4305b1d112ee5bd2cb4b9a26d_cgraph.png" border="0" usemap="#classcl_1_1sycl_1_1buffer_a198b3dc4305b1d112ee5bd2cb4b9a26d_cgraph" alt=""/></div>
<map name="classcl_1_1sycl_1_1buffer_a198b3dc4305b1d112ee5bd2cb4b9a26d_cgraph" id="classcl_1_1sycl_1_1buffer_a198b3dc4305b1d112ee5bd2cb4b9a26d_cgraph">
<area shape="rect" id="node2" href="group__helpers.html#gabc18198696a1e2ec4ea6c231a8c90391" title="Display an &quot;unimplemented&quot; message. " alt="" coords="200,5,399,32"/>
</map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1e5d63a2931ac9dc650320487ac21a31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;access::mode Mode, access::target Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classcl_1_1sycl_1_1accessor">accessor</a>&lt;T, Dimensions, Mode, Target&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classcl_1_1sycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an accessor to the buffer with the required mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Mode</td><td>is the requested access mode</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Target</td><td>is the type of object to be accessed</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command_group_handler</td><td>is the command group handler in which the kernel is to be executed</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000080">Todo:</a></b></dt><dd>Do we need for an accessor to increase the reference count of a buffer object? It does make more sense for a host-side accessor.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>Implement the modes and targets </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00365">365</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598ade1df516592d6089a5a1d4c9280f257b">cl::sycl::access::constant_buffer</a>, <a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598acb1529b5988261a81704f0f39d6c287b">cl::sycl::access::global_buffer</a>, and <a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598aa0599d72026e3c6df4a0488cdf4e18d7">cl::sycl::access::host_buffer</a>.</p>
<div class="fragment"><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                                             {</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    static_assert(Target == <a class="code" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598acb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                  || Target == <a class="code" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598ade1df516592d6089a5a1d4c9280f257b">access::target::constant_buffer</a>,</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;                  <span class="stringliteral">&quot;get_access(handler) can only deal with access::global_buffer&quot;</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;                  <span class="stringliteral">&quot; or access::constant_buffer (for host_buffer accessor&quot;</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;                  <span class="stringliteral">&quot; do not use a command group handler&quot;</span>);</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">return</span> { *<span class="keyword">this</span>, command_group_handler };</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  }</div><div class="ttc" id="namespacecl_1_1sycl_1_1access_html_a54d2e6e700c92ce57c6fe2ba91432598ade1df516592d6089a5a1d4c9280f257b"><div class="ttname"><a href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598ade1df516592d6089a5a1d4c9280f257b">cl::sycl::access::target::constant_buffer</a></div></div>
<div class="ttc" id="namespacecl_1_1sycl_1_1access_html_a54d2e6e700c92ce57c6fe2ba91432598acb1529b5988261a81704f0f39d6c287b"><div class="ttname"><a href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598acb1529b5988261a81704f0f39d6c287b">cl::sycl::access::target::global_buffer</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9b25b30e20f4a2ebda0d58343949711a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;access::mode Mode, access::target Target = access::target::host_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classcl_1_1sycl_1_1accessor">accessor</a>&lt;T, Dimensions, Mode, Target&gt; <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a host accessor to the buffer with the required mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mode</td><td>is the requested access mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd>Implement the modes</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd>More elegant solution </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00386">386</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598aa0599d72026e3c6df4a0488cdf4e18d7">cl::sycl::access::host_buffer</a>.</p>
<div class="fragment"><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;               {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    static_assert(Target == <a class="code" href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598aa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>,</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                  <span class="stringliteral">&quot;get_access() without a command group handler is only&quot;</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;                  <span class="stringliteral">&quot; for host_buffer accessor&quot;</span>);</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="keywordflow">return</span> { *<span class="keyword">this</span> };</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  }</div><div class="ttc" id="namespacecl_1_1sycl_1_1access_html_a54d2e6e700c92ce57c6fe2ba91432598aa0599d72026e3c6df4a0488cdf4e18d7"><div class="ttname"><a href="namespacecl_1_1sycl_1_1access.html#a54d2e6e700c92ce57c6fe2ba91432598aa0599d72026e3c6df4a0488cdf4e18d7">cl::sycl::access::target::host_buffer</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abb46db7f86f0f153e8d67ffbd3cae5e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in the buffer. </p>
<p>Equal to <a class="el" href="classcl_1_1sycl_1_1buffer.html#ae8471b53f94001e70de54c38e088822e" title="Return a range object representing the size of the buffer in terms of number of elements in each dime...">get_range()</a>[0] * ... * <a class="el" href="classcl_1_1sycl_1_1buffer.html#ae8471b53f94001e70de54c38e088822e" title="Return a range object representing the size of the buffer in terms of number of elements in each dime...">get_range()</a>[dimensions-1]. </p>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00415">415</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="shared__ptr__implementation_8hpp_source.html#l00043">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a>.</p>
<div class="fragment"><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                         {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a>-&gt;implementation-&gt;get_count();</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;  }</div><div class="ttc" id="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation_html_a5da30706edae995aa3f51436de112c54"><div class="ttname"><a href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00043">shared_ptr_implementation.hpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae8471b53f94001e70de54c38e088822e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000084">Todo:</a></b></dt><dd>rename to the equivalent from array_ref proposals? Such as size() in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0009r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0009r2.html</a> </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00402">402</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="shared__ptr__implementation_8hpp_source.html#l00043">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a>.</p>
<div class="fragment"><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;                         {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    <span class="comment">/* Interpret the shape which is a pointer to the first element as an</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment">       array of Dimensions elements so that the range&lt;Dimensions&gt;</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment">       constructor is happy with this collection</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a>-&gt;implementation-&gt;get_range();</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  }</div><div class="ttc" id="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation_html_a5da30706edae995aa3f51436de112c54"><div class="ttname"><a href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00043">shared_ptr_implementation.hpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aef172cb6ab104ef307e120260e19ed76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the buffer storage in bytes. </p>
<p>Equal to <a class="el" href="classcl_1_1sycl_1_1buffer.html#abb46db7f86f0f153e8d67ffbd3cae5e3" title="Returns the total number of elements in the buffer. ">get_count()</a>*sizeof(T).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo:</a></b></dt><dd>rename to something else. In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0122r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0122r0.pdf</a> it is named bytes() for example </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00428">428</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="shared__ptr__implementation_8hpp_source.html#l00043">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a>.</p>
<div class="fragment"><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                          {</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a>-&gt;implementation-&gt;get_size();</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  }</div><div class="ttc" id="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation_html_a5da30706edae995aa3f51436de112c54"><div class="ttname"><a href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00043">shared_ptr_implementation.hpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a85670971c793b40a612ce48c76b12f22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::is_read_only </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask for read-only status of the buffer. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000087">Todo:</a></b></dt><dd>Add to specification </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00455">455</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="shared__ptr__implementation_8hpp_source.html#l00043">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a>.</p>
<div class="fragment"><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                            {</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a>-&gt;implementation-&gt;read_only;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  }</div><div class="ttc" id="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation_html_a5da30706edae995aa3f51436de112c54"><div class="ttname"><a href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00043">shared_ptr_implementation.hpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a26d6f5eab3e26d0dd5dde0ecdf931ea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecl_1_1sycl.html#a8cc65d5e679773a053245819fa2a13de">weak_ptr_class</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>finalData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set destination of buffer data on destruction. </p>
<p>The finalData points to the host memory to which, the outcome of all the buffer processing is going to be copied to.</p>
<p>This is the final pointer, which is going to be accessible after the destruction of the buffer and in the case where this is a valid pointer, the data are going to be copied to this host address.</p>
<p>finalData is different from the original host address, if the buffer was created associated with one. This is mainly to be used when a shared_ptr is given in the constructor and the output data will reside in a different location from the initialization data.</p>
<p>It is defined as a weak_ptr referring to a shared_ptr that is not associated with the <a class="el" href="classcl_1_1sycl_1_1buffer.html" title="&lt;T, Dimensions, Mode, Target&gt;up data Data access and storage in SYCL ">cl::sycl::buffer</a>, and so the <a class="el" href="classcl_1_1sycl_1_1buffer.html" title="&lt;T, Dimensions, Mode, Target&gt;up data Data access and storage in SYCL ">cl::sycl::buffer</a> will have no ownership of finalData.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000088">Todo:</a></b></dt><dd>Update the API to take finalData by value instead of by reference. This way we can have an implicit conversion possible at the API call from a shared_ptr&lt;&gt;, avoiding an explicit weak_ptr&lt;&gt; creation</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000089">Todo:</a></b></dt><dd>figure out how <a class="el" href="classcl_1_1sycl_1_1buffer.html#a26d6f5eab3e26d0dd5dde0ecdf931ea0" title="Set destination of buffer data on destruction. ">set_final_data()</a> interact with the other way to write back some data or with some data sharing with the host that can not be undone </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00487">487</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="shared__ptr__implementation_8hpp_source.html#l00043">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a>.</p>
<div class="fragment"><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                                                   {</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <a class="code" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a>-&gt;implementation-&gt;set_final_data(std::move(finalData));</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  }</div><div class="ttc" id="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation_html_a5da30706edae995aa3f51436de112c54"><div class="ttname"><a href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00043">shared_ptr_implementation.hpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9d4290e039c4fa36b99eef6411708ea9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t Dimensions = 1, typename Allocator = buffer_allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buffers that are shared/referenced. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer&lt;int&gt;</a> b { 1000 };</div><div class="line"><span class="comment">// Here b.use_count() should return 1</span></div><div class="line"><a class="code" href="classcl_1_1sycl_1_1buffer.html">cl::sycl::buffer&lt;int&gt;</a> c { b };</div><div class="line"><span class="comment">// Here b.use_count() and b.use_count() should return 2</span></div></div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo:</a></b></dt><dd>Add to the specification, useful for validation </dd></dl>

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00445">445</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

<p>References <a class="el" href="shared__ptr__implementation_8hpp_source.html#l00043">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a>.</p>
<div class="fragment"><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;                         {</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="comment">// Rely on the shared_ptr&lt;&gt; use_count()</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">implementation</a>.use_count();</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  }</div><div class="ttc" id="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation_html_a5da30706edae995aa3f51436de112c54"><div class="ttname"><a href="structcl_1_1sycl_1_1detail_1_1shared__ptr__implementation.html#a5da30706edae995aa3f51436de112c54">cl::sycl::detail::shared_ptr_implementation&lt; buffer&lt; T, Dimensions, Allocator &gt;, detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer_waiter&lt; T, Dimensions, Allocator &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation. </div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00043">shared_ptr_implementation.hpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/CL/sycl/<a class="el" href="accessor_8hpp_source.html">accessor.hpp</a></li>
<li>include/CL/sycl/<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Oct 26 2016 12:28:40 for triSYCL implementation of OpenCL SYCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
