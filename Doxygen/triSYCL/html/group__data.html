<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>triSYCL implementation of SYCL: Data access and storage in SYCL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">triSYCL implementation of SYCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Data access and storage in SYCL</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Data access and storage in SYCL:</div>
<div class="dyncontent">
<div class="center"><img src="group__data.png" border="0" usemap="#agroup____data" alt=""/></div>
<map name="agroup____data" id="agroup____data">
<area shape="rect" href="group__address__spaces.html" title=" " alt="" coords="307,5,453,45"/>
<area shape="rect" title=" " alt="" coords="5,5,173,45"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetrisycl_1_1access"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1access.html">trisycl::access</a></td></tr>
<tr class="memdesc:namespacetrisycl_1_1access"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describe the type of access by kernels. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout">trisycl::vendor::trisycl::pipe::cout</a></td></tr>
<tr class="memdesc:classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout"><td class="mdescLeft">&#160;</td><td class="mdescRight">triSYCL extension for SYCL pipe object sending data to std::cout  <a href="group__data.html#classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1accessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor&lt; DataType, Dimensions, AccessMode, Target &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accessor abstracts the way buffer or pipe data are accessed inside a kernel in a multidimensional variable length array way.  <a href="group__data.html#classtrisycl_1_1accessor">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">trisycl::detail::accessor_base</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer data types.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local accessor specialization abstracts the way local memory is allocated to a kernel to be shared between work-items of the same work-group.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1buffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer&lt; T, Dimensions, Allocator &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that is used to store data to work on.  <a href="group__data.html#classtrisycl_1_1buffer">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional variable length array way.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1buffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that is used to store data to work on.  <a href="group__data.html#classtrisycl_1_1detail_1_1buffer">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1buffer__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">trisycl::detail::buffer_base</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1buffer__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize some template independent buffer aspects in a base class.  <a href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1buffer__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1buffer__waiter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">trisycl::detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1buffer__waiter"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to wait for the final buffer destruction if the conditions for blocking are met.  <a href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1buffer__waiter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1image"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#structtrisycl_1_1image">trisycl::image&lt; Dimensions &gt;</a></td></tr>
<tr class="separator:structtrisycl_1_1image"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1pipe"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1pipe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL pipe object.  <a href="group__data.html#classtrisycl_1_1pipe">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1pipe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga97d78bc6e06d272d46df6824d686cf45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97d78bc6e06d272d46df6824d686cf45"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45">trisycl::buffer_allocator</a> = std::allocator&lt; T &gt;</td></tr>
<tr class="memdesc:ga97d78bc6e06d272d46df6824d686cf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator objects give the programmer some control on how the memory is allocated inside SYCL.  <a href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45">More...</a><br /></td></tr>
<tr class="separator:ga97d78bc6e06d272d46df6824d686cf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d70ad5a942e9f5796851e699254ac57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2d70ad5a942e9f5796851e699254ac57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga2d70ad5a942e9f5796851e699254ac57">trisycl::image_allocator</a> = std::allocator&lt; T &gt;</td></tr>
<tr class="memdesc:ga2d70ad5a942e9f5796851e699254ac57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator used for the <code>image</code> inside SYCL.  <a href="group__data.html#ga2d70ad5a942e9f5796851e699254ac57">More...</a><br /></td></tr>
<tr class="separator:ga2d70ad5a942e9f5796851e699254ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae530ec4a956b74088b45ee1ef2f5e492"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae530ec4a956b74088b45ee1ef2f5e492"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gae530ec4a956b74088b45ee1ef2f5e492">trisycl::map_allocator</a> = std::allocator&lt; T &gt;</td></tr>
<tr class="memdesc:gae530ec4a956b74088b45ee1ef2f5e492"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator used to map the memory at the same place.  <a href="group__data.html#gae530ec4a956b74088b45ee1ef2f5e492">More...</a><br /></td></tr>
<tr class="separator:gae530ec4a956b74088b45ee1ef2f5e492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb39bd9d956d552c0a7b811158d6c31d"><td class="memTemplParams" colspan="2">template&lt;std::forward_iterator FIB, std::forward_iterator FIE&gt; </td></tr>
<tr class="memitem:gacb39bd9d956d552c0a7b811158d6c31d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d">trisycl::buffer</a> (FIB begin, FIE end) -&gt; <a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; typename std::iterator_traits&lt; FIB &gt;::value_type, 1 &gt;</td></tr>
<tr class="memdesc:gacb39bd9d956d552c0a7b811158d6c31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deduction guide to infer the buffer type from the read-write forward iterators into a copy-in on construction and copy-back on destruction.  <a href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d">More...</a><br /></td></tr>
<tr class="separator:gacb39bd9d956d552c0a7b811158d6c31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9490f033582adcc4b953b1942929af9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga9490f033582adcc4b953b1942929af9e">trisycl::buffer</a> (auto &amp;host_data) -&gt; <a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; std::ranges::range_value_t&lt; decltype(host_data)&gt;, 1 &gt;</td></tr>
<tr class="memdesc:ga9490f033582adcc4b953b1942929af9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deduction guide to infer the buffer type from the read-write range.  <a href="group__data.html#ga9490f033582adcc4b953b1942929af9e">More...</a><br /></td></tr>
<tr class="separator:ga9490f033582adcc4b953b1942929af9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="memTemplParams" colspan="2">template&lt;typename BufferDetail &gt; </td></tr>
<tr class="memitem:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7">trisycl::detail::buffer_add_to_task</a> (BufferDetail buf, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function to avoid some circular type recursion.  <a href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7">More...</a><br /></td></tr>
<tr class="separator:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gaae79251ae2eb2eb3f5f1418acf0f1c2f">trisycl::detail::add_buffer_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="separator:gaae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">trisycl::detail::waiter</a> (<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; *<a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>)</td></tr>
<tr class="memdesc:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a new <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a>.  <a href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">More...</a><br /></td></tr>
<tr class="separator:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout" id="classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1vendor_1_1trisycl_1_1pipe_1_1cout">&#9670;&nbsp;</a></span>trisycl::vendor::trisycl::pipe::cout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::vendor::trisycl::pipe::cout</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >triSYCL extension for SYCL pipe object sending data to std::cout </p>
<p >Experiment with a new pipe extension to send data to std::cout with a simplified pipe extension like with:</p>
<div class="fragment"><div class="line">sycl::vendor::trisycl::pipe::cout::write(<span class="stringliteral">&quot;salut !\n&quot;</span>);</div>
<div class="line">sycl::vendor::trisycl::pipe::cout::stream() &lt;&lt; <span class="stringliteral">&quot;hello &quot;</span> &lt;&lt; 42 &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00028">28</a> of file <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html">cout.hpp</a>.</p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:ab23c2ecbca0112f976c864315313010d"><td class="memItemLeft" align="right" valign="top">static auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab23c2ecbca0112f976c864315313010d">stream</a> ()</td></tr>
<tr class="memdesc:ab23c2ecbca0112f976c864315313010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the usual stream interface to std::cout.  <a href="group__data.html#ab23c2ecbca0112f976c864315313010d">More...</a><br /></td></tr>
<tr class="separator:ab23c2ecbca0112f976c864315313010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34fc9b5e0256abc7866ca967eef03a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab34fc9b5e0256abc7866ca967eef03a1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ab34fc9b5e0256abc7866ca967eef03a1">write</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ab34fc9b5e0256abc7866ca967eef03a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send some value to std::cout.  <a href="group__data.html#ab34fc9b5e0256abc7866ca967eef03a1">More...</a><br /></td></tr>
<tr class="separator:ab34fc9b5e0256abc7866ca967eef03a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23c2ecbca0112f976c864315313010d"><td class="memItemLeft" align="right" valign="top">static auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab23c2ecbca0112f976c864315313010d">stream</a> ()</td></tr>
<tr class="memdesc:ab23c2ecbca0112f976c864315313010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the usual stream interface to std::cout.  <a href="group__data.html#ab23c2ecbca0112f976c864315313010d">More...</a><br /></td></tr>
<tr class="separator:ab23c2ecbca0112f976c864315313010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34fc9b5e0256abc7866ca967eef03a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab34fc9b5e0256abc7866ca967eef03a1"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ab34fc9b5e0256abc7866ca967eef03a1">write</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ab34fc9b5e0256abc7866ca967eef03a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send some value to std::cout.  <a href="group__data.html#ab34fc9b5e0256abc7866ca967eef03a1">More...</a><br /></td></tr>
<tr class="separator:ab34fc9b5e0256abc7866ca967eef03a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="ab23c2ecbca0112f976c864315313010d" name="ab23c2ecbca0112f976c864315313010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23c2ecbca0112f976c864315313010d">&#9670;&nbsp;</a></span>stream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto &amp; trisycl::vendor::trisycl::pipe::cout::stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the usual stream interface to std::cout. </p>

<p class="definition">Definition at line <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00033">33</a> of file <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html">cout.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   33</span>                        {</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">return</span> std::cout;</div>
<div class="line"><span class="lineno">   35</span>  }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00039">write()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ab23c2ecbca0112f976c864315313010d_icgraph.png" border="0" usemap="#agroup__data_ab23c2ecbca0112f976c864315313010d_icgraph" alt=""/></div>
<map name="agroup__data_ab23c2ecbca0112f976c864315313010d_icgraph" id="agroup__data_ab23c2ecbca0112f976c864315313010d_icgraph">
<area shape="rect" title="Provide the usual stream interface to std::cout." alt="" coords="200,5,347,47"/>
<area shape="rect" href="group__data.html#ab34fc9b5e0256abc7866ca967eef03a1" title="Send some value to std::cout." alt="" coords="5,5,152,47"/>
</map>
</div>

</div>
</div>
<a id="ab23c2ecbca0112f976c864315313010d" name="ab23c2ecbca0112f976c864315313010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23c2ecbca0112f976c864315313010d">&#9670;&nbsp;</a></span>stream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto &amp; trisycl::vendor::trisycl::pipe::cout::stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the usual stream interface to std::cout. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00033">33</a> of file <a class="el" href="triSYCL_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html">cout.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   33</span>                        {</div>
<div class="line"><span class="lineno">   34</span>    <span class="keywordflow">return</span> std::cout;</div>
<div class="line"><span class="lineno">   35</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab34fc9b5e0256abc7866ca967eef03a1" name="ab34fc9b5e0256abc7866ca967eef03a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34fc9b5e0256abc7866ca967eef03a1">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trisycl::vendor::trisycl::pipe::cout::write </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send some value to std::cout. </p>

<p class="definition">Definition at line <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00039">39</a> of file <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html">cout.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   39</span>                                    {</div>
<div class="line"><span class="lineno">   40</span>    <a class="code hl_function" href="group__data.html#ab23c2ecbca0112f976c864315313010d">stream</a>() &lt;&lt; value;</div>
<div class="line"><span class="lineno">   41</span>  }</div>
<div class="ttc" id="agroup__data_html_ab23c2ecbca0112f976c864315313010d"><div class="ttname"><a href="group__data.html#ab23c2ecbca0112f976c864315313010d">trisycl::vendor::trisycl::pipe::cout::stream</a></div><div class="ttdeci">static auto &amp; stream()</div><div class="ttdoc">Provide the usual stream interface to std::cout.</div><div class="ttdef"><b>Definition:</b> <a href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00033">cout.hpp:33</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00033">stream()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph.png" border="0" usemap="#agroup__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph" alt=""/></div>
<map name="agroup__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph" id="agroup__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph">
<area shape="rect" title="Send some value to std::cout." alt="" coords="5,5,152,47"/>
<area shape="rect" href="group__data.html#ab23c2ecbca0112f976c864315313010d" title="Provide the usual stream interface to std::cout." alt="" coords="200,5,347,47"/>
</map>
</div>

</div>
</div>
<a id="ab34fc9b5e0256abc7866ca967eef03a1" name="ab34fc9b5e0256abc7866ca967eef03a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34fc9b5e0256abc7866ca967eef03a1">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void trisycl::vendor::trisycl::pipe::cout::write </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send some value to std::cout. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00039">39</a> of file <a class="el" href="triSYCL_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html">cout.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   39</span>                                    {</div>
<div class="line"><span class="lineno">   40</span>    <a class="code hl_function" href="group__data.html#ab23c2ecbca0112f976c864315313010d">stream</a>() &lt;&lt; value;</div>
<div class="line"><span class="lineno">   41</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="sycl_2vendor_2triSYCL_2pipe_2cout_8hpp_source.html#l00033">stream()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph.png" border="0" usemap="#agroup__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph" alt=""/></div>
<map name="agroup__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph" id="agroup__data_ab34fc9b5e0256abc7866ca967eef03a1_cgraph">
<area shape="rect" title="Send some value to std::cout." alt="" coords="5,5,152,47"/>
<area shape="rect" href="group__data.html#ab23c2ecbca0112f976c864315313010d" title="Provide the usual stream interface to std::cout." alt="" coords="200,5,347,47"/>
</map>
</div>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1accessor" id="classtrisycl_1_1accessor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1accessor">&#9670;&nbsp;</a></span>trisycl::accessor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::accessor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename DataType, int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt;<br />
class trisycl::accessor&lt; DataType, Dimensions, AccessMode, Target &gt;</div><p >The accessor abstracts the way buffer or pipe data are accessed inside a kernel in a multidimensional variable length array way. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000058">Todo:</a></b></dt><dd>Implement it for images according so section 3.3.4.5 </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00054">54</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::accessor&lt; DataType, Dimensions, AccessMode, Target &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1accessor__inherit__graph.png" border="0" usemap="#atrisycl_1_1accessor_3_01DataType_00_01Dimensions_00_01AccessMode_00_01Target_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1accessor_3_01DataType_00_01Dimensions_00_01AccessMode_00_01Target_01_4_inherit__map" id="atrisycl_1_1accessor_3_01DataType_00_01Dimensions_00_01AccessMode_00_01Target_01_4_inherit__map">
<area shape="rect" title="The accessor abstracts the way buffer or pipe data are accessed inside a kernel in a multidimensional..." alt="" coords="612,119,775,175"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html" title=" " alt="" coords="272,5,564,164"/>
<area shape="rect" title=" " alt="" coords="5,35,224,135"/>
<area shape="rect" href="group__helpers.html" title=" " alt="" coords="317,188,519,229"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::accessor&lt; DataType, Dimensions, AccessMode, Target &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1accessor__coll__graph.png" border="0" usemap="#atrisycl_1_1accessor_3_01DataType_00_01Dimensions_00_01AccessMode_00_01Target_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1accessor_3_01DataType_00_01Dimensions_00_01AccessMode_00_01Target_01_4_coll__map" id="atrisycl_1_1accessor_3_01DataType_00_01Dimensions_00_01AccessMode_00_01Target_01_4_coll__map">
<area shape="rect" title="The accessor abstracts the way buffer or pipe data are accessed inside a kernel in a multidimensional..." alt="" coords="809,246,972,302"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html" title=" " alt="" coords="365,41,657,200"/>
<area shape="rect" title=" " alt="" coords="5,5,224,105"/>
<area shape="rect" href="classstd_1_1shared__ptr_3_01detail_1_1accessor_3_01DataType_00_01Dimensions_00_07std_1_1is__cons2521ddca8b1df7ab78e9954276624121.html" title=" " alt="" coords="15,130,214,245"/>
<area shape="rect" href="group__helpers.html" title=" " alt="" coords="411,224,612,265"/>
<area shape="rect" href="classfriend.html" title=" " alt="" coords="484,290,539,317"/>
<area shape="rect" title=" " alt="" coords="439,341,583,367"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a0d2d6323ca7ff829dbcd81659659f4bb"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a0d2d6323ca7ff829dbcd81659659f4bb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a0d2d6323ca7ff829dbcd81659659f4bb">accessor</a> (<a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; DataType, Dimensions, Allocator &gt; &amp;target_buffer, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:a0d2d6323ca7ff829dbcd81659659f4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer accessor from a buffer using a command group handler object from the command group scope.  <a href="group__data.html#a0d2d6323ca7ff829dbcd81659659f4bb">More...</a><br /></td></tr>
<tr class="separator:a0d2d6323ca7ff829dbcd81659659f4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6089969f8d96f5da20c362d96e1c18"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:a8c6089969f8d96f5da20c362d96e1c18"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a8c6089969f8d96f5da20c362d96e1c18">accessor</a> (<a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; DataType, Dimensions, Allocator &gt; &amp;target_buffer)</td></tr>
<tr class="memdesc:a8c6089969f8d96f5da20c362d96e1c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer accessor from a buffer.  <a href="group__data.html#a8c6089969f8d96f5da20c362d96e1c18">More...</a><br /></td></tr>
<tr class="separator:a8c6089969f8d96f5da20c362d96e1c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfda5ddf6c741d40634ac34682be7f17"><td class="memTemplParams" colspan="2">template&lt;typename Allocator &gt; </td></tr>
<tr class="memitem:acfda5ddf6c741d40634ac34682be7f17"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#acfda5ddf6c741d40634ac34682be7f17">accessor</a> (<a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; DataType, Dimensions, Allocator &gt; &amp;target_buffer, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;<a class="el" href="opencl__spir_8h.html#a30c1789509ffb2ea07b060fc6e1344c1">offset</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>)</td></tr>
<tr class="memdesc:acfda5ddf6c741d40634ac34682be7f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a buffer accessor from a buffer given a specific range for access permissions and an offset that provides the starting point for the access range using a command group handler object from the command group scope.  <a href="group__data.html#acfda5ddf6c741d40634ac34682be7f17">More...</a><br /></td></tr>
<tr class="separator:acfda5ddf6c741d40634ac34682be7f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447c7edd2b1e005a220e4f3f35210a39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a447c7edd2b1e005a220e4f3f35210a39">accessor</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;allocation_size, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:a447c7edd2b1e005a220e4f3f35210a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an accessor of dimension Dimensions with elements of type DataType using the passed range to specify the size in each dimension.  <a href="group__data.html#a447c7edd2b1e005a220e4f3f35210a39">More...</a><br /></td></tr>
<tr class="separator:a447c7edd2b1e005a220e4f3f35210a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62901775a6a0969fdb5f3217d21ed9c7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a62901775a6a0969fdb5f3217d21ed9c7">get_range</a> () const</td></tr>
<tr class="memdesc:a62901775a6a0969fdb5f3217d21ed9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor.  <a href="group__data.html#a62901775a6a0969fdb5f3217d21ed9c7">More...</a><br /></td></tr>
<tr class="separator:a62901775a6a0969fdb5f3217d21ed9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68b1d5990dcc6b3ebbf6a088a6649a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#afa68b1d5990dcc6b3ebbf6a088a6649a">get_count</a> () const</td></tr>
<tr class="memdesc:afa68b1d5990dcc6b3ebbf6a088a6649a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements behind the accessor.  <a href="group__data.html#afa68b1d5990dcc6b3ebbf6a088a6649a">More...</a><br /></td></tr>
<tr class="separator:afa68b1d5990dcc6b3ebbf6a088a6649a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ca883f45754d54a19d51738669f181"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ac9ca883f45754d54a19d51738669f181">get_size</a> () const</td></tr>
<tr class="memdesc:ac9ca883f45754d54a19d51738669f181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying buffer storage in bytes.  <a href="group__data.html#ac9ca883f45754d54a19d51738669f181">More...</a><br /></td></tr>
<tr class="separator:ac9ca883f45754d54a19d51738669f181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8b5b483bc23d0b7cfa8042403deea6"><td class="memTemplParams" colspan="2">template&lt;std::integral... T&gt; </td></tr>
<tr class="memitem:adc8b5b483bc23d0b7cfa8042403deea6"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#adc8b5b483bc23d0b7cfa8042403deea6">operator[]</a> (T... indices)</td></tr>
<tr class="memdesc:adc8b5b483bc23d0b7cfa8042403deea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...].  <a href="group__data.html#adc8b5b483bc23d0b7cfa8042403deea6">More...</a><br /></td></tr>
<tr class="separator:adc8b5b483bc23d0b7cfa8042403deea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d57834b14c240e3543ee4657b076069"><td class="memTemplParams" colspan="2">template&lt;std::integral... T&gt; </td></tr>
<tr class="memitem:a8d57834b14c240e3543ee4657b076069"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a8d57834b14c240e3543ee4657b076069">operator[]</a> (T... indices) const</td></tr>
<tr class="memdesc:a8d57834b14c240e3543ee4657b076069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...].  <a href="group__data.html#a8d57834b14c240e3543ee4657b076069">More...</a><br /></td></tr>
<tr class="separator:a8d57834b14c240e3543ee4657b076069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c73fa2fc8911e5822b5c7cb77d53123"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a1c73fa2fc8911e5822b5c7cb77d53123">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;index)</td></tr>
<tr class="memdesc:a1c73fa2fc8911e5822b5c7cb77d53123"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the accessor with [id&lt;&gt;].  <a href="group__data.html#a1c73fa2fc8911e5822b5c7cb77d53123">More...</a><br /></td></tr>
<tr class="separator:a1c73fa2fc8911e5822b5c7cb77d53123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705d9fd23436356cdc6bfe2e7968f3e8"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a705d9fd23436356cdc6bfe2e7968f3e8">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:a705d9fd23436356cdc6bfe2e7968f3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the accessor with [id&lt;&gt;].  <a href="group__data.html#a705d9fd23436356cdc6bfe2e7968f3e8">More...</a><br /></td></tr>
<tr class="separator:a705d9fd23436356cdc6bfe2e7968f3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508adebd76462b4b6cef37ac2a1aae4"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a1508adebd76462b4b6cef37ac2a1aae4">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;index)</td></tr>
<tr class="memdesc:a1508adebd76462b4b6cef37ac2a1aae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with [item&lt;&gt;].  <a href="group__data.html#a1508adebd76462b4b6cef37ac2a1aae4">More...</a><br /></td></tr>
<tr class="separator:a1508adebd76462b4b6cef37ac2a1aae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d5d55d6effd8a42427d4a2c1d84b85"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ad0d5d55d6effd8a42427d4a2c1d84b85">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:ad0d5d55d6effd8a42427d4a2c1d84b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with [item&lt;&gt;].  <a href="group__data.html#ad0d5d55d6effd8a42427d4a2c1d84b85">More...</a><br /></td></tr>
<tr class="separator:ad0d5d55d6effd8a42427d4a2c1d84b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01680fcb2c6b2940aa5724c73478711b"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a01680fcb2c6b2940aa5724c73478711b">operator[]</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;index)</td></tr>
<tr class="memdesc:a01680fcb2c6b2940aa5724c73478711b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with an [nd_item&lt;&gt;].  <a href="group__data.html#a01680fcb2c6b2940aa5724c73478711b">More...</a><br /></td></tr>
<tr class="separator:a01680fcb2c6b2940aa5724c73478711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a960aae76f100973b60f6364ee63d58"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a6a960aae76f100973b60f6364ee63d58">operator[]</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;index) const</td></tr>
<tr class="memdesc:a6a960aae76f100973b60f6364ee63d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with an [nd_item&lt;&gt;].  <a href="group__data.html#a6a960aae76f100973b60f6364ee63d58">More...</a><br /></td></tr>
<tr class="separator:a6a960aae76f100973b60f6364ee63d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5d8726d7d3d4f9229e90d873c66d9e"><td class="memItemLeft" align="right" valign="top">accessor_detail::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9d5d8726d7d3d4f9229e90d873c66d9e">operator*</a> ()</td></tr>
<tr class="memdesc:a9d5d8726d7d3d4f9229e90d873c66d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of the accessor.  <a href="group__data.html#a9d5d8726d7d3d4f9229e90d873c66d9e">More...</a><br /></td></tr>
<tr class="separator:a9d5d8726d7d3d4f9229e90d873c66d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abcbc1d6e7466903c58e353141e6c03"><td class="memItemLeft" align="right" valign="top">accessor_detail::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a7abcbc1d6e7466903c58e353141e6c03">operator*</a> () const</td></tr>
<tr class="memdesc:a7abcbc1d6e7466903c58e353141e6c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of the accessor.  <a href="group__data.html#a7abcbc1d6e7466903c58e353141e6c03">More...</a><br /></td></tr>
<tr class="separator:a7abcbc1d6e7466903c58e353141e6c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9696f09c436b1367fabbed80bf40b550"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9696f09c436b1367fabbed80bf40b550">get_pointer</a> () const</td></tr>
<tr class="memdesc:a9696f09c436b1367fabbed80bf40b550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the start of the data.  <a href="group__data.html#a9696f09c436b1367fabbed80bf40b550">More...</a><br /></td></tr>
<tr class="separator:a9696f09c436b1367fabbed80bf40b550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f43d5547649f7422b22b70a1b44071b"><td class="memItemLeft" align="right" valign="top">accessor_detail::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a0f43d5547649f7422b22b70a1b44071b">begin</a> () const</td></tr>
<tr class="memdesc:a0f43d5547649f7422b22b70a1b44071b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward all the iterator functions to the implementation.  <a href="group__data.html#a0f43d5547649f7422b22b70a1b44071b">More...</a><br /></td></tr>
<tr class="separator:a0f43d5547649f7422b22b70a1b44071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec64ec068f11fd6c7500bba1b7e7c0"><td class="memItemLeft" align="right" valign="top">accessor_detail::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a78ec64ec068f11fd6c7500bba1b7e7c0">end</a> () const</td></tr>
<tr class="separator:a78ec64ec068f11fd6c7500bba1b7e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9603fb66d3d16c007e21cd45b90a055"><td class="memItemLeft" align="right" valign="top">accessor_detail::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aa9603fb66d3d16c007e21cd45b90a055">cbegin</a> () const</td></tr>
<tr class="separator:aa9603fb66d3d16c007e21cd45b90a055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9be218f1479230487bbb0ba7f5fc96"><td class="memItemLeft" align="right" valign="top">accessor_detail::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a4c9be218f1479230487bbb0ba7f5fc96">cend</a> () const</td></tr>
<tr class="separator:a4c9be218f1479230487bbb0ba7f5fc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95190c4935e5cc94611fe0c897dd218c"><td class="memItemLeft" align="right" valign="top">accessor_detail::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a95190c4935e5cc94611fe0c897dd218c">rbegin</a> () const</td></tr>
<tr class="separator:a95190c4935e5cc94611fe0c897dd218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6724d1704d897db33981351dbf0734"><td class="memItemLeft" align="right" valign="top">accessor_detail::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aee6724d1704d897db33981351dbf0734">rend</a> () const</td></tr>
<tr class="separator:aee6724d1704d897db33981351dbf0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9653e7d488638e91b6f319e993571394"><td class="memItemLeft" align="right" valign="top">accessor_detail::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9653e7d488638e91b6f319e993571394">crbegin</a> () const</td></tr>
<tr class="separator:a9653e7d488638e91b6f319e993571394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713ef2deaa5438c4815f9a745694b0d0"><td class="memItemLeft" align="right" valign="top">accessor_detail::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a713ef2deaa5438c4815f9a745694b0d0">crend</a> () const</td></tr>
<tr class="separator:a713ef2deaa5438c4815f9a745694b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html">trisycl::detail::shared_ptr_implementation&lt; accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt;, detail::accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; &gt;</a></td></tr>
<tr class="memitem:a216dcddf50a237c93e1809a1b2364607 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a216dcddf50a237c93e1809a1b2364607">shared_ptr_implementation</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">detail::accessor</a>&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; &gt; <a class="el" href="opencl__spir_8h.html#a58cbf454cb6069623756197ea924f9fa">i</a>)</td></tr>
<tr class="memdesc:a216dcddf50a237c93e1809a1b2364607 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation directly as a shared pointer.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a216dcddf50a237c93e1809a1b2364607">More...</a><br /></td></tr>
<tr class="separator:a216dcddf50a237c93e1809a1b2364607 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43ad6aba6b17a30a4f9d7e237e25fa1 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#aa43ad6aba6b17a30a4f9d7e237e25fa1">shared_ptr_implementation</a> (<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">detail::accessor</a>&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; *<a class="el" href="opencl__spir_8h.html#a58cbf454cb6069623756197ea924f9fa">i</a>)</td></tr>
<tr class="memdesc:aa43ad6aba6b17a30a4f9d7e237e25fa1 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation takes the ownership from a raw pointer.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#aa43ad6aba6b17a30a4f9d7e237e25fa1">More...</a><br /></td></tr>
<tr class="separator:aa43ad6aba6b17a30a4f9d7e237e25fa1 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeba2f9ac0187cc5ba4bb8813e592f6a inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#aeeba2f9ac0187cc5ba4bb8813e592f6a">shared_ptr_implementation</a> ()=default</td></tr>
<tr class="memdesc:aeeba2f9ac0187cc5ba4bb8813e592f6a inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep all other constructors to have usual shared_ptr behaviour.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#aeeba2f9ac0187cc5ba4bb8813e592f6a">More...</a><br /></td></tr>
<tr class="separator:aeeba2f9ac0187cc5ba4bb8813e592f6a inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb7676f2e4f7e0e69201ab8888ecfc3 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#addb7676f2e4f7e0e69201ab8888ecfc3">hash</a> () const</td></tr>
<tr class="memdesc:addb7676f2e4f7e0e69201ab8888ecfc3 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward the hashing for unordered containers to the implementation.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#addb7676f2e4f7e0e69201ab8888ecfc3">More...</a><br /></td></tr>
<tr class="separator:addb7676f2e4f7e0e69201ab8888ecfc3 inherit pub_methods_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:ade1173f8bf52fd9c7471ef068ef4e5d6"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ade1173f8bf52fd9c7471ef068ef4e5d6">access_mode</a> ()</td></tr>
<tr class="memdesc:ade1173f8bf52fd9c7471ef068ef4e5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introspect the <code>access_mode</code>.  <a href="group__data.html#ade1173f8bf52fd9c7471ef068ef4e5d6">More...</a><br /></td></tr>
<tr class="separator:ade1173f8bf52fd9c7471ef068ef4e5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43142868081217cab1fb1b2bef4c670"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aa43142868081217cab1fb1b2bef4c670">target</a> ()</td></tr>
<tr class="memdesc:aa43142868081217cab1fb1b2bef4c670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introspect the <code>target</code>.  <a href="group__data.html#aa43142868081217cab1fb1b2bef4c670">More...</a><br /></td></tr>
<tr class="separator:aa43142868081217cab1fb1b2bef4c670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Attributes</h3></td></tr>
<tr class="memitem:a8dbe6f54053b089df27b8092b4684178"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> = Dimensions</td></tr>
<tr class="separator:a8dbe6f54053b089df27b8092b4684178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a4404c712ea8d82efbc30e9d1bc0e1a66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a4404c712ea8d82efbc30e9d1bc0e1a66">accessor_detail</a> = typename <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">detail::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;</td></tr>
<tr class="separator:a4404c712ea8d82efbc30e9d1bc0e1a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b5f331932268e315c85d8b2091c2e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ad6b5f331932268e315c85d8b2091c2e4">implementation_t</a> = typename <a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a216dcddf50a237c93e1809a1b2364607">accessor::shared_ptr_implementation</a></td></tr>
<tr class="separator:ad6b5f331932268e315c85d8b2091c2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a23988a19bcf28b3076992e369ee3e213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfriend.html">friend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a23988a19bcf28b3076992e369ee3e213">implementation_t</a></td></tr>
<tr class="separator:a23988a19bcf28b3076992e369ee3e213"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_group__helpers"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__helpers')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__helpers.html">trisycl::detail::container_element_aspect&lt; DataType &gt;</a></td></tr>
<tr class="memitem:aa2af948217ea3bd3d7bd7c428fe01cec inherit pub_types_group__helpers"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#aa2af948217ea3bd3d7bd7c428fe01cec">value_type</a> = DataType</td></tr>
<tr class="separator:aa2af948217ea3bd3d7bd7c428fe01cec inherit pub_types_group__helpers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c317687aa8ed1ba885303c25676875b inherit pub_types_group__helpers"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#a1c317687aa8ed1ba885303c25676875b">pointer</a> = <a class="el" href="group__helpers.html#aa2af948217ea3bd3d7bd7c428fe01cec">value_type</a> *</td></tr>
<tr class="separator:a1c317687aa8ed1ba885303c25676875b inherit pub_types_group__helpers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8239b062a652c390dac9f82b8ccd1924 inherit pub_types_group__helpers"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#a8239b062a652c390dac9f82b8ccd1924">const_pointer</a> = const <a class="el" href="group__helpers.html#aa2af948217ea3bd3d7bd7c428fe01cec">value_type</a> *</td></tr>
<tr class="separator:a8239b062a652c390dac9f82b8ccd1924 inherit pub_types_group__helpers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589da6033f56d3649535b727d476565b inherit pub_types_group__helpers"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#a589da6033f56d3649535b727d476565b">reference</a> = <a class="el" href="group__helpers.html#aa2af948217ea3bd3d7bd7c428fe01cec">value_type</a> &amp;</td></tr>
<tr class="separator:a589da6033f56d3649535b727d476565b inherit pub_types_group__helpers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c711c0170340e041b6597b80dbbaaa inherit pub_types_group__helpers"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#a49c711c0170340e041b6597b80dbbaaa">const_reference</a> = const <a class="el" href="group__helpers.html#aa2af948217ea3bd3d7bd7c428fe01cec">value_type</a> &amp;</td></tr>
<tr class="separator:a49c711c0170340e041b6597b80dbbaaa inherit pub_types_group__helpers"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_structtrisycl_1_1detail_1_1shared__ptr__implementation')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html">trisycl::detail::shared_ptr_implementation&lt; accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt;, detail::accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; &gt;</a></td></tr>
<tr class="memitem:a75000a9b2ed7debf4c77623b7f78a328 inherit pub_attribs_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">detail::accessor</a>&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a></td></tr>
<tr class="memdesc:a75000a9b2ed7debf4c77623b7f78a328 inherit pub_attribs_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation forward everything to this... implementation.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">More...</a><br /></td></tr>
<tr class="separator:a75000a9b2ed7debf4c77623b7f78a328 inherit pub_attribs_structtrisycl_1_1detail_1_1shared__ptr__implementation"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a4404c712ea8d82efbc30e9d1bc0e1a66" name="a4404c712ea8d82efbc30e9d1bc0e1a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4404c712ea8d82efbc30e9d1bc0e1a66">&#9670;&nbsp;</a></span>accessor_detail</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::accessor_detail =  typename <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">detail::accessor</a>&lt;DataType, Dimensions, AccessMode, Target&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00067">67</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

</div>
</div>
<a id="ad6b5f331932268e315c85d8b2091c2e4" name="ad6b5f331932268e315c85d8b2091c2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b5f331932268e315c85d8b2091c2e4">&#9670;&nbsp;</a></span>implementation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::implementation_t =  typename <a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a216dcddf50a237c93e1809a1b2364607">accessor::shared_ptr_implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00073">73</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a0d2d6323ca7ff829dbcd81659659f4bb" name="a0d2d6323ca7ff829dbcd81659659f4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2d6323ca7ff829dbcd81659659f4bb">&#9670;&nbsp;</a></span>accessor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; DataType, Dimensions, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a buffer accessor from a buffer using a command group handler object from the command group scope. </p>
<p >Constructor only available for global_buffer or constant_buffer target.</p>
<p >access_target defines the form of access being obtained.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000060">Todo:</a></b></dt><dd>Add template allocator type in all the accessor constructors in the specification or just use a more opaque Buffer type?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000061">Todo:</a></b></dt><dd>fix specification where access mode should be target instead </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00104">104</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  105</span>                                           : <a class="code hl_typedef" href="group__data.html#ad6b5f331932268e315c85d8b2091c2e4">implementation_t</a> {</div>
<div class="line"><span class="lineno">  106</span>    <span class="keyword">new</span> detail::accessor&lt;DataType, Dimensions, AccessMode, Target&gt; {</div>
<div class="line"><span class="lineno">  107</span>      target_buffer.implementation-&gt;implementation, command_group_handler }</div>
<div class="line"><span class="lineno">  108</span>  } {</div>
<div class="line"><span class="lineno">  109</span>    <span class="keyword">static_assert</span>(Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a></div>
<div class="line"><span class="lineno">  110</span>                  || Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b">access::target::constant_buffer</a>,</div>
<div class="line"><span class="lineno">  111</span>                  <span class="stringliteral">&quot;access target should be global_buffer or constant_buffer &quot;</span></div>
<div class="line"><span class="lineno">  112</span>                  <span class="stringliteral">&quot;when a handler is used&quot;</span>);</div>
<div class="line"><span class="lineno">  113</span>    <span class="comment">// Now the implementation is created, register it</span></div>
<div class="line"><span class="lineno">  114</span>    <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;register_accessor();</div>
<div class="line"><span class="lineno">  115</span>  }</div>
<div class="ttc" id="agroup__data_html_ad6b5f331932268e315c85d8b2091c2e4"><div class="ttname"><a href="group__data.html#ad6b5f331932268e315c85d8b2091c2e4">trisycl::accessor::implementation_t</a></div><div class="ttdeci">typename accessor::shared_ptr_implementation implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_8hpp_source.html#l00073">accessor.hpp:73</a></div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b">trisycl::access::target::global_buffer</a></div><div class="ttdeci">@ global_buffer</div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b">trisycl::access::target::constant_buffer</a></div><div class="ttdeci">@ constant_buffer</div></div>
<div class="ttc" id="astructtrisycl_1_1detail_1_1shared__ptr__implementation_html_a75000a9b2ed7debf4c77623b7f78a328"><div class="ttname"><a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">trisycl::detail::shared_ptr_implementation&lt; accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt;, detail::accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; &gt;::implementation</a></div><div class="ttdeci">std::shared_ptr&lt; detail::accessor&lt; DataType, Dimensions,(std::is_const_v&lt; DataType &gt; ? access::mode::read :access::mode::read_write), access::target::global_buffer &gt; &gt; implementation</div><div class="ttdoc">The implementation forward everything to this... implementation.</div><div class="ttdef"><b>Definition:</b> <a href="shared__ptr__implementation_8hpp_source.html#l00041">shared_ptr_implementation.hpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c6089969f8d96f5da20c362d96e1c18" name="a8c6089969f8d96f5da20c362d96e1c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6089969f8d96f5da20c362d96e1c18">&#9670;&nbsp;</a></span>accessor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; DataType, Dimensions, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a buffer accessor from a buffer. </p>
<p >Constructor only available for host_buffer target.</p>
<p >access_target defines the form of access being obtained. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00125">125</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  126</span>    : <a class="code hl_typedef" href="group__data.html#ad6b5f331932268e315c85d8b2091c2e4">implementation_t</a> {</div>
<div class="line"><span class="lineno">  127</span>    <span class="keyword">new</span> detail::accessor&lt;DataType, Dimensions, AccessMode, Target&gt; {</div>
<div class="line"><span class="lineno">  128</span>      target_buffer.implementation-&gt;implementation }</div>
<div class="line"><span class="lineno">  129</span>  } {</div>
<div class="line"><span class="lineno">  130</span>    <span class="keyword">static_assert</span>(Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>,</div>
<div class="line"><span class="lineno">  131</span>                  <span class="stringliteral">&quot;without a handler, access target should be host_buffer&quot;</span>);</div>
<div class="line"><span class="lineno">  132</span>  }</div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">trisycl::access::target::host_buffer</a></div><div class="ttdeci">@ host_buffer</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acfda5ddf6c741d40634ac34682be7f17" name="acfda5ddf6c741d40634ac34682be7f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfda5ddf6c741d40634ac34682be7f17">&#9670;&nbsp;</a></span>accessor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<div class="memtemplate">
template&lt;typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; DataType, Dimensions, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a buffer accessor from a buffer given a specific range for access permissions and an offset that provides the starting point for the access range using a command group handler object from the command group scope. </p>
<p >This accessor limits the processing of the buffer to the [offset, offset+range[ for every dimension. Any other parts of the buffer will be unaffected.</p>
<p >Constructor only available for access modes global_buffer, and constant_buffer (see Table "Buffer accessor constructors"). access_target defines the form of access being obtained.</p>
<p >This accessor is recommended for discard-write and discard read write access modes, when the unaffected parts of the processing should be retained. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00153">153</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  156</span>                                           {</div>
<div class="line"><span class="lineno">  157</span>    <a class="code hl_define" href="group__helpers.html#gabc864dbff357567e07f18baf409db80e">TRISYCL_UNIMPL</a>;</div>
<div class="line"><span class="lineno">  158</span>  }</div>
<div class="ttc" id="agroup__helpers_html_gabc864dbff357567e07f18baf409db80e"><div class="ttname"><a href="group__helpers.html#gabc864dbff357567e07f18baf409db80e">TRISYCL_UNIMPL</a></div><div class="ttdeci">#define TRISYCL_UNIMPL</div><div class="ttdef"><b>Definition:</b> <a href="unimplemented_8hpp_source.html#l00032">unimplemented.hpp:32</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="unimplemented_8hpp_source.html#l00032">TRISYCL_UNIMPL</a>.</p>

</div>
</div>
<a id="a447c7edd2b1e005a220e4f3f35210a39" name="a447c7edd2b1e005a220e4f3f35210a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447c7edd2b1e005a220e4f3f35210a39">&#9670;&nbsp;</a></span>accessor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>allocation_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an accessor of dimension Dimensions with elements of type DataType using the passed range to specify the size in each dimension. </p>
<p >It needs as a parameter a command group handler object from the command group scope. Constructor only available if AccessMode is local, see Table 3.25. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00169">169</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  171</span>    : <a class="code hl_typedef" href="group__data.html#ad6b5f331932268e315c85d8b2091c2e4">implementation_t</a> { <span class="keyword">new</span> detail::accessor&lt;DataType,</div>
<div class="line"><span class="lineno">  172</span>                                              Dimensions,</div>
<div class="line"><span class="lineno">  173</span>                                              AccessMode,</div>
<div class="line"><span class="lineno">  174</span>                                              <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2">access::target::local</a>&gt; {</div>
<div class="line"><span class="lineno">  175</span>      allocation_size, command_group_handler</div>
<div class="line"><span class="lineno">  176</span>        }</div>
<div class="line"><span class="lineno">  177</span>  }</div>
<div class="line"><span class="lineno">  178</span>  {</div>
<div class="line"><span class="lineno">  179</span>    <span class="keyword">static_assert</span>(Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2">access::target::local</a>,</div>
<div class="line"><span class="lineno">  180</span>                  <span class="stringliteral">&quot;This accessor constructor requires &quot;</span></div>
<div class="line"><span class="lineno">  181</span>                  <span class="stringliteral">&quot;access target be local&quot;</span>);</div>
<div class="line"><span class="lineno">  182</span>  }</div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2">trisycl::access::target::local</a></div><div class="ttdeci">@ local</div></div>
</div><!-- fragment -->
</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="ade1173f8bf52fd9c7471ef068ef4e5d6" name="ade1173f8bf52fd9c7471ef068ef4e5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1173f8bf52fd9c7471ef068ef4e5d6">&#9670;&nbsp;</a></span>access_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto constexpr <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::access_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introspect the <code>access_mode</code>. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00080">80</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   80</span>{ <span class="keywordflow">return</span> AccessMode; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f43d5547649f7422b22b70a1b44071b" name="a0f43d5547649f7422b22b70a1b44071b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f43d5547649f7422b22b70a1b44071b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forward all the iterator functions to the implementation. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000072">Todo:</a></b></dt><dd>Add these functions to the specification</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000073">Todo:</a></b></dt><dd>The fact that the lambda capture make a const copy of the accessor is not yet elegantly managed... The issue is that <a class="el" href="group__data.html#a0f43d5547649f7422b22b70a1b44071b" title="Forward all the iterator functions to the implementation.">begin()</a>/end() dispatch is made according to the accessor constness and not from the array member constness...</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000074">Todo:</a></b></dt><dd>try to solve it by using some enable_if on array constness?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000075">Todo:</a></b></dt><dd>The issue is that the end may not be known if it is implemented by a raw OpenCL cl_mem... So only provide on the device the iterators related to the start? Actually the accessor needs to know a part of the shape to have the multidimentional addressing. So this only require a size_t more...</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd>Factor out these in a template helper </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00345">345</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  345</span>                                                 {</div>
<div class="line"><span class="lineno">  346</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;begin();</div>
<div class="line"><span class="lineno">  347</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9603fb66d3d16c007e21cd45b90a055" name="aa9603fb66d3d16c007e21cd45b90a055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9603fb66d3d16c007e21cd45b90a055">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::const_iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00355">355</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  355</span>                                                        {</div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;cbegin();</div>
<div class="line"><span class="lineno">  357</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c9be218f1479230487bbb0ba7f5fc96" name="a4c9be218f1479230487bbb0ba7f5fc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9be218f1479230487bbb0ba7f5fc96">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::const_iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00360">360</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  360</span>                                                      {</div>
<div class="line"><span class="lineno">  361</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;cend();</div>
<div class="line"><span class="lineno">  362</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9653e7d488638e91b6f319e993571394" name="a9653e7d488638e91b6f319e993571394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9653e7d488638e91b6f319e993571394">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::const_reverse_iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00375">375</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  375</span>                                                                 {</div>
<div class="line"><span class="lineno">  376</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;rbegin();</div>
<div class="line"><span class="lineno">  377</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a713ef2deaa5438c4815f9a745694b0d0" name="a713ef2deaa5438c4815f9a745694b0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713ef2deaa5438c4815f9a745694b0d0">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::const_reverse_iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00380">380</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  380</span>                                                               {</div>
<div class="line"><span class="lineno">  381</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;rend();</div>
<div class="line"><span class="lineno">  382</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a78ec64ec068f11fd6c7500bba1b7e7c0" name="a78ec64ec068f11fd6c7500bba1b7e7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ec64ec068f11fd6c7500bba1b7e7c0">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00351">351</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  351</span>                                               {</div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;end();</div>
<div class="line"><span class="lineno">  353</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="afa68b1d5990dcc6b3ebbf6a088a6649a" name="afa68b1d5990dcc6b3ebbf6a088a6649a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa68b1d5990dcc6b3ebbf6a088a6649a">&#9670;&nbsp;</a></span>get_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements behind the accessor. </p>
<p >Equal to <a class="el" href="group__data.html#a62901775a6a0969fdb5f3217d21ed9c7" title="Return a range object representing the size of the buffer in terms of number of elements in each dime...">get_range()</a>[0] * ... * <a class="el" href="group__data.html#a62901775a6a0969fdb5f3217d21ed9c7" title="Return a range object representing the size of the buffer in terms of number of elements in each dime...">get_range()</a>[Dimensions-1].</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000063">Todo:</a></b></dt><dd>Move on <a href="https://cvs.khronos.org/bugzilla/show_bug.cgi?id=15564">https://cvs.khronos.org/bugzilla/show_bug.cgi?id=15564</a> and <a href="https://cvs.khronos.org/bugzilla/show_bug.cgi?id=14404">https://cvs.khronos.org/bugzilla/show_bug.cgi?id=14404</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00213">213</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  213</span>                         {</div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;get_count();</div>
<div class="line"><span class="lineno">  215</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9696f09c436b1367fabbed80bf40b550" name="a9696f09c436b1367fabbed80bf40b550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9696f09c436b1367fabbed80bf40b550">&#9670;&nbsp;</a></span>get_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::get_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the pointer to the start of the data. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000071">Todo:</a></b></dt><dd>Should it be named data() instead? </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00318">318</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  318</span>                      {</div>
<div class="line"><span class="lineno">  319</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;get_pointer();</div>
<div class="line"><span class="lineno">  320</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a62901775a6a0969fdb5f3217d21ed9c7" name="a62901775a6a0969fdb5f3217d21ed9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62901775a6a0969fdb5f3217d21ed9c7">&#9670;&nbsp;</a></span>get_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::get_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000062">Todo:</a></b></dt><dd>Move on <a href="https://cvs.khronos.org/bugzilla/show_bug.cgi?id=15564">https://cvs.khronos.org/bugzilla/show_bug.cgi?id=15564</a> and <a href="https://cvs.khronos.org/bugzilla/show_bug.cgi?id=14404">https://cvs.khronos.org/bugzilla/show_bug.cgi?id=14404</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00193">193</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  193</span>                         {</div>
<div class="line"><span class="lineno">  194</span>    <span class="comment">/* Interpret the shape which is a pointer to the first element as an</span></div>
<div class="line"><span class="lineno">  195</span><span class="comment">       array of Dimensions elements so that the range&lt;Dimensions&gt;</span></div>
<div class="line"><span class="lineno">  196</span><span class="comment">       constructor is happy with this collection</span></div>
<div class="line"><span class="lineno">  197</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  198</span><span class="comment">       \todo Add also a constructor in range&lt;&gt; to accept a const</span></div>
<div class="line"><span class="lineno">  199</span><span class="comment">       std::size_t *?</span></div>
<div class="line"><span class="lineno">  200</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;get_range();</div>
<div class="line"><span class="lineno">  202</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac9ca883f45754d54a19d51738669f181" name="ac9ca883f45754d54a19d51738669f181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ca883f45754d54a19d51738669f181">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the underlying buffer storage in bytes. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000064">Todo:</a></b></dt><dd>It is incompatible with buffer <a class="el" href="group__data.html#ac9ca883f45754d54a19d51738669f181" title="Returns the size of the underlying buffer storage in bytes.">get_size()</a> in the spec</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo:</a></b></dt><dd>Move on <a href="https://cvs.khronos.org/bugzilla/show_bug.cgi?id=15564">https://cvs.khronos.org/bugzilla/show_bug.cgi?id=15564</a> and <a href="https://cvs.khronos.org/bugzilla/show_bug.cgi?id=14404">https://cvs.khronos.org/bugzilla/show_bug.cgi?id=14404</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00226">226</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  226</span>                        {</div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;get_size();</div>
<div class="line"><span class="lineno">  228</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9d5d8726d7d3d4f9229e90d873c66d9e" name="a9d5d8726d7d3d4f9229e90d873c66d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5d8726d7d3d4f9229e90d873c66d9e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::reference <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first element of the accessor. </p>
<p >Useful with an accessor on a scalar for example.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000068">Todo:</a></b></dt><dd>Add in the specification </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00294">294</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  294</span>                                                {</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">return</span> **<a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>;</div>
<div class="line"><span class="lineno">  296</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7abcbc1d6e7466903c58e353141e6c03" name="a7abcbc1d6e7466903c58e353141e6c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abcbc1d6e7466903c58e353141e6c03">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::reference <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first element of the accessor. </p>
<p >Useful with an accessor on a scalar for example.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000069">Todo:</a></b></dt><dd>Add in the specification?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000070">Todo:</a></b></dt><dd>Add the concept of 0-dim buffer and accessor for scalar and use an implicit conversion to value_type reference to access the value with the accessor? </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00309">309</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  309</span>                                                      {</div>
<div class="line"><span class="lineno">  310</span>    <span class="keywordflow">return</span> **<a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>;</div>
<div class="line"><span class="lineno">  311</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c73fa2fc8911e5822b5c7cb77d53123" name="a1c73fa2fc8911e5822b5c7cb77d53123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c73fa2fc8911e5822b5c7cb77d53123">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To use the accessor with [id&lt;&gt;]. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00249">249</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  249</span>                                                    {</div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordflow">return</span> (*<a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>)[index];</div>
<div class="line"><span class="lineno">  251</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a705d9fd23436356cdc6bfe2e7968f3e8" name="a705d9fd23436356cdc6bfe2e7968f3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705d9fd23436356cdc6bfe2e7968f3e8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To use the accessor with [id&lt;&gt;]. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00254">254</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  254</span>                                                          {</div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">return</span> (*<a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>)[index];</div>
<div class="line"><span class="lineno">  256</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1508adebd76462b4b6cef37ac2a1aae4" name="a1508adebd76462b4b6cef37ac2a1aae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1508adebd76462b4b6cef37ac2a1aae4">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To use an accessor with [item&lt;&gt;]. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00260">260</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  260</span>                                                      {</div>
<div class="line"><span class="lineno">  261</span>    <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[index.get_id()];</div>
<div class="line"><span class="lineno">  262</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="item_8hpp_source.html#l00066">trisycl::item&lt; Dimensions, with_offset &gt;::get_id()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a1508adebd76462b4b6cef37ac2a1aae4_cgraph.png" border="0" usemap="#agroup__data_a1508adebd76462b4b6cef37ac2a1aae4_cgraph" alt=""/></div>
<map name="agroup__data_a1508adebd76462b4b6cef37ac2a1aae4_cgraph" id="agroup__data_a1508adebd76462b4b6cef37ac2a1aae4_cgraph">
<area shape="rect" title="To use an accessor with [item&lt;&gt;]." alt="" coords="5,5,132,47"/>
<area shape="rect" href="group__parallelism.html#ad6458907c63eaef564466906a4a55091" title="Return the constituent local or global id&lt;&gt; representing the work&#45;item&#39;s position in the iteration sp..." alt="" coords="180,13,313,39"/>
</map>
</div>

</div>
</div>
<a id="ad0d5d55d6effd8a42427d4a2c1d84b85" name="ad0d5d55d6effd8a42427d4a2c1d84b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d5d55d6effd8a42427d4a2c1d84b85">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To use an accessor with [item&lt;&gt;]. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00266">266</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  266</span>                                                            {</div>
<div class="line"><span class="lineno">  267</span>    <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[index.get_id()];</div>
<div class="line"><span class="lineno">  268</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="item_8hpp_source.html#l00066">trisycl::item&lt; Dimensions, with_offset &gt;::get_id()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ad0d5d55d6effd8a42427d4a2c1d84b85_cgraph.png" border="0" usemap="#agroup__data_ad0d5d55d6effd8a42427d4a2c1d84b85_cgraph" alt=""/></div>
<map name="agroup__data_ad0d5d55d6effd8a42427d4a2c1d84b85_cgraph" id="agroup__data_ad0d5d55d6effd8a42427d4a2c1d84b85_cgraph">
<area shape="rect" title="To use an accessor with [item&lt;&gt;]." alt="" coords="5,5,132,47"/>
<area shape="rect" href="group__parallelism.html#ad6458907c63eaef564466906a4a55091" title="Return the constituent local or global id&lt;&gt; representing the work&#45;item&#39;s position in the iteration sp..." alt="" coords="180,13,313,39"/>
</map>
</div>

</div>
</div>
<a id="a01680fcb2c6b2940aa5724c73478711b" name="a01680fcb2c6b2940aa5724c73478711b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01680fcb2c6b2940aa5724c73478711b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To use an accessor with an [nd_item&lt;&gt;]. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000066">Todo:</a></b></dt><dd>Add in the specification because used by HPC-GPU slide 22 </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00275">275</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  275</span>                                                         {</div>
<div class="line"><span class="lineno">  276</span>    <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[index.get_global_id()];</div>
<div class="line"><span class="lineno">  277</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="nd__item_8hpp_source.html#l00079">trisycl::nd_item&lt; Dimensions &gt;::get_global_id()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a01680fcb2c6b2940aa5724c73478711b_cgraph.png" border="0" usemap="#agroup__data_a01680fcb2c6b2940aa5724c73478711b_cgraph" alt=""/></div>
<map name="agroup__data_a01680fcb2c6b2940aa5724c73478711b_cgraph" id="agroup__data_a01680fcb2c6b2940aa5724c73478711b_cgraph">
<area shape="rect" title="To use an accessor with an [nd_item&lt;&gt;]." alt="" coords="5,5,132,47"/>
<area shape="rect" href="group__parallelism.html#a5bedcf64f53a469a28b4960c74a7f4f2" title="Return the constituent global id representing the work&#45;item&#39;s position in the global iteration space." alt="" coords="180,5,317,47"/>
</map>
</div>

</div>
</div>
<a id="a6a960aae76f100973b60f6364ee63d58" name="a6a960aae76f100973b60f6364ee63d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a960aae76f100973b60f6364ee63d58">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; <a class="el" href="group__data.html#a8dbe6f54053b089df27b8092b4684178">dimensionality</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To use an accessor with an [nd_item&lt;&gt;]. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000067">Todo:</a></b></dt><dd>Add in the specification because used by HPC-GPU slide 22 </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00283">283</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  283</span>                                                               {</div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[index.get_global_id()];</div>
<div class="line"><span class="lineno">  285</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="nd__item_8hpp_source.html#l00079">trisycl::nd_item&lt; Dimensions &gt;::get_global_id()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a6a960aae76f100973b60f6364ee63d58_cgraph.png" border="0" usemap="#agroup__data_a6a960aae76f100973b60f6364ee63d58_cgraph" alt=""/></div>
<map name="agroup__data_a6a960aae76f100973b60f6364ee63d58_cgraph" id="agroup__data_a6a960aae76f100973b60f6364ee63d58_cgraph">
<area shape="rect" title="To use an accessor with an [nd_item&lt;&gt;]." alt="" coords="5,5,132,47"/>
<area shape="rect" href="group__parallelism.html#a5bedcf64f53a469a28b4960c74a7f4f2" title="Return the constituent global id representing the work&#45;item&#39;s position in the global iteration space." alt="" coords="180,5,317,47"/>
</map>
</div>

</div>
</div>
<a id="adc8b5b483bc23d0b7cfa8042403deea6" name="adc8b5b483bc23d0b7cfa8042403deea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8b5b483bc23d0b7cfa8042403deea6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<div class="memtemplate">
template&lt;std::integral... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T...&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...]. </p>
<dl class="section return"><dt>Returns</dt><dd>decltype(auto) to return either a reference to the final element when the indexing has been fully resolved or a proxy object to handle the remaining [] </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00235">235</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  235</span>                                                                      {</div>
<div class="line"><span class="lineno">  236</span>    <span class="keywordflow">return</span> (*<a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>)[indices...];</div>
<div class="line"><span class="lineno">  237</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8d57834b14c240e3543ee4657b076069" name="a8d57834b14c240e3543ee4657b076069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d57834b14c240e3543ee4657b076069">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<div class="memtemplate">
template&lt;std::integral... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">T...&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...]. </p>
<dl class="section return"><dt>Returns</dt><dd>decltype(auto) to return either a reference to the final element when the indexing has been fully resolved or a proxy object to handle the remaining [] </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00244">244</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  244</span>                                                                            {</div>
<div class="line"><span class="lineno">  245</span>    <span class="keywordflow">return</span> (*<a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>)[indices...];</div>
<div class="line"><span class="lineno">  246</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a95190c4935e5cc94611fe0c897dd218c" name="a95190c4935e5cc94611fe0c897dd218c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95190c4935e5cc94611fe0c897dd218c">&#9670;&nbsp;</a></span>rbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::reverse_iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00365">365</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  365</span>                                                          {</div>
<div class="line"><span class="lineno">  366</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;rbegin();</div>
<div class="line"><span class="lineno">  367</span>  };</div>
</div><!-- fragment -->
</div>
</div>
<a id="aee6724d1704d897db33981351dbf0734" name="aee6724d1704d897db33981351dbf0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6724d1704d897db33981351dbf0734">&#9670;&nbsp;</a></span>rend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">accessor_detail::reverse_iterator <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00370">370</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  370</span>                                                        {</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#a75000a9b2ed7debf4c77623b7f78a328">implementation</a>-&gt;rend();</div>
<div class="line"><span class="lineno">  372</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa43142868081217cab1fb1b2bef4c670" name="aa43142868081217cab1fb1b2bef4c670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43142868081217cab1fb1b2bef4c670">&#9670;&nbsp;</a></span>target()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto constexpr <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::target </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introspect the <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00083">83</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   83</span>{ <span class="keywordflow">return</span> Target; }</div>
</div><!-- fragment -->
</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a8dbe6f54053b089df27b8092b4684178" name="a8dbe6f54053b089df27b8092b4684178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbe6f54053b089df27b8092b4684178">&#9670;&nbsp;</a></span>dimensionality</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::dimensionality = Dimensions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000059">Todo:</a></b></dt><dd>in the specification: store the dimension for user request </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00063">63</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

</div>
</div>
<a id="a23988a19bcf28b3076992e369ee3e213" name="a23988a19bcf28b3076992e369ee3e213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23988a19bcf28b3076992e369ee3e213">&#9670;&nbsp;</a></span>implementation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> AccessMode = (std::is_const_v&lt;DataType&gt; ? access::mode::read                                         : access::mode::read_write), <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> <a class="el" href="group__data.html#classtrisycl_1_1accessor">trisycl::accessor</a>&lt; DataType, Dimensions, AccessMode, Target &gt;::implementation_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2accessor_8hpp_source.html#l00076">76</a> of file <a class="el" href="triSYCL_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1detail_1_1accessor__base" id="classtrisycl_1_1detail_1_1accessor__base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1detail_1_1accessor__base">&#9670;&nbsp;</a></span>trisycl::detail::accessor_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::detail::accessor_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer data types. </p>

<p class="definition">Definition at line <a class="el" href="accessor__base_8hpp_source.html#l00037">37</a> of file <a class="el" href="accessor__base_8hpp_source.html">accessor_base.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::detail::accessor_base:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1accessor__base__inherit__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1accessor__base_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1detail_1_1accessor__base_inherit__map" id="atrisycl_1_1detail_1_1accessor__base_inherit__map">
<area shape="rect" title="The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer..." alt="" coords="5,60,197,87"/>
<area shape="rect" href="group__data.html" title=" " alt="" coords="245,5,440,61"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1accessor" title="The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional ..." alt="" coords="262,85,423,141"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4" title="The local accessor specialization abstracts the way local memory is allocated to a kernel to be share..." alt="" coords="488,5,649,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::detail::accessor_base:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1accessor__base__coll__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1accessor__base_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1detail_1_1accessor__base_coll__map" id="atrisycl_1_1detail_1_1accessor__base_coll__map">
<area shape="rect" title="The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer..." alt="" coords="33,109,225,136"/>
<area shape="rect" title=" " alt="" coords="5,5,136,47"/>
<area shape="rect" title=" " alt="" coords="161,13,218,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a0f17346e18ae668ecb8175ff3b2ccb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">set_order</a> (std::size_t o)</td></tr>
<tr class="memdesc:a0f17346e18ae668ecb8175ff3b2ccb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order of the accessor.  <a href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">More...</a><br /></td></tr>
<tr class="separator:a0f17346e18ae668ecb8175ff3b2ccb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5efdf051df9db11cfc7d4be3d7673f0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#af5efdf051df9db11cfc7d4be3d7673f0">get_order</a> ()</td></tr>
<tr class="memdesc:af5efdf051df9db11cfc7d4be3d7673f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the order of the accessor.  <a href="group__data.html#af5efdf051df9db11cfc7d4be3d7673f0">More...</a><br /></td></tr>
<tr class="separator:af5efdf051df9db11cfc7d4be3d7673f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980d5757946fa394716ea51b6a1bc9d7"><td class="memItemLeft" align="right" valign="top">virtual boost::compute::buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">get_cl_buffer</a> () const =0</td></tr>
<tr class="memdesc:a980d5757946fa394716ea51b6a1bc9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boost::compute::buffer or throw if unset.  <a href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">More...</a><br /></td></tr>
<tr class="separator:a980d5757946fa394716ea51b6a1bc9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72bda8f733bd016a15f3d7ad3112e28"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#af72bda8f733bd016a15f3d7ad3112e28">~accessor_base</a> ()</td></tr>
<tr class="separator:af72bda8f733bd016a15f3d7ad3112e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Attributes</h3></td></tr>
<tr class="memitem:ae542f16a71fdeb8797e59d711b7ed124"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a></td></tr>
<tr class="memdesc:ae542f16a71fdeb8797e59d711b7ed124"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task where the accessor is used in.  <a href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">More...</a><br /></td></tr>
<tr class="separator:ae542f16a71fdeb8797e59d711b7ed124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b32ac13bfd168d1318d7b5e84b8370"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">order</a></td></tr>
<tr class="memdesc:a75b32ac13bfd168d1318d7b5e84b8370"><td class="mdescLeft">&#160;</td><td class="mdescRight">The declaration order of the accessor.  <a href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">More...</a><br /></td></tr>
<tr class="separator:a75b32ac13bfd168d1318d7b5e84b8370"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="af72bda8f733bd016a15f3d7ad3112e28" name="af72bda8f733bd016a15f3d7ad3112e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72bda8f733bd016a15f3d7ad3112e28">&#9670;&nbsp;</a></span>~accessor_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual trisycl::detail::accessor_base::~accessor_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="accessor__base_8hpp_source.html#l00066">66</a> of file <a class="el" href="accessor__base_8hpp_source.html">accessor_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   66</span>{}</div>
</div><!-- fragment -->
</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a980d5757946fa394716ea51b6a1bc9d7" name="a980d5757946fa394716ea51b6a1bc9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980d5757946fa394716ea51b6a1bc9d7">&#9670;&nbsp;</a></span>get_cl_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::compute::buffer trisycl::detail::accessor_base::get_cl_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the boost::compute::buffer or throw if unset. </p>

<p>Implemented in <a class="el" href="group__data.html#a21266c6ebba45da03ee63e0342f8e7fc">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;</a>, and <a class="el" href="group__data.html#a21266c6ebba45da03ee63e0342f8e7fc">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::host_buffer &gt;</a>.</p>

</div>
</div>
<a id="af5efdf051df9db11cfc7d4be3d7673f0" name="af5efdf051df9db11cfc7d4be3d7673f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5efdf051df9db11cfc7d4be3d7673f0">&#9670;&nbsp;</a></span>get_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto trisycl::detail::accessor_base::get_order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the order of the accessor. </p>

<p class="definition">Definition at line <a class="el" href="accessor__base_8hpp_source.html#l00056">56</a> of file <a class="el" href="accessor__base_8hpp_source.html">accessor_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   56</span>                   {</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">order</a>;</div>
<div class="line"><span class="lineno">   58</span>  }</div>
<div class="ttc" id="agroup__data_html_a75b32ac13bfd168d1318d7b5e84b8370"><div class="ttname"><a href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">trisycl::detail::accessor_base::order</a></div><div class="ttdeci">std::size_t order</div><div class="ttdoc">The declaration order of the accessor.</div><div class="ttdef"><b>Definition:</b> <a href="accessor__base_8hpp_source.html#l00045">accessor_base.hpp:45</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="accessor__base_8hpp_source.html#l00045">order</a>.</p>

</div>
</div>
<a id="a0f17346e18ae668ecb8175ff3b2ccb76" name="a0f17346e18ae668ecb8175ff3b2ccb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f17346e18ae668ecb8175ff3b2ccb76">&#9670;&nbsp;</a></span>set_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::accessor_base::set_order </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the order of the accessor. </p>

<p class="definition">Definition at line <a class="el" href="accessor__base_8hpp_source.html#l00050">50</a> of file <a class="el" href="accessor__base_8hpp_source.html">accessor_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   50</span>                              {</div>
<div class="line"><span class="lineno">   51</span>    <a class="code hl_variable" href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">order</a> = o;</div>
<div class="line"><span class="lineno">   52</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="accessor__base_8hpp_source.html#l00045">order</a>.</p>

<p class="reference">Referenced by <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00141">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::register_accessor()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a0f17346e18ae668ecb8175ff3b2ccb76_icgraph.png" border="0" usemap="#agroup__data_a0f17346e18ae668ecb8175ff3b2ccb76_icgraph" alt=""/></div>
<map name="agroup__data_a0f17346e18ae668ecb8175ff3b2ccb76_icgraph" id="agroup__data_a0f17346e18ae668ecb8175ff3b2ccb76_icgraph">
<area shape="rect" title="Set the order of the accessor." alt="" coords="211,5,368,47"/>
<area shape="rect" href="group__data.html#a9acc187ff81ce7b877785d2fd9116e52" title="Register the accessor once a std::shared_ptr is created on it." alt="" coords="5,5,163,47"/>
</map>
</div>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a75b32ac13bfd168d1318d7b5e84b8370" name="a75b32ac13bfd168d1318d7b5e84b8370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b32ac13bfd168d1318d7b5e84b8370">&#9670;&nbsp;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t trisycl::detail::accessor_base::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The declaration order of the accessor. </p>

<p class="definition">Definition at line <a class="el" href="accessor__base_8hpp_source.html#l00045">45</a> of file <a class="el" href="accessor__base_8hpp_source.html">accessor_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="accessor__base_8hpp_source.html#l00056">get_order()</a>, and <a class="el" href="accessor__base_8hpp_source.html#l00050">set_order()</a>.</p>

</div>
</div>
<a id="ae542f16a71fdeb8797e59d711b7ed124" name="ae542f16a71fdeb8797e59d711b7ed124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae542f16a71fdeb8797e59d711b7ed124">&#9670;&nbsp;</a></span>task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a>&gt; trisycl::detail::accessor_base::task</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The task where the accessor is used in. </p>

<p class="definition">Definition at line <a class="el" href="accessor__base_8hpp_source.html#l00042">42</a> of file <a class="el" href="accessor__base_8hpp_source.html">accessor_base.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4" id="classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">&#9670;&nbsp;</a></span>trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode&gt;<br />
class trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;</div><p >The local accessor specialization abstracts the way local memory is allocated to a kernel to be shared between work-items of the same work-group. </p>
<p >Since this a pure library implementation, implement it as a <a class="el" href="group__old__data.html#classtrisycl_1_1host__accessor" title="SYCL 2020 host_accessor.">host_accessor</a> using its own local buffer.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000077">Todo:</a></b></dt><dd>Implement a real local accessor handling several work-group running in parallel </dd></dl>

<p class="definition">Definition at line <a class="el" href="local__accessor_8hpp_source.html#l00046">46</a> of file <a class="el" href="local__accessor_8hpp_source.html">local_accessor.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4__inherit__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4_inherit__map" id="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4_inherit__map">
<area shape="rect" title="The local accessor specialization abstracts the way local memory is allocated to a kernel to be share..." alt="" coords="760,129,921,185"/>
<area shape="rect" href="group__data.html" title=" " alt="" coords="511,89,705,145"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base" title="The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer..." alt="" coords="237,5,429,32"/>
<area shape="rect" href="group__execution.html" title=" " alt="" coords="211,57,456,98"/>
<area shape="rect" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor" title="SYCL accessor mixin providing multi&#45;dimensional access features." alt="" coords="5,57,163,98"/>
<area shape="rect" title=" " alt="" coords="253,122,414,193"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="240,217,427,273"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="504,169,712,225"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4__coll__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4_coll__map" id="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4_coll__map">
<area shape="rect" title="The local accessor specialization abstracts the way local memory is allocated to a kernel to be share..." alt="" coords="1099,355,1260,411"/>
<area shape="rect" href="group__data.html" title=" " alt="" coords="848,188,1043,244"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base" title="The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer..." alt="" coords="528,64,720,91"/>
<area shape="rect" title=" " alt="" coords="276,57,407,98"/>
<area shape="rect" title=" " alt="" coords="313,5,370,32"/>
<area shape="rect" href="group__execution.html" title=" " alt="" coords="501,115,747,157"/>
<area shape="rect" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor" title="SYCL accessor mixin providing multi&#45;dimensional access features." alt="" coords="263,122,420,163"/>
<area shape="rect" title=" " alt="" coords="5,115,168,171"/>
<area shape="rect" title=" " alt="" coords="543,181,705,251"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="531,276,717,332"/>
<area shape="rect" title=" " alt="" coords="559,356,689,412"/>
<area shape="rect" href="classfriend.html" title=" " alt="" coords="597,13,651,40"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="841,431,1049,487"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:aab5e6102db9388ea1d8a50d0ec01abdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aab5e6102db9388ea1d8a50d0ec01abdb">accessor</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;allocation_size, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:aab5e6102db9388ea1d8a50d0ec01abdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a local accessor of the right size.  <a href="group__data.html#aab5e6102db9388ea1d8a50d0ec01abdb">More...</a><br /></td></tr>
<tr class="separator:aab5e6102db9388ea1d8a50d0ec01abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__data"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__data')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__data.html">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::host_buffer &gt;</a></td></tr>
<tr class="memitem:a21380463aebdb51ae93dd80e37669bfa inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a21380463aebdb51ae93dd80e37669bfa">accessor</a> ()=default</td></tr>
<tr class="memdesc:a21380463aebdb51ae93dd80e37669bfa inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the local accessor hack on top of host accessor.  <a href="group__data.html#a21380463aebdb51ae93dd80e37669bfa">More...</a><br /></td></tr>
<tr class="separator:a21380463aebdb51ae93dd80e37669bfa inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4881bcc1d0dc6fcdd30ebafc37ceada inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab4881bcc1d0dc6fcdd30ebafc37ceada">accessor</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt; target_buffer)</td></tr>
<tr class="memdesc:ab4881bcc1d0dc6fcdd30ebafc37ceada inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a host accessor from an existing buffer.  <a href="group__data.html#ab4881bcc1d0dc6fcdd30ebafc37ceada">More...</a><br /></td></tr>
<tr class="separator:ab4881bcc1d0dc6fcdd30ebafc37ceada inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0ea8db6d7a56a5226b59c7127e6d1d inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9a0ea8db6d7a56a5226b59c7127e6d1d">accessor</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt; target_buffer, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:a9a0ea8db6d7a56a5226b59c7127e6d1d inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a device accessor from an existing buffer.  <a href="group__data.html#a9a0ea8db6d7a56a5226b59c7127e6d1d">More...</a><br /></td></tr>
<tr class="separator:a9a0ea8db6d7a56a5226b59c7127e6d1d inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc187ff81ce7b877785d2fd9116e52 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9acc187ff81ce7b877785d2fd9116e52">register_accessor</a> ()</td></tr>
<tr class="memdesc:a9acc187ff81ce7b877785d2fd9116e52 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the accessor once a <code>std::shared_ptr</code> is created on it.  <a href="group__data.html#a9acc187ff81ce7b877785d2fd9116e52">More...</a><br /></td></tr>
<tr class="separator:a9acc187ff81ce7b877785d2fd9116e52 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e87e3b06183000b805e1d60808cfca inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a46e87e3b06183000b805e1d60808cfca">get_buffer</a> ()</td></tr>
<tr class="memdesc:a46e87e3b06183000b805e1d60808cfca inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer used to create the accessor.  <a href="group__data.html#a46e87e3b06183000b805e1d60808cfca">More...</a><br /></td></tr>
<tr class="separator:a46e87e3b06183000b805e1d60808cfca inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48edd495ed98735815a64a4ebfb2942e inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a48edd495ed98735815a64a4ebfb2942e">is_read_access</a> () const</td></tr>
<tr class="memdesc:a48edd495ed98735815a64a4ebfb2942e inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the accessor has a read access right.  <a href="group__data.html#a48edd495ed98735815a64a4ebfb2942e">More...</a><br /></td></tr>
<tr class="separator:a48edd495ed98735815a64a4ebfb2942e inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93b6f20bc4c61705ae616c02b5ad8ed inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">is_write_access</a> () const</td></tr>
<tr class="memdesc:ae93b6f20bc4c61705ae616c02b5ad8ed inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the accessor has a write access right.  <a href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">More...</a><br /></td></tr>
<tr class="separator:ae93b6f20bc4c61705ae616c02b5ad8ed inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__data"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__data')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">trisycl::detail::accessor_base</a></td></tr>
<tr class="memitem:a0f17346e18ae668ecb8175ff3b2ccb76 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">set_order</a> (std::size_t o)</td></tr>
<tr class="memdesc:a0f17346e18ae668ecb8175ff3b2ccb76 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order of the accessor.  <a href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">More...</a><br /></td></tr>
<tr class="separator:a0f17346e18ae668ecb8175ff3b2ccb76 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5efdf051df9db11cfc7d4be3d7673f0 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#af5efdf051df9db11cfc7d4be3d7673f0">get_order</a> ()</td></tr>
<tr class="memdesc:af5efdf051df9db11cfc7d4be3d7673f0 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the order of the accessor.  <a href="group__data.html#af5efdf051df9db11cfc7d4be3d7673f0">More...</a><br /></td></tr>
<tr class="separator:af5efdf051df9db11cfc7d4be3d7673f0 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980d5757946fa394716ea51b6a1bc9d7 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">virtual boost::compute::buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">get_cl_buffer</a> () const =0</td></tr>
<tr class="memdesc:a980d5757946fa394716ea51b6a1bc9d7 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boost::compute::buffer or throw if unset.  <a href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">More...</a><br /></td></tr>
<tr class="separator:a980d5757946fa394716ea51b6a1bc9d7 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72bda8f733bd016a15f3d7ad3112e28 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#af72bda8f733bd016a15f3d7ad3112e28">~accessor_base</a> ()</td></tr>
<tr class="separator:af72bda8f733bd016a15f3d7ad3112e28 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__execution.html">trisycl::facade::accessor&lt; mixin::accessor&lt; T, Dimensions &gt; &gt;</a></td></tr>
<tr class="memitem:a6eef273a240060cb62a4a80c51b35eb9 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6eef273a240060cb62a4a80c51b35eb9">operator[]</a> (T... indices)</td></tr>
<tr class="memdesc:a6eef273a240060cb62a4a80c51b35eb9 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...].  <a href="group__execution.html#a6eef273a240060cb62a4a80c51b35eb9">More...</a><br /></td></tr>
<tr class="separator:a6eef273a240060cb62a4a80c51b35eb9 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc322d386c9d5a3bbc0b89ab12213f77 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#adc322d386c9d5a3bbc0b89ab12213f77">operator[]</a> (T... indices) const</td></tr>
<tr class="memdesc:adc322d386c9d5a3bbc0b89ab12213f77 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...].  <a href="group__execution.html#adc322d386c9d5a3bbc0b89ab12213f77">More...</a><br /></td></tr>
<tr class="separator:adc322d386c9d5a3bbc0b89ab12213f77 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3f661bde509189c29f05660c1d1708 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a5d3f661bde509189c29f05660c1d1708">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; mixin::rank()&gt; &amp;index)</td></tr>
<tr class="memdesc:a5d3f661bde509189c29f05660c1d1708 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the accessor with [id&lt;&gt;].  <a href="group__execution.html#a5d3f661bde509189c29f05660c1d1708">More...</a><br /></td></tr>
<tr class="separator:a5d3f661bde509189c29f05660c1d1708 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61bbf4173c57c5a8ae49ffe81cde40d inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af61bbf4173c57c5a8ae49ffe81cde40d">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; mixin::rank()&gt; &amp;index) const</td></tr>
<tr class="memdesc:af61bbf4173c57c5a8ae49ffe81cde40d inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the accessor with [id&lt;&gt;].  <a href="group__execution.html#af61bbf4173c57c5a8ae49ffe81cde40d">More...</a><br /></td></tr>
<tr class="separator:af61bbf4173c57c5a8ae49ffe81cde40d inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04d40ff5615efd2d3682ebda7863c2b inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af04d40ff5615efd2d3682ebda7863c2b">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; mixin::rank()&gt; &amp;index)</td></tr>
<tr class="memdesc:af04d40ff5615efd2d3682ebda7863c2b inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with [item&lt;&gt;].  <a href="group__execution.html#af04d40ff5615efd2d3682ebda7863c2b">More...</a><br /></td></tr>
<tr class="separator:af04d40ff5615efd2d3682ebda7863c2b inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b08cda0ba2d9f6b937855a083225df2 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a5b08cda0ba2d9f6b937855a083225df2">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; mixin::rank()&gt; &amp;index) const</td></tr>
<tr class="memdesc:a5b08cda0ba2d9f6b937855a083225df2 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with [item&lt;&gt;].  <a href="group__execution.html#a5b08cda0ba2d9f6b937855a083225df2">More...</a><br /></td></tr>
<tr class="separator:a5b08cda0ba2d9f6b937855a083225df2 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09adf470b84dc7e295b9a821c828634e inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a09adf470b84dc7e295b9a821c828634e">operator[]</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; mixin::rank()&gt; &amp;index)</td></tr>
<tr class="memdesc:a09adf470b84dc7e295b9a821c828634e inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with an [nd_item&lt;&gt;].  <a href="group__execution.html#a09adf470b84dc7e295b9a821c828634e">More...</a><br /></td></tr>
<tr class="separator:a09adf470b84dc7e295b9a821c828634e inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9613839bd22a392c4ca84f598889424c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a9613839bd22a392c4ca84f598889424c">operator[]</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; mixin::rank()&gt; &amp;index) const</td></tr>
<tr class="memdesc:a9613839bd22a392c4ca84f598889424c inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with an [nd_item&lt;&gt;].  <a href="group__execution.html#a9613839bd22a392c4ca84f598889424c">More...</a><br /></td></tr>
<tr class="separator:a9613839bd22a392c4ca84f598889424c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb116683e03d6fa44cee3f2901465244 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">mixin::reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#afb116683e03d6fa44cee3f2901465244">operator*</a> ()</td></tr>
<tr class="memdesc:afb116683e03d6fa44cee3f2901465244 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of the accessor.  <a href="group__execution.html#afb116683e03d6fa44cee3f2901465244">More...</a><br /></td></tr>
<tr class="separator:afb116683e03d6fa44cee3f2901465244 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb77f9ba773cf177f4464e51deeffa3 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">mixin::reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aabb77f9ba773cf177f4464e51deeffa3">operator*</a> () const</td></tr>
<tr class="memdesc:aabb77f9ba773cf177f4464e51deeffa3 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of the accessor.  <a href="group__execution.html#aabb77f9ba773cf177f4464e51deeffa3">More...</a><br /></td></tr>
<tr class="separator:aabb77f9ba773cf177f4464e51deeffa3 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402ca1b3328d01fea7fa8953d303a208 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a402ca1b3328d01fea7fa8953d303a208">get_pointer</a> ()</td></tr>
<tr class="memdesc:a402ca1b3328d01fea7fa8953d303a208 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the data.  <a href="group__execution.html#a402ca1b3328d01fea7fa8953d303a208">More...</a><br /></td></tr>
<tr class="separator:a402ca1b3328d01fea7fa8953d303a208 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe2f0ac3385cfe2c5127490a0b868db inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a0fe2f0ac3385cfe2c5127490a0b868db">begin</a> ()</td></tr>
<tr class="memdesc:a0fe2f0ac3385cfe2c5127490a0b868db inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward all the iterator functions to the implementation.  <a href="group__execution.html#a0fe2f0ac3385cfe2c5127490a0b868db">More...</a><br /></td></tr>
<tr class="separator:a0fe2f0ac3385cfe2c5127490a0b868db inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1e639022a7e80f5934dedefd860b82 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a7e1e639022a7e80f5934dedefd860b82">end</a> ()</td></tr>
<tr class="separator:a7e1e639022a7e80f5934dedefd860b82 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d19d8277ca63b730cad67d7e17d5b6c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a4d19d8277ca63b730cad67d7e17d5b6c">cbegin</a> ()</td></tr>
<tr class="separator:a4d19d8277ca63b730cad67d7e17d5b6c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb172a662af09174e2686c4412be40f2 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aeb172a662af09174e2686c4412be40f2">cend</a> ()</td></tr>
<tr class="separator:aeb172a662af09174e2686c4412be40f2 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b54e3307c9ed22506e90ca8d89f26f inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a2187a41b81c402735f83bd7aed70c136">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ae2b54e3307c9ed22506e90ca8d89f26f">rbegin</a> ()</td></tr>
<tr class="separator:ae2b54e3307c9ed22506e90ca8d89f26f inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581bd7d35303570b9b708f0ac29b9c22 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a2187a41b81c402735f83bd7aed70c136">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a581bd7d35303570b9b708f0ac29b9c22">rend</a> ()</td></tr>
<tr class="separator:a581bd7d35303570b9b708f0ac29b9c22 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a188afc42b14b542fce66bc076b73ff inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae46a2abe59ad97ea115f7c6f125e5f80">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a1a188afc42b14b542fce66bc076b73ff">crbegin</a> () const</td></tr>
<tr class="separator:a1a188afc42b14b542fce66bc076b73ff inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d2c16439fcb44fd0cad68097cb1177 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae46a2abe59ad97ea115f7c6f125e5f80">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a78d2c16439fcb44fd0cad68097cb1177">crend</a> () const</td></tr>
<tr class="separator:a78d2c16439fcb44fd0cad68097cb1177 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aa952a1cd3084acfd5848c96e1307b722">accessor</a> ()=default</td></tr>
<tr class="memdesc:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the local accessor hack on top of host accessor.  <a href="group__execution.html#aa952a1cd3084acfd5848c96e1307b722">More...</a><br /></td></tr>
<tr class="separator:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a4bee5e8e1a4cc07794c8603ceb05449c">accessor</a> (<a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> <a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;r)</td></tr>
<tr class="memdesc:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor of dimensions r on top of data storage.  <a href="group__execution.html#a4bee5e8e1a4cc07794c8603ceb05449c">More...</a><br /></td></tr>
<tr class="separator:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#addcb16193eee7d27f95ad2562a3647c1">accessor</a> (const <a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> &amp;m)</td></tr>
<tr class="memdesc:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor from another mdspan.  <a href="group__execution.html#addcb16193eee7d27f95ad2562a3647c1">More...</a><br /></td></tr>
<tr class="separator:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">update</a> (<a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> <a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;r)</td></tr>
<tr class="memdesc:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the accessor to target somewhere else.  <a href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">More...</a><br /></td></tr>
<tr class="separator:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">get_range</a> () const</td></tr>
<tr class="memdesc:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor.  <a href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">More...</a><br /></td></tr>
<tr class="separator:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">get_count</a> () const</td></tr>
<tr class="memdesc:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in the buffer.  <a href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">More...</a><br /></td></tr>
<tr class="separator:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">get_size</a> () const</td></tr>
<tr class="memdesc:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the buffer storage in bytes.  <a href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">More...</a><br /></td></tr>
<tr class="separator:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a> ()</td></tr>
<tr class="memdesc:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying storage.  <a href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">More...</a><br /></td></tr>
<tr class="separator:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6e1886294408463407c1beccd8ca683d">tuple_indexed_access</a> (const auto &amp;tuple_like_indices)</td></tr>
<tr class="memdesc:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element with indices implementing a tuple interface.  <a href="group__execution.html#a6e1886294408463407c1beccd8ca683d">More...</a><br /></td></tr>
<tr class="separator:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:afed1ec4362c68b1dc067e4f814204bef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#afed1ec4362c68b1dc067e4f814204bef">hb</a> = <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a> &gt;</td></tr>
<tr class="separator:afed1ec4362c68b1dc067e4f814204bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a67db08d2c9b5e799ad2d1dbd4c0d5d36"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">buffer</a>&lt; T, Dimensions &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a67db08d2c9b5e799ad2d1dbd4c0d5d36">buf</a></td></tr>
<tr class="separator:a67db08d2c9b5e799ad2d1dbd4c0d5d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__execution.html">trisycl::facade::accessor&lt; mixin::accessor&lt; T, Dimensions &gt; &gt;</a></td></tr>
<tr class="memitem:ae117ebf0aa308a78a9eecf8df1f37510 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a> = typename <a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">mixin::pointer</a></td></tr>
<tr class="separator:ae117ebf0aa308a78a9eecf8df1f37510 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1fc9f365afffa58e2ebcf6d5ecb325 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a> = typename <a class="el" href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">mixin::const_pointer</a></td></tr>
<tr class="separator:a1a1fc9f365afffa58e2ebcf6d5ecb325 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2187a41b81c402735f83bd7aed70c136 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2187a41b81c402735f83bd7aed70c136">reverse_iterator</a> = typename std::reverse_iterator&lt; <a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a> &gt;</td></tr>
<tr class="separator:a2187a41b81c402735f83bd7aed70c136 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46a2abe59ad97ea115f7c6f125e5f80 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ae46a2abe59ad97ea115f7c6f125e5f80">const_reverse_iterator</a> = typename std::reverse_iterator&lt; <a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a> &gt;</td></tr>
<tr class="separator:ae46a2abe59ad97ea115f7c6f125e5f80 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> = T</td></tr>
<tr class="memdesc:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to SYCL: provide pieces of STL container interface from mdspan.  <a href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">More...</a><br /></td></tr>
<tr class="separator:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">value_type</a> = std::remove_cv_t&lt; <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> &gt;</td></tr>
<tr class="memdesc:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Even if the buffer is read-only use a non-const type so at least the current implementation can copy the data too.  <a href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">More...</a><br /></td></tr>
<tr class="separator:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e2a9cdf64e350ee9993ad05f43d12 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aad9e2a9cdf64e350ee9993ad05f43d12">non_const_pointer</a> = <a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">value_type</a> *</td></tr>
<tr class="separator:aad9e2a9cdf64e350ee9993ad05f43d12 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> = typename mdspan::accessor_type::data_handle_type</td></tr>
<tr class="memdesc:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to element.  <a href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">More...</a><br /></td></tr>
<tr class="separator:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">const_pointer</a> = const <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> *</td></tr>
<tr class="memdesc:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to const element.  <a href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">More...</a><br /></td></tr>
<tr class="separator:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">reference</a> = typename mdspan::reference</td></tr>
<tr class="memdesc:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type to the elements.  <a href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">More...</a><br /></td></tr>
<tr class="separator:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a> ()</td></tr>
<tr class="memdesc:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions of the buffer.  <a href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">More...</a><br /></td></tr>
<tr class="separator:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="memItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#abd5445bd551db33605ec8fa2709a10e8">tuple_indexed_mdspan_access</a> (auto &amp;&amp;some_mdspan, const auto &amp;tuple_like_indices)</td></tr>
<tr class="memdesc:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an mdspan element with indices implementing a tuple interface.  <a href="group__execution.html#abd5445bd551db33605ec8fa2709a10e8">More...</a><br /></td></tr>
<tr class="separator:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__debug__trace"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__debug__trace')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__debug__trace.html">trisycl::detail::debug&lt; accessor&lt; T, Dimensions, Mode, Target &gt; &gt;</a></td></tr>
<tr class="memitem:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">type_pretty_name</a> ()</td></tr>
<tr class="memdesc:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pretty name of T itself.  <a href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">More...</a><br /></td></tr>
<tr class="separator:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__debug__trace"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__debug__trace')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__debug__trace.html">trisycl::detail::debug&lt; accessor&lt; T, Dimensions, Mode, access::target::local &gt; &gt;</a></td></tr>
<tr class="memitem:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">type_pretty_name</a> ()</td></tr>
<tr class="memdesc:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pretty name of T itself.  <a href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">More...</a><br /></td></tr>
<tr class="separator:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> = std::mdspan&lt; <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a>, std::dextents&lt; std::size_t, Dimensions &gt; &gt;</td></tr>
<tr class="memdesc:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory lay-out of a buffer is a dynamic multidimensional array.  <a href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">More...</a><br /></td></tr>
<tr class="separator:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_group__data"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_group__data')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="group__data.html">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::host_buffer &gt;</a></td></tr>
<tr class="memitem:a4c51168df9f102bc21423a5c01285450 inherit pro_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a4c51168df9f102bc21423a5c01285450">set_buffer</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>)</td></tr>
<tr class="memdesc:a4c51168df9f102bc21423a5c01285450 inherit pro_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set later the current buffer associated to this accessor.  <a href="group__data.html#a4c51168df9f102bc21423a5c01285450">More...</a><br /></td></tr>
<tr class="separator:a4c51168df9f102bc21423a5c01285450 inherit pro_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memTemplParams" colspan="2">template&lt;typename BasicType , typename FinalType &gt; </td></tr>
<tr class="memitem:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memTemplItemLeft" align="right" valign="top">const std::array&lt; typename mdspan::size_type, <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__execution.html#a255326fb325821d440d826dabda8f043">extents_cast</a> (const <a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">detail::small_array</a>&lt; BasicType, FinalType, <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;sa)</td></tr>
<tr class="memdesc:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a SYCL range/id-like into a mdspan index array, which is an array of std::size_t into an array of std::ptrdiff_t.  <a href="group__execution.html#a255326fb325821d440d826dabda8f043">More...</a><br /></td></tr>
<tr class="separator:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">set_access</a> (const <a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> &amp;<a class="el" href="opencl__spir_8h.html#afce50bc7a23ec77afc73ea78f6f569e9">a</a>)</td></tr>
<tr class="memdesc:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set later the mdspan associated to this accessor.  <a href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">More...</a><br /></td></tr>
<tr class="separator:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group__data"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group__data')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">trisycl::detail::accessor_base</a></td></tr>
<tr class="memitem:ae542f16a71fdeb8797e59d711b7ed124 inherit pro_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a></td></tr>
<tr class="memdesc:ae542f16a71fdeb8797e59d711b7ed124 inherit pro_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task where the accessor is used in.  <a href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">More...</a><br /></td></tr>
<tr class="separator:ae542f16a71fdeb8797e59d711b7ed124 inherit pro_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b32ac13bfd168d1318d7b5e84b8370 inherit pro_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">order</a></td></tr>
<tr class="memdesc:a75b32ac13bfd168d1318d7b5e84b8370 inherit pro_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">The declaration order of the accessor.  <a href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">More...</a><br /></td></tr>
<tr class="separator:a75b32ac13bfd168d1318d7b5e84b8370 inherit pro_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">access</a></td></tr>
<tr class="memdesc:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the multi-dimensional interface to the data that may point to either allocation in the case of storage managed by SYCL itself or to some other memory location in the case of host memory or storage&lt;&gt; abstraction use.  <a href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">More...</a><br /></td></tr>
<tr class="separator:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="afed1ec4362c68b1dc067e4f814204bef" name="afed1ec4362c68b1dc067e4f814204bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed1ec4362c68b1dc067e4f814204bef">&#9670;&nbsp;</a></span>hb</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2">access::target::local</a> &gt;::hb =  <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">accessor</a>&lt;T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="local__accessor_8hpp_source.html#l00050">50</a> of file <a class="el" href="local__accessor_8hpp_source.html">local_accessor.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="aab5e6102db9388ea1d8a50d0ec01abdb" name="aab5e6102db9388ea1d8a50d0ec01abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5e6102db9388ea1d8a50d0ec01abdb">&#9670;&nbsp;</a></span>accessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2">access::target::local</a> &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>allocation_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a local accessor of the right size. </p>

<p class="definition">Definition at line <a class="el" href="local__accessor_8hpp_source.html#l00057">57</a> of file <a class="el" href="local__accessor_8hpp_source.html">local_accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   59</span>      : <a class="code hl_variable" href="group__data.html#a67db08d2c9b5e799ad2d1dbd4c0d5d36">buf</a> { std::make_shared&lt;buffer&lt;T, Dimensions&gt;&gt;(allocation_size) } {</div>
<div class="line"><span class="lineno">   60</span>    this-&gt;<a class="code hl_function" href="group__data.html#a4c51168df9f102bc21423a5c01285450">set_buffer</a>(<a class="code hl_variable" href="group__data.html#a67db08d2c9b5e799ad2d1dbd4c0d5d36">buf</a>);</div>
<div class="line"><span class="lineno">   61</span>    this-&gt;<a class="code hl_function" href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">set_access</a>(<a class="code hl_variable" href="group__data.html#a67db08d2c9b5e799ad2d1dbd4c0d5d36">buf</a>-&gt;access);</div>
<div class="line"><span class="lineno">   62</span>  }</div>
<div class="ttc" id="agroup__data_html_a4c51168df9f102bc21423a5c01285450"><div class="ttname"><a href="group__data.html#a4c51168df9f102bc21423a5c01285450">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::host_buffer &gt;::set_buffer</a></div><div class="ttdeci">void set_buffer(std::shared_ptr&lt; detail::buffer&lt; T, Dimensions &gt; &gt; b)</div><div class="ttdoc">Set later the current buffer associated to this accessor.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00229">accessor.hpp:229</a></div></div>
<div class="ttc" id="agroup__data_html_a67db08d2c9b5e799ad2d1dbd4c0d5d36"><div class="ttname"><a href="group__data.html#a67db08d2c9b5e799ad2d1dbd4c0d5d36">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;::buf</a></div><div class="ttdeci">std::shared_ptr&lt; buffer&lt; T, Dimensions &gt; &gt; buf</div><div class="ttdef"><b>Definition:</b> <a href="local__accessor_8hpp_source.html#l00053">local_accessor.hpp:53</a></div></div>
<div class="ttc" id="agroup__execution_html_a8dc014b33aba699cc4a9e2810df68c0f"><div class="ttname"><a href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">trisycl::mixin::accessor::set_access</a></div><div class="ttdeci">void set_access(const mdspan &amp;a)</div><div class="ttdoc">Set later the mdspan associated to this accessor.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00068">accessor.hpp:68</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00068">trisycl::mixin::accessor&lt; T, Dimensions &gt;::set_access()</a>, and <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00229">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::set_buffer()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_aab5e6102db9388ea1d8a50d0ec01abdb_cgraph.png" border="0" usemap="#agroup__data_aab5e6102db9388ea1d8a50d0ec01abdb_cgraph" alt=""/></div>
<map name="agroup__data_aab5e6102db9388ea1d8a50d0ec01abdb_cgraph" id="agroup__data_aab5e6102db9388ea1d8a50d0ec01abdb_cgraph">
<area shape="rect" title="Construct a local accessor of the right size." alt="" coords="5,24,167,95"/>
<area shape="rect" href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f" title="Set later the mdspan associated to this accessor." alt="" coords="215,5,372,47"/>
<area shape="rect" href="group__data.html#a4c51168df9f102bc21423a5c01285450" title="Set later the current buffer associated to this accessor." alt="" coords="215,71,372,112"/>
</map>
</div>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a67db08d2c9b5e799ad2d1dbd4c0d5d36" name="a67db08d2c9b5e799ad2d1dbd4c0d5d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67db08d2c9b5e799ad2d1dbd4c0d5d36">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">buffer</a>&lt;T, Dimensions&gt; &gt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faf5ddaf0ca7929578b408c909429f68f2">access::target::local</a> &gt;::buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="local__accessor_8hpp_source.html#l00053">53</a> of file <a class="el" href="local__accessor_8hpp_source.html">local_accessor.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1buffer" id="classtrisycl_1_1buffer"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1buffer">&#9670;&nbsp;</a></span>trisycl::buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::buffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, int Dimensions = 1, typename Allocator = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt;<br />
class trisycl::buffer&lt; T, Dimensions, Allocator &gt;</div><p >A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that is used to store data to work on. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000107">Todo:</a></b></dt><dd>There is a naming inconsistency in the specification between buffer and accessor on T versus datatype</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000108">Todo:</a></b></dt><dd>Finish allocator implementation</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000109">Todo:</a></b></dt><dd>Think about the need of an allocator when constructing a buffer from other buffers</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000110">Todo:</a></b></dt><dd>Update the specification to have a non-const allocator for const buffer? Or do we rely on rebind_alloc&lt;T&gt;. But does this work with astate-full allocator?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000111">Todo:</a></b></dt><dd>Add constructors from arrays so that in C++17 the range and type can be infered from the constructor</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000112">Todo:</a></b></dt><dd>Add constructors from array_ref </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00063">63</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::buffer&lt; T, Dimensions, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1buffer__inherit__graph.png" border="0" usemap="#atrisycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map" id="atrisycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map">
<area shape="rect" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ..." alt="" coords="259,97,424,138"/>
<area shape="rect" title=" " alt="" coords="17,5,199,120"/>
<area shape="rect" href="classdetail_1_1debug_3_01buffer_3_01T_00_011_00_01buffer__allocator_3_01std_1_1remove__const__t_3_01T_01_4_01_4_01_4_01_4.html" title=" " alt="" coords="5,144,211,200"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::buffer&lt; T, Dimensions, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1buffer__coll__graph.png" border="0" usemap="#atrisycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map" id="atrisycl_1_1buffer_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map">
<area shape="rect" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ..." alt="" coords="363,151,528,193"/>
<area shape="rect" title=" " alt="" coords="17,5,199,120"/>
<area shape="rect" href="classdetail_1_1debug_3_01buffer_3_01T_00_011_00_01buffer__allocator_3_01std_1_1remove__const__t_3_01T_01_4_01_4_01_4_01_4.html" title=" " alt="" coords="5,144,211,200"/>
<area shape="rect" href="classfriend.html" title=" " alt="" coords="81,224,135,251"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:ae97d555c503db95f43b186067f36a418"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae97d555c503db95f43b186067f36a418">value_type</a> = T</td></tr>
<tr class="memdesc:ae97d555c503db95f43b186067f36a418"><td class="mdescLeft">&#160;</td><td class="mdescRight">The STL-like types.  <a href="group__data.html#ae97d555c503db95f43b186067f36a418">More...</a><br /></td></tr>
<tr class="separator:ae97d555c503db95f43b186067f36a418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75627cf65137ebfba9a08e7236ac0a52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a75627cf65137ebfba9a08e7236ac0a52">reference</a> = <a class="el" href="group__data.html#ae97d555c503db95f43b186067f36a418">value_type</a> &amp;</td></tr>
<tr class="separator:a75627cf65137ebfba9a08e7236ac0a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16be27cee5d83c2c4312c9155a12d8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ac16be27cee5d83c2c4312c9155a12d8a">const_reference</a> = const <a class="el" href="group__data.html#ae97d555c503db95f43b186067f36a418">value_type</a> &amp;</td></tr>
<tr class="separator:ac16be27cee5d83c2c4312c9155a12d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1661bbf9e82979db4c946581732e3957"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a1661bbf9e82979db4c946581732e3957">allocator_type</a> = Allocator</td></tr>
<tr class="separator:a1661bbf9e82979db4c946581732e3957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a36e4fff26408d50b92adbff86035925c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a36e4fff26408d50b92adbff86035925c">buffer</a> ()=default</td></tr>
<tr class="memdesc:a36e4fff26408d50b92adbff86035925c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use default constructors so that we can create a new buffer copy from another one, with either a l-value or an r-value (for std::move() for example).  <a href="group__data.html#a36e4fff26408d50b92adbff86035925c">More...</a><br /></td></tr>
<tr class="separator:a36e4fff26408d50b92adbff86035925c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5ff6e93dbc50ae18b28e6623827c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aef5ff6e93dbc50ae18b28e6623827c4b">buffer</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r, Allocator allocator={})</td></tr>
<tr class="memdesc:aef5ff6e93dbc50ae18b28e6623827c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer of the given size with storage managed by the SYCL runtime.  <a href="group__data.html#aef5ff6e93dbc50ae18b28e6623827c4b">More...</a><br /></td></tr>
<tr class="separator:aef5ff6e93dbc50ae18b28e6623827c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec622fd8cc3430c73aceab8912f104b"><td class="memTemplParams" colspan="2">template&lt;typename Dependent  = T, typename  = std::enable_if_t&lt;!std::is_const&lt;Dependent&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:aeec622fd8cc3430c73aceab8912f104b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#aeec622fd8cc3430c73aceab8912f104b">buffer</a> (const T *host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r, Allocator allocator={})</td></tr>
<tr class="memdesc:aeec622fd8cc3430c73aceab8912f104b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated host memory.  <a href="group__data.html#aeec622fd8cc3430c73aceab8912f104b">More...</a><br /></td></tr>
<tr class="separator:aeec622fd8cc3430c73aceab8912f104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8028efa11a09c1238c5c499d26dcbad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae8028efa11a09c1238c5c499d26dcbad">buffer</a> (T *host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r, Allocator allocator={})</td></tr>
<tr class="memdesc:ae8028efa11a09c1238c5c499d26dcbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated host memory.  <a href="group__data.html#ae8028efa11a09c1238c5c499d26dcbad">More...</a><br /></td></tr>
<tr class="separator:ae8028efa11a09c1238c5c499d26dcbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18733ad06f745ee5cf823d3529168fe4"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; <br />
requires requires { std::begin(std::declval&lt;Range&gt;()); std::end(std::declval&lt;Range&gt;()); } &amp;&amp; (!<a class="el" href="namespacetrisycl_1_1detail.html#a839412f45f55b79e2b0557514de898b6">detail::is_range_v</a>&lt;Range&gt;)</td></tr>
<tr class="memitem:a18733ad06f745ee5cf823d3529168fe4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a18733ad06f745ee5cf823d3529168fe4">buffer</a> (Range &amp;host_data, Allocator allocator={})</td></tr>
<tr class="memdesc:a18733ad06f745ee5cf823d3529168fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated host memory from a range.  <a href="group__data.html#a18733ad06f745ee5cf823d3529168fe4">More...</a><br /></td></tr>
<tr class="separator:a18733ad06f745ee5cf823d3529168fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342d1c16cf165f22daca78b6ce2d7bc0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a342d1c16cf165f22daca78b6ce2d7bc0">buffer</a> (<a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt; &amp;host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;buffer_range, <a class="el" href="namespacetrisycl.html#aa3bd3b66b2b8b0d4de44838b05c4ae1d">trisycl::mutex_class</a> &amp;m, Allocator allocator={})</td></tr>
<tr class="memdesc:a342d1c16cf165f22daca78b6ce2d7bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated memory, using the data in host_data.  <a href="group__data.html#a342d1c16cf165f22daca78b6ce2d7bc0">More...</a><br /></td></tr>
<tr class="separator:a342d1c16cf165f22daca78b6ce2d7bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8475ebb7ab0dc2648fc8cdf42b235d75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a8475ebb7ab0dc2648fc8cdf42b235d75">buffer</a> (<a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt; host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;buffer_range, Allocator allocator={})</td></tr>
<tr class="memdesc:a8475ebb7ab0dc2648fc8cdf42b235d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated memory, using the data in host_data.  <a href="group__data.html#a8475ebb7ab0dc2648fc8cdf42b235d75">More...</a><br /></td></tr>
<tr class="separator:a8475ebb7ab0dc2648fc8cdf42b235d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1fcebb7eeffc00f69407957aa13e1e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ValueType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt; </td></tr>
<tr class="memitem:a3d1fcebb7eeffc00f69407957aa13e1e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a3d1fcebb7eeffc00f69407957aa13e1e">buffer</a> (InputIterator start_iterator, InputIterator end_iterator, Allocator allocator={})</td></tr>
<tr class="memdesc:a3d1fcebb7eeffc00f69407957aa13e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new allocated 1D buffer initialized from the given elements ranging from first up to one before last.  <a href="group__data.html#a3d1fcebb7eeffc00f69407957aa13e1e">More...</a><br /></td></tr>
<tr class="separator:a3d1fcebb7eeffc00f69407957aa13e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bca6180932ebf145dc7e767466db15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a29bca6180932ebf145dc7e767466db15">buffer</a> (<a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; T, Dimensions, Allocator &gt; &amp;<a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; Dimensions &gt; &amp;base_index, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;sub_range, Allocator allocator={})</td></tr>
<tr class="memdesc:a29bca6180932ebf145dc7e767466db15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new sub-buffer without allocation to have separate accessors later.  <a href="group__data.html#a29bca6180932ebf145dc7e767466db15">More...</a><br /></td></tr>
<tr class="separator:a29bca6180932ebf145dc7e767466db15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f74ec8316dd32314a321128fd4bf9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a34f74ec8316dd32314a321128fd4bf9f">buffer</a> (cl_mem mem_object, <a class="el" href="group__execution.html#classtrisycl_1_1queue">queue</a> from_queue, <a class="el" href="classtrisycl_1_1event.html">event</a> available_event={}, Allocator allocator={})</td></tr>
<tr class="memdesc:a34f74ec8316dd32314a321128fd4bf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer from an existing OpenCL memory object associated with a context after waiting for an event signaling the availability of the OpenCL data.  <a href="group__data.html#a34f74ec8316dd32314a321128fd4bf9f">More...</a><br /></td></tr>
<tr class="separator:a34f74ec8316dd32314a321128fd4bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c981bc708c4969c75899e95c177664"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </td></tr>
<tr class="memitem:af8c981bc708c4969c75899e95c177664"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__data.html#classtrisycl_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, Target &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#af8c981bc708c4969c75899e95c177664">get_access</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:af8c981bc708c4969c75899e95c177664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an accessor to the buffer with the required mode.  <a href="group__data.html#af8c981bc708c4969c75899e95c177664">More...</a><br /></td></tr>
<tr class="separator:af8c981bc708c4969c75899e95c177664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ae259a6dad961ee0e17857c047bc53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a11ae259a6dad961ee0e17857c047bc53">mark_as_written</a> ()</td></tr>
<tr class="memdesc:a11ae259a6dad961ee0e17857c047bc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the buffer to behave like if we had created an accessor in write mode.  <a href="group__data.html#a11ae259a6dad961ee0e17857c047bc53">More...</a><br /></td></tr>
<tr class="separator:a11ae259a6dad961ee0e17857c047bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceddb07bed6e43aceb4705e2da88f0a9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode&gt; </td></tr>
<tr class="memitem:aceddb07bed6e43aceb4705e2da88f0a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__data.html#classtrisycl_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#aceddb07bed6e43aceb4705e2da88f0a9">get_access</a> ()</td></tr>
<tr class="memdesc:aceddb07bed6e43aceb4705e2da88f0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a host accessor to the buffer with the required mode.  <a href="group__data.html#aceddb07bed6e43aceb4705e2da88f0a9">More...</a><br /></td></tr>
<tr class="separator:aceddb07bed6e43aceb4705e2da88f0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695d2de4f455be9fcb3f4e6e944e243e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a695d2de4f455be9fcb3f4e6e944e243e">get_range</a> () const</td></tr>
<tr class="memdesc:a695d2de4f455be9fcb3f4e6e944e243e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor.  <a href="group__data.html#a695d2de4f455be9fcb3f4e6e944e243e">More...</a><br /></td></tr>
<tr class="separator:a695d2de4f455be9fcb3f4e6e944e243e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c9bddd70293cc3cb833f0a5d06a5e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a984c9bddd70293cc3cb833f0a5d06a5e">get_count</a> () const</td></tr>
<tr class="memdesc:a984c9bddd70293cc3cb833f0a5d06a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in the buffer.  <a href="group__data.html#a984c9bddd70293cc3cb833f0a5d06a5e">More...</a><br /></td></tr>
<tr class="separator:a984c9bddd70293cc3cb833f0a5d06a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba4e97cae437d39e6d5d95fc36bd5d3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9ba4e97cae437d39e6d5d95fc36bd5d3">get_size</a> () const</td></tr>
<tr class="memdesc:a9ba4e97cae437d39e6d5d95fc36bd5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the buffer storage in bytes.  <a href="group__data.html#a9ba4e97cae437d39e6d5d95fc36bd5d3">More...</a><br /></td></tr>
<tr class="separator:a9ba4e97cae437d39e6d5d95fc36bd5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543940ea05f65b229970c0ded5eb1c22"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a543940ea05f65b229970c0ded5eb1c22">use_count</a> () const</td></tr>
<tr class="memdesc:a543940ea05f65b229970c0ded5eb1c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of buffers that are shared/referenced.  <a href="group__data.html#a543940ea05f65b229970c0ded5eb1c22">More...</a><br /></td></tr>
<tr class="separator:a543940ea05f65b229970c0ded5eb1c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857af808d85b625925d4ba6718665102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a> constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a857af808d85b625925d4ba6718665102">is_read_only</a> () const</td></tr>
<tr class="memdesc:a857af808d85b625925d4ba6718665102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask for read-only status of the buffer.  <a href="group__data.html#a857af808d85b625925d4ba6718665102">More...</a><br /></td></tr>
<tr class="separator:a857af808d85b625925d4ba6718665102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b3552d91b2545a66e66f9b286b0bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a46b3552d91b2545a66e66f9b286b0bba">set_final_data</a> (<a class="el" href="namespacetrisycl.html#aeeda429d2a18afa01f0da7fa444b8da9">weak_ptr_class</a>&lt; T &gt; finalData)</td></tr>
<tr class="memdesc:a46b3552d91b2545a66e66f9b286b0bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set destination of buffer data on destruction.  <a href="group__data.html#a46b3552d91b2545a66e66f9b286b0bba">More...</a><br /></td></tr>
<tr class="separator:a46b3552d91b2545a66e66f9b286b0bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115962ebff5ecde85712eb597fd6a96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a115962ebff5ecde85712eb597fd6a96a">set_final_data</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a115962ebff5ecde85712eb597fd6a96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable write-back on buffer destruction.  <a href="group__data.html#a115962ebff5ecde85712eb597fd6a96a">More...</a><br /></td></tr>
<tr class="separator:a115962ebff5ecde85712eb597fd6a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcfd2145ed456649d68a914a48b79b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#acfcfd2145ed456649d68a914a48b79b7">is_cached</a> (<a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx)</td></tr>
<tr class="memdesc:acfcfd2145ed456649d68a914a48b79b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is already cached in a certain context.  <a href="group__data.html#acfcfd2145ed456649d68a914a48b79b7">More...</a><br /></td></tr>
<tr class="separator:acfcfd2145ed456649d68a914a48b79b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c184163daeeb7a746aa752bc2b4af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a39c184163daeeb7a746aa752bc2b4af0">is_data_up_to_date</a> (<a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx)</td></tr>
<tr class="memdesc:a39c184163daeeb7a746aa752bc2b4af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data stored in the buffer is up-to-date in a certain context.  <a href="group__data.html#a39c184163daeeb7a746aa752bc2b4af0">More...</a><br /></td></tr>
<tr class="separator:a39c184163daeeb7a746aa752bc2b4af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e5c51731726a9f0a7309e8407d8bb7"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename ValueType  = typename std::iterator_traits&lt;              std::remove_reference_t&lt;Iterator&gt;&gt;::value_type&gt; </td></tr>
<tr class="memitem:ad5e5c51731726a9f0a7309e8407d8bb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ad5e5c51731726a9f0a7309e8407d8bb7">set_final_data</a> (Iterator &amp;&amp;finalData)</td></tr>
<tr class="memdesc:ad5e5c51731726a9f0a7309e8407d8bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set destination of buffer data on destruction.  <a href="group__data.html#ad5e5c51731726a9f0a7309e8407d8bb7">More...</a><br /></td></tr>
<tr class="separator:ad5e5c51731726a9f0a7309e8407d8bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:abf8873be9cc00a7b691c7afeaed2e7e1"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#abf8873be9cc00a7b691c7afeaed2e7e1">rank</a> ()</td></tr>
<tr class="memdesc:abf8873be9cc00a7b691c7afeaed2e7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions of the buffer.  <a href="group__data.html#abf8873be9cc00a7b691c7afeaed2e7e1">More...</a><br /></td></tr>
<tr class="separator:abf8873be9cc00a7b691c7afeaed2e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a32d3250591416d4d5213f06d39a9d282"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a32d3250591416d4d5213f06d39a9d282">implementation_t</a> = typename buffer::shared_ptr_implementation</td></tr>
<tr class="separator:a32d3250591416d4d5213f06d39a9d282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:adb7157de5cc9ba52801fdbf786855528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfriend.html">friend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#adb7157de5cc9ba52801fdbf786855528">implementation_t</a></td></tr>
<tr class="separator:adb7157de5cc9ba52801fdbf786855528"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a1661bbf9e82979db4c946581732e3957" name="a1661bbf9e82979db4c946581732e3957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1661bbf9e82979db4c946581732e3957">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::allocator_type =  Allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00076">76</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="ac16be27cee5d83c2c4312c9155a12d8a" name="ac16be27cee5d83c2c4312c9155a12d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16be27cee5d83c2c4312c9155a12d8a">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::const_reference =  const <a class="el" href="group__data.html#ae97d555c503db95f43b186067f36a418">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00075">75</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="a32d3250591416d4d5213f06d39a9d282" name="a32d3250591416d4d5213f06d39a9d282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d3250591416d4d5213f06d39a9d282">&#9670;&nbsp;</a></span>implementation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::implementation_t =  typename buffer::shared_ptr_implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00087">87</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="a75627cf65137ebfba9a08e7236ac0a52" name="a75627cf65137ebfba9a08e7236ac0a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75627cf65137ebfba9a08e7236ac0a52">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::reference =  <a class="el" href="group__data.html#ae97d555c503db95f43b186067f36a418">value_type</a>&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00074">74</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="ae97d555c503db95f43b186067f36a418" name="ae97d555c503db95f43b186067f36a418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97d555c503db95f43b186067f36a418">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The STL-like types. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00073">73</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a36e4fff26408d50b92adbff86035925c" name="a36e4fff26408d50b92adbff86035925c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e4fff26408d50b92adbff86035925c">&#9670;&nbsp;</a></span>buffer() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use default constructors so that we can create a new buffer copy from another one, with either a l-value or an r-value (for std::move() for example). </p>
<p >Since we just copy the shared_ptr&lt;&gt; from the shared_ptr_implementation above, this is where/how the sharing magic is happening with reference counting in this case. </p>

</div>
</div>
<a id="aef5ff6e93dbc50ae18b28e6623827c4b" name="aef5ff6e93dbc50ae18b28e6623827c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5ff6e93dbc50ae18b28e6623827c4b">&#9670;&nbsp;</a></span>buffer() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer of the given size with storage managed by the SYCL runtime. </p>
<p >The default behavior is to use the default host buffer allocator, in order to allow for host accesses. If the type of the buffer, has the const qualifier, then the default allocator will remove the qualifier to allow host access to the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00120">120</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  120</span>                                                           {})</div>
<div class="line"><span class="lineno">  121</span>    : <a class="code hl_typedef" href="group__data.html#a32d3250591416d4d5213f06d39a9d282">implementation_t</a> { detail::waiter&lt;T, Dimensions, Allocator&gt;(</div>
<div class="line"><span class="lineno">  122</span>                         <span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt; { r }) }</div>
<div class="line"><span class="lineno">  123</span>      {}</div>
<div class="ttc" id="agroup__data_html_a32d3250591416d4d5213f06d39a9d282"><div class="ttname"><a href="group__data.html#a32d3250591416d4d5213f06d39a9d282">trisycl::buffer::implementation_t</a></div><div class="ttdeci">typename buffer::shared_ptr_implementation implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00087">buffer.hpp:87</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeec622fd8cc3430c73aceab8912f104b" name="aeec622fd8cc3430c73aceab8912f104b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec622fd8cc3430c73aceab8912f104b">&#9670;&nbsp;</a></span>buffer() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Dependent  = T, typename  = std::enable_if_t&lt;!std::is_const&lt;Dependent&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <code><a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45" title="The allocator objects give the programmer some control on how the memory is allocated inside SYCL.">trisycl::buffer_allocator&lt;T&gt;</a></code> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The host address is </p><div class="fragment"><div class="line"><span class="keyword">const</span> T* </div>
</div><!-- fragment --><p>, so the host memory is read-only.</p>
<p >However, the typename T is not const so the device accesses can be both read and write accesses. Since, the host_data is const, this buffer is only initialized with this memory and there is no write after its destruction, unless there is another final data address given after construction of the buffer.</p>
<p >Only enable this constructor if it is not the same as the one with </p><div class="fragment"><div class="line"><span class="keyword">const</span> T *host_data </div>
</div><!-- fragment --><p>, which is when <code>T</code> is already a constant type.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000117">Todo:</a></b></dt><dd>Actually this is redundant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00153">153</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  155</span>                               {})</div>
<div class="line"><span class="lineno">  156</span>    : <a class="code hl_typedef" href="group__data.html#a32d3250591416d4d5213f06d39a9d282">implementation_t</a> { <a class="code hl_function" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div>
<div class="line"><span class="lineno">  157</span>                         { host_data, r }) }</div>
<div class="line"><span class="lineno">  158</span>  {}</div>
<div class="ttc" id="agroup__data_html_ga39aab9a5c74f01bd53de448ab7d9048a"><div class="ttname"><a href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">trisycl::detail::waiter</a></div><div class="ttdeci">auto waiter(detail::buffer&lt; T, Dimensions &gt; *b)</div><div class="ttdoc">Helper function to create a new buffer_waiter.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00077">buffer_waiter.hpp:77</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8028efa11a09c1238c5c499d26dcbad" name="ae8028efa11a09c1238c5c499d26dcbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8028efa11a09c1238c5c499d26dcbad">&#9670;&nbsp;</a></span>buffer() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated host memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45" title="The allocator objects give the programmer some control on how the memory is allocated inside SYCL.">trisycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The memory is owned by the runtime during the lifetime of the object. Data is copied back to the host unless the user overrides the behavior using the set_final_data method. host_data points to the storage and values used by the buffer and range&lt;Dimensions&gt; defines the size. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00177">177</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  179</span>                               {})</div>
<div class="line"><span class="lineno">  180</span>    : <a class="code hl_typedef" href="group__data.html#a32d3250591416d4d5213f06d39a9d282">implementation_t</a> { <a class="code hl_function" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div>
<div class="line"><span class="lineno">  181</span>                         { host_data, r }) }</div>
<div class="line"><span class="lineno">  182</span>  {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a18733ad06f745ee5cf823d3529168fe4" name="a18733ad06f745ee5cf823d3529168fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18733ad06f745ee5cf823d3529168fe4">&#9670;&nbsp;</a></span>buffer() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Range &gt; <br />
requires requires { std::begin(std::declval&lt;Range&gt;()); std::end(std::declval&lt;Range&gt;()); } &amp;&amp; (!<a class="el" href="namespacetrisycl_1_1detail.html#a839412f45f55b79e2b0557514de898b6">detail::is_range_v</a>&lt;Range&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated host memory from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45" title="The allocator objects give the programmer some control on how the memory is allocated inside SYCL.">trisycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The memory is owned by the runtime during the lifetime of the object. Data is copied back to the host unless the user overrides the behavior using the set_final_data method. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00207">207</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  208</span>                               {})</div>
<div class="line"><span class="lineno">  209</span>      : <a class="code hl_function" href="group__data.html#a36e4fff26408d50b92adbff86035925c">buffer</a> { host_data.begin(),</div>
<div class="line"><span class="lineno">  210</span>                 <a class="code hl_function" href="group__parallelism.html#gaf13e5aad587b3e566ee1be683f3417e4">range</a> { std::ranges::distance(host_data) } } {}</div>
<div class="ttc" id="agroup__data_html_a36e4fff26408d50b92adbff86035925c"><div class="ttname"><a href="group__data.html#a36e4fff26408d50b92adbff86035925c">trisycl::buffer::buffer</a></div><div class="ttdeci">buffer()=default</div><div class="ttdoc">Use default constructors so that we can create a new buffer copy from another one,...</div></div>
<div class="ttc" id="agroup__parallelism_html_gaf13e5aad587b3e566ee1be683f3417e4"><div class="ttname"><a href="group__parallelism.html#gaf13e5aad587b3e566ee1be683f3417e4">trisycl::range</a></div><div class="ttdeci">range(BasicType... Args) -&gt; range&lt; sizeof...(Args)&gt;</div><div class="ttdoc">User-defined deduction guides to deduce the rank of a range from the number of arguments.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a342d1c16cf165f22daca78b6ce2d7bc0" name="a342d1c16cf165f22daca78b6ce2d7bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342d1c16cf165f22daca78b6ce2d7bc0">&#9670;&nbsp;</a></span>buffer() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetrisycl.html#aa3bd3b66b2b8b0d4de44838b05c4ae1d">trisycl::mutex_class</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated memory, using the data in host_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45" title="The allocator objects give the programmer some control on how the memory is allocated inside SYCL.">trisycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The ownership of the host_data is shared between the runtime and the user. In order to enable both the user application and the SYCL runtime to use the same pointer, a <a class="el" href="namespacetrisycl.html#aa3bd3b66b2b8b0d4de44838b05c4ae1d">trisycl::mutex_class</a> is used. The mutex m is locked by the runtime whenever the data is in use and unlocked otherwise. Data is synchronized with host_data, when the mutex is unlocked by the runtime.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000118">Todo:</a></b></dt><dd>update the specification to replace the pointer by a reference and provide the constructor with and without a mutex </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00233">233</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  236</span>                               {}) {</div>
<div class="line"><span class="lineno">  237</span>    <a class="code hl_define" href="group__helpers.html#gabc864dbff357567e07f18baf409db80e">TRISYCL_UNIMPL</a>;</div>
<div class="line"><span class="lineno">  238</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8475ebb7ab0dc2648fc8cdf42b235d75" name="a8475ebb7ab0dc2648fc8cdf42b235d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8475ebb7ab0dc2648fc8cdf42b235d75">&#9670;&nbsp;</a></span>buffer() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated memory, using the data in host_data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">host_data</td><td>points to the storage and values used by the buffer</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>defines the size</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45" title="The allocator objects give the programmer some control on how the memory is allocated inside SYCL.">trisycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<p>The ownership of the host_data is shared between the runtime and the user. In order to enable both the user application and the SYCL runtime to use the same pointer, a <a class="el" href="namespacetrisycl.html#aa3bd3b66b2b8b0d4de44838b05c4ae1d">trisycl::mutex_class</a> is used.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000119">Todo:</a></b></dt><dd>add this mutex-less constructor to the specification </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00259">259</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  261</span>                               {})</div>
<div class="line"><span class="lineno">  262</span>    : <a class="code hl_typedef" href="group__data.html#a32d3250591416d4d5213f06d39a9d282">implementation_t</a> { <a class="code hl_function" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div>
<div class="line"><span class="lineno">  263</span>                         { host_data, buffer_range }) }</div>
<div class="line"><span class="lineno">  264</span>  {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d1fcebb7eeffc00f69407957aa13e1e" name="a3d1fcebb7eeffc00f69407957aa13e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1fcebb7eeffc00f69407957aa13e1e">&#9670;&nbsp;</a></span>buffer() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator , typename ValueType  = typename std::iterator_traits&lt;InputIterator&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>start_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new allocated 1D buffer initialized from the given elements ranging from first up to one before last. </p>
<p >The data is copied to an intermediate memory position by the runtime. Data is written back to the same iterator set if the iterator is not a const iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start_iterator</td><td>points to the first element to copy</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_iterator</td><td>points to just after the last element to copy</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>is to be used by the SYCL runtime, of type <a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45" title="The allocator objects give the programmer some control on how the memory is allocated inside SYCL.">trisycl::buffer_allocator&lt;T&gt;</a> by default</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000120">Todo:</a></b></dt><dd>Implement the copy back at buffer destruction</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000121">Todo:</a></b></dt><dd>Generalize this for n-D and provide column-major and row-major initialization</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000122">Todo:</a></b></dt><dd>a reason to have this nD is that set_final_data(weak_ptr_class&lt;T&gt; &amp; finalData) is actually doing this linearization anyway</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000123">Todo:</a></b></dt><dd>Allow read-only buffer construction too</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000124">Todo:</a></b></dt><dd>update the specification to deal with forward iterators instead and rewrite back only when it is non const and output iterator at least</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000125">Todo:</a></b></dt><dd>Allow initialization from ranges and collections à la STL </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00304">304</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  306</span>                               {}) :</div>
<div class="line"><span class="lineno">  307</span>    <a class="code hl_typedef" href="group__data.html#a32d3250591416d4d5213f06d39a9d282">implementation_t</a> { <a class="code hl_function" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">detail::waiter</a>(<span class="keyword">new</span> detail::buffer&lt;T, Dimensions&gt;</div>
<div class="line"><span class="lineno">  308</span>                       { start_iterator, end_iterator }) }</div>
<div class="line"><span class="lineno">  309</span>  {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a29bca6180932ebf145dc7e767466db15" name="a29bca6180932ebf145dc7e767466db15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bca6180932ebf145dc7e767466db15">&#9670;&nbsp;</a></span>buffer() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; T, Dimensions, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new sub-buffer without allocation to have separate accessors later. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td>is the buffer with the real data</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_index</td><td>specifies the origin of the sub-buffer inside the buffer b</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub_range</td><td>specifies the size of the sub-buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000126">Todo:</a></b></dt><dd>To be implemented</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000127">Todo:</a></b></dt><dd>Update the specification to replace index by id </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00326">326</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  329</span>                               {}) { <a class="code hl_define" href="group__helpers.html#gabc864dbff357567e07f18baf409db80e">TRISYCL_UNIMPL</a>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34f74ec8316dd32314a321128fd4bf9f" name="a34f74ec8316dd32314a321128fd4bf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f74ec8316dd32314a321128fd4bf9f">&#9670;&nbsp;</a></span>buffer() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">cl_mem&#160;</td>
          <td class="paramname"><em>mem_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1queue">queue</a>&#160;</td>
          <td class="paramname"><em>from_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtrisycl_1_1event.html">event</a>&#160;</td>
          <td class="paramname"><em>available_event</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Allocator&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a buffer from an existing OpenCL memory object associated with a context after waiting for an event signaling the availability of the OpenCL data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mem_object</td><td>is the OpenCL memory object to use</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">from_queue</td><td>is the queue associated to the memory object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">available_event</td><td>specifies the event to wait for if non null</td></tr>
  </table>
  </dd>
</dl>
<p>Note that a buffer created from a cl_mem object will only have one underlying cl_mem for the lifetime of the buffer and use on an incompatible queue constitues an error.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000128">Todo:</a></b></dt><dd>To be implemented</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000129">Todo:</a></b></dt><dd>Improve the specification to allow CLHPP objects too </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00353">353</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  355</span>                                 {},</div>
<div class="line"><span class="lineno">  356</span>         Allocator allocator = {}) { <a class="code hl_define" href="group__helpers.html#gabc864dbff357567e07f18baf409db80e">TRISYCL_UNIMPL</a>;  }</div>
</div><!-- fragment -->
</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="aceddb07bed6e43aceb4705e2da88f0a9" name="aceddb07bed6e43aceb4705e2da88f0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceddb07bed6e43aceb4705e2da88f0a9">&#9670;&nbsp;</a></span>get_access() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a> &gt; <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a host accessor to the buffer with the required mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Mode</td><td>is the requested access mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000132">Todo:</a></b></dt><dd>Implement the modes</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000133">Todo:</a></b></dt><dd>More elegant solution </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00408">408</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  408</span>               {</div>
<div class="line"><span class="lineno">  409</span>    implementation-&gt;implementation-&gt;template track_access_mode&lt;Mode, access::target::host_buffer&gt;();</div>
<div class="line"><span class="lineno">  410</span>    <span class="keywordflow">return</span> { *<span class="keyword">this</span> };</div>
<div class="line"><span class="lineno">  411</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8c981bc708c4969c75899e95c177664" name="af8c981bc708c4969c75899e95c177664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c981bc708c4969c75899e95c177664">&#9670;&nbsp;</a></span>get_access() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::global_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1accessor">accessor</a>&lt; T, Dimensions, Mode, Target &gt; <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_access </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an accessor to the buffer with the required mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">Mode</td><td>is the requested access mode</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">Target</td><td>is the type of object to be accessed</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command_group_handler</td><td>is the command group handler in which the kernel is to be executed</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000130">Todo:</a></b></dt><dd>Do we need for an accessor to increase the reference count of a buffer object? It does make more sense for a host-side accessor.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000131">Todo:</a></b></dt><dd>Implement the modes and targets </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00379">379</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  379</span>                                             {</div>
<div class="line"><span class="lineno">  380</span>    <span class="keyword">static_assert</span>(Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a></div>
<div class="line"><span class="lineno">  381</span>                  || Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b">access::target::constant_buffer</a>,</div>
<div class="line"><span class="lineno">  382</span>                  <span class="stringliteral">&quot;get_access(handler) can only deal with access::global_buffer&quot;</span></div>
<div class="line"><span class="lineno">  383</span>                  <span class="stringliteral">&quot; or access::constant_buffer (for host_buffer accessor&quot;</span></div>
<div class="line"><span class="lineno">  384</span>                  <span class="stringliteral">&quot; do not use a command group handler&quot;</span>);</div>
<div class="line"><span class="lineno">  385</span>    implementation-&gt;implementation-&gt;template track_access_mode&lt;Mode, Target&gt;();</div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">return</span> { *<span class="keyword">this</span>, command_group_handler };</div>
<div class="line"><span class="lineno">  387</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b">trisycl::access::constant_buffer</a>, and <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b">trisycl::access::global_buffer</a>.</p>

</div>
</div>
<a id="a984c9bddd70293cc3cb833f0a5d06a5e" name="a984c9bddd70293cc3cb833f0a5d06a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c9bddd70293cc3cb833f0a5d06a5e">&#9670;&nbsp;</a></span>get_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in the buffer. </p>
<p >Equal to <a class="el" href="group__data.html#a695d2de4f455be9fcb3f4e6e944e243e" title="Return a range object representing the size of the buffer in terms of number of elements in each dime...">get_range()</a>[0] * ... * <a class="el" href="group__data.html#a695d2de4f455be9fcb3f4e6e944e243e" title="Return a range object representing the size of the buffer in terms of number of elements in each dime...">get_range()</a>[Dimensions-1]. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00435">435</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  435</span>                         {</div>
<div class="line"><span class="lineno">  436</span>    <span class="keywordflow">return</span> implementation-&gt;implementation-&gt;get_count();</div>
<div class="line"><span class="lineno">  437</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a695d2de4f455be9fcb3f4e6e944e243e" name="a695d2de4f455be9fcb3f4e6e944e243e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695d2de4f455be9fcb3f4e6e944e243e">&#9670;&nbsp;</a></span>get_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000134">Todo:</a></b></dt><dd>rename to the equivalent from array_ref proposals? Such as size() in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0009r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0009r2.html</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00422">422</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  422</span>                         {</div>
<div class="line"><span class="lineno">  423</span>    <span class="comment">/* Interpret the shape which is a pointer to the first element as an</span></div>
<div class="line"><span class="lineno">  424</span><span class="comment">       array of Dimensions elements so that the range&lt;Dimensions&gt;</span></div>
<div class="line"><span class="lineno">  425</span><span class="comment">       constructor is happy with this collection</span></div>
<div class="line"><span class="lineno">  426</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">return</span> implementation-&gt;implementation-&gt;get_range();</div>
<div class="line"><span class="lineno">  428</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ba4e97cae437d39e6d5d95fc36bd5d3" name="a9ba4e97cae437d39e6d5d95fc36bd5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba4e97cae437d39e6d5d95fc36bd5d3">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the buffer storage in bytes. </p>
<p >Equal to <a class="el" href="group__data.html#a984c9bddd70293cc3cb833f0a5d06a5e" title="Returns the total number of elements in the buffer.">get_count()</a>*sizeof(T).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000135">Todo:</a></b></dt><dd>rename to something else. In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0122r0.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0122r0.pdf</a> it is named bytes() for example </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00448">448</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  448</span>                          {</div>
<div class="line"><span class="lineno">  449</span>    <span class="keywordflow">return</span> implementation-&gt;implementation-&gt;get_size();</div>
<div class="line"><span class="lineno">  450</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acfcfd2145ed456649d68a914a48b79b7" name="acfcfd2145ed456649d68a914a48b79b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcfd2145ed456649d68a914a48b79b7">&#9670;&nbsp;</a></span>is_cached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::is_cached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer is already cached in a certain context. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00513">513</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  513</span>                                      {</div>
<div class="line"><span class="lineno">  514</span>    <span class="keywordflow">return</span> implementation-&gt;implementation-&gt;is_cached(ctx);</div>
<div class="line"><span class="lineno">  515</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a39c184163daeeb7a746aa752bc2b4af0" name="a39c184163daeeb7a746aa752bc2b4af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c184163daeeb7a746aa752bc2b4af0">&#9670;&nbsp;</a></span>is_data_up_to_date()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::is_data_up_to_date </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the data stored in the buffer is up-to-date in a certain context. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00520">520</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  520</span>                                               {</div>
<div class="line"><span class="lineno">  521</span>    <span class="keywordflow">return</span> implementation-&gt;implementation-&gt;is_data_up_to_date(ctx);</div>
<div class="line"><span class="lineno">  522</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a857af808d85b625925d4ba6718665102" name="a857af808d85b625925d4ba6718665102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857af808d85b625925d4ba6718665102">&#9670;&nbsp;</a></span>is_read_only()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> constexpr <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::is_read_only </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask for read-only status of the buffer. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000137">Todo:</a></b></dt><dd>Add to specification </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00475">475</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  475</span>                                      {</div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">return</span> std::is_const&lt;T&gt;::value;</div>
<div class="line"><span class="lineno">  477</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11ae259a6dad961ee0e17857c047bc53" name="a11ae259a6dad961ee0e17857c047bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ae259a6dad961ee0e17857c047bc53">&#9670;&nbsp;</a></span>mark_as_written()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::mark_as_written </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the buffer to behave like if we had created an accessor in write mode. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00393">393</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  393</span>                         {</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">return</span> implementation-&gt;implementation-&gt;mark_as_written();</div>
<div class="line"><span class="lineno">  395</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abf8873be9cc00a7b691c7afeaed2e7e1" name="abf8873be9cc00a7b691c7afeaed2e7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8873be9cc00a7b691c7afeaed2e7e1">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto constexpr <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of dimensions of the buffer. </p>
<p >Name inspired from ISO C++ P0009 mdspan papers </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00082">82</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   82</span>{ <span class="keywordflow">return</span> Dimensions; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5e5c51731726a9f0a7309e8407d8bb7" name="ad5e5c51731726a9f0a7309e8407d8bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e5c51731726a9f0a7309e8407d8bb7">&#9670;&nbsp;</a></span>set_final_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator , typename ValueType  = typename std::iterator_traits&lt;              std::remove_reference_t&lt;Iterator&gt;&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype">Iterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>finalData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set destination of buffer data on destruction. </p>
<p >WARNING: the user has to ensure that the object referred to by the iterator will be alive after buffer destruction, otherwise the behavior is undefined. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00535">535</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  535</span>                                            {</div>
<div class="line"><span class="lineno">  536</span>    implementation-&gt;implementation-&gt;set_final_data(</div>
<div class="line"><span class="lineno">  537</span>      std::forward&lt;Iterator&gt;(finalData));</div>
<div class="line"><span class="lineno">  538</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a115962ebff5ecde85712eb597fd6a96a" name="a115962ebff5ecde85712eb597fd6a96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115962ebff5ecde85712eb597fd6a96a">&#9670;&nbsp;</a></span>set_final_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable write-back on buffer destruction. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00505">505</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  505</span>                                    {</div>
<div class="line"><span class="lineno">  506</span>    implementation-&gt;implementation-&gt;set_final_data(<span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  507</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a46b3552d91b2545a66e66f9b286b0bba" name="a46b3552d91b2545a66e66f9b286b0bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b3552d91b2545a66e66f9b286b0bba">&#9670;&nbsp;</a></span>set_final_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetrisycl.html#aeeda429d2a18afa01f0da7fa444b8da9">weak_ptr_class</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>finalData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set destination of buffer data on destruction. </p>
<p >The finalData points to the host memory to which, the outcome of all the buffer processing is going to be copied to.</p>
<p >This is the final pointer, which is going to be accessible after the destruction of the buffer and in the case where this is a valid pointer, the data are going to be copied to this host address.</p>
<p >finalData is different from the original host address, if the buffer was created associated with one. This is mainly to be used when a shared_ptr is given in the constructor and the output data will reside in a different location from the initialization data.</p>
<p >It is defined as a weak_ptr referring to a shared_ptr that is not associated with the <a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a>, and so the <a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a> will have no ownership of finalData. </p>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00498">498</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  498</span>                                                   {</div>
<div class="line"><span class="lineno">  499</span>    implementation-&gt;implementation-&gt;set_final_data(std::move(finalData));</div>
<div class="line"><span class="lineno">  500</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a543940ea05f65b229970c0ded5eb1c22" name="a543940ea05f65b229970c0ded5eb1c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543940ea05f65b229970c0ded5eb1c22">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buffers that are shared/referenced. </p>
<p >For example </p><div class="fragment"><div class="line"><a class="code hl_class" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer&lt;int&gt;</a> <a class="code hl_variable" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a> { 1000 };</div>
<div class="line"><span class="comment">// Here b.use_count() should return 1</span></div>
<div class="line"><a class="code hl_class" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer&lt;int&gt;</a> <a class="code hl_variable" href="opencl__spir_8h.html#a3b302851bd36c93d2ea8c990ddddb91a">c</a> { <a class="code hl_variable" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a> };</div>
<div class="line"><span class="comment">// Here b.use_count() and b.use_count() should return 2</span></div>
<div class="ttc" id="agroup__data_html_classtrisycl_1_1buffer"><div class="ttname"><a href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a></div><div class="ttdoc">A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...</div><div class="ttdef"><b>Definition:</b> <a href="buffer_8hpp_source.html#l00063">buffer.hpp:69</a></div></div>
<div class="ttc" id="aopencl__spir_8h_html_a3b302851bd36c93d2ea8c990ddddb91a"><div class="ttname"><a href="opencl__spir_8h.html#a3b302851bd36c93d2ea8c990ddddb91a">c</a></div><div class="ttdeci">float const_func float float c</div><div class="ttdef"><b>Definition:</b> <a href="opencl__spir_8h_source.html#l00915">opencl_spir.h:915</a></div></div>
<div class="ttc" id="aopencl__spir_8h_html_a3fd8c63fddfb0d3ba796ef725a8cc5ce"><div class="ttname"><a href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a></div><div class="ttdeci">float const_func float b</div><div class="ttdef"><b>Definition:</b> <a href="opencl__spir_8h_source.html#l00915">opencl_spir.h:915</a></div></div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000136">Todo:</a></b></dt><dd>Add to the specification, useful for validation </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00465">465</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  465</span>                         {</div>
<div class="line"><span class="lineno">  466</span>    <span class="comment">// Rely on the shared_ptr&lt;&gt; use_count()</span></div>
<div class="line"><span class="lineno">  467</span>    <span class="keywordflow">return</span> implementation.use_count();</div>
<div class="line"><span class="lineno">  468</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="adb7157de5cc9ba52801fdbf786855528" name="adb7157de5cc9ba52801fdbf786855528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7157de5cc9ba52801fdbf786855528">&#9670;&nbsp;</a></span>implementation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> <a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a>&lt; T, Dimensions, Allocator &gt;::implementation_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_8hpp_source.html#l00090">90</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1detail_1_1accessor" id="classtrisycl_1_1detail_1_1accessor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1detail_1_1accessor">&#9670;&nbsp;</a></span>trisycl::detail::accessor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::detail::accessor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt;<br />
class trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;</div><p >The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional variable length array way. </p>
<p >This implementation relies on std::mdspan to provide this nice syntax and behavior.</p>
<p >Right now the aim of this class is just to access to the buffer in a read-write mode, even if capturing the accessor from a lambda make it const (since in examples we have lambda with [=] without mutable lambda).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000138">Todo:</a></b></dt><dd>Use the <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c" title="This describes the type of the access mode to be used via accessor.">access::mode</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00055">55</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1accessor__inherit__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01Target_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01Target_01_4_inherit__map" id="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01Target_01_4_inherit__map">
<area shape="rect" title="The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional ..." alt="" coords="504,89,665,145"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base" title="The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer..." alt="" coords="237,5,429,32"/>
<area shape="rect" href="group__execution.html" title=" " alt="" coords="211,57,456,98"/>
<area shape="rect" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor" title="SYCL accessor mixin providing multi&#45;dimensional access features." alt="" coords="5,57,163,98"/>
<area shape="rect" title=" " alt="" coords="253,122,414,193"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="240,217,427,273"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1accessor__coll__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01Target_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01Target_01_4_coll__map" id="atrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01Target_01_4_coll__map">
<area shape="rect" title="The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional ..." alt="" coords="841,239,1003,295"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base" title="The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer..." alt="" coords="528,71,720,98"/>
<area shape="rect" title=" " alt="" coords="276,5,407,47"/>
<area shape="rect" title=" " alt="" coords="313,71,370,98"/>
<area shape="rect" href="group__execution.html" title=" " alt="" coords="501,123,747,164"/>
<area shape="rect" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor" title="SYCL accessor mixin providing multi&#45;dimensional access features." alt="" coords="263,123,420,164"/>
<area shape="rect" title=" " alt="" coords="5,115,168,171"/>
<area shape="rect" title=" " alt="" coords="543,188,705,259"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="531,283,717,339"/>
<area shape="rect" title=" " alt="" coords="559,363,689,419"/>
<area shape="rect" href="classfriend.html" title=" " alt="" coords="597,443,651,470"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a21380463aebdb51ae93dd80e37669bfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a21380463aebdb51ae93dd80e37669bfa">accessor</a> ()=default</td></tr>
<tr class="memdesc:a21380463aebdb51ae93dd80e37669bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the local accessor hack on top of host accessor.  <a href="group__data.html#a21380463aebdb51ae93dd80e37669bfa">More...</a><br /></td></tr>
<tr class="separator:a21380463aebdb51ae93dd80e37669bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4881bcc1d0dc6fcdd30ebafc37ceada"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab4881bcc1d0dc6fcdd30ebafc37ceada">accessor</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt; target_buffer)</td></tr>
<tr class="memdesc:ab4881bcc1d0dc6fcdd30ebafc37ceada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a host accessor from an existing buffer.  <a href="group__data.html#ab4881bcc1d0dc6fcdd30ebafc37ceada">More...</a><br /></td></tr>
<tr class="separator:ab4881bcc1d0dc6fcdd30ebafc37ceada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0ea8db6d7a56a5226b59c7127e6d1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9a0ea8db6d7a56a5226b59c7127e6d1d">accessor</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt; target_buffer, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;command_group_handler)</td></tr>
<tr class="memdesc:a9a0ea8db6d7a56a5226b59c7127e6d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a device accessor from an existing buffer.  <a href="group__data.html#a9a0ea8db6d7a56a5226b59c7127e6d1d">More...</a><br /></td></tr>
<tr class="separator:a9a0ea8db6d7a56a5226b59c7127e6d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc187ff81ce7b877785d2fd9116e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9acc187ff81ce7b877785d2fd9116e52">register_accessor</a> ()</td></tr>
<tr class="memdesc:a9acc187ff81ce7b877785d2fd9116e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the accessor once a <code>std::shared_ptr</code> is created on it.  <a href="group__data.html#a9acc187ff81ce7b877785d2fd9116e52">More...</a><br /></td></tr>
<tr class="separator:a9acc187ff81ce7b877785d2fd9116e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e87e3b06183000b805e1d60808cfca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a46e87e3b06183000b805e1d60808cfca">get_buffer</a> ()</td></tr>
<tr class="memdesc:a46e87e3b06183000b805e1d60808cfca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer used to create the accessor.  <a href="group__data.html#a46e87e3b06183000b805e1d60808cfca">More...</a><br /></td></tr>
<tr class="separator:a46e87e3b06183000b805e1d60808cfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48edd495ed98735815a64a4ebfb2942e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a48edd495ed98735815a64a4ebfb2942e">is_read_access</a> () const</td></tr>
<tr class="memdesc:a48edd495ed98735815a64a4ebfb2942e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the accessor has a read access right.  <a href="group__data.html#a48edd495ed98735815a64a4ebfb2942e">More...</a><br /></td></tr>
<tr class="separator:a48edd495ed98735815a64a4ebfb2942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93b6f20bc4c61705ae616c02b5ad8ed"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">is_write_access</a> () const</td></tr>
<tr class="memdesc:ae93b6f20bc4c61705ae616c02b5ad8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the accessor has a write access right.  <a href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">More...</a><br /></td></tr>
<tr class="separator:ae93b6f20bc4c61705ae616c02b5ad8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__data"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__data')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">trisycl::detail::accessor_base</a></td></tr>
<tr class="memitem:a0f17346e18ae668ecb8175ff3b2ccb76 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">set_order</a> (std::size_t o)</td></tr>
<tr class="memdesc:a0f17346e18ae668ecb8175ff3b2ccb76 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the order of the accessor.  <a href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">More...</a><br /></td></tr>
<tr class="separator:a0f17346e18ae668ecb8175ff3b2ccb76 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5efdf051df9db11cfc7d4be3d7673f0 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#af5efdf051df9db11cfc7d4be3d7673f0">get_order</a> ()</td></tr>
<tr class="memdesc:af5efdf051df9db11cfc7d4be3d7673f0 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the order of the accessor.  <a href="group__data.html#af5efdf051df9db11cfc7d4be3d7673f0">More...</a><br /></td></tr>
<tr class="separator:af5efdf051df9db11cfc7d4be3d7673f0 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980d5757946fa394716ea51b6a1bc9d7 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">virtual boost::compute::buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">get_cl_buffer</a> () const =0</td></tr>
<tr class="memdesc:a980d5757946fa394716ea51b6a1bc9d7 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boost::compute::buffer or throw if unset.  <a href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">More...</a><br /></td></tr>
<tr class="separator:a980d5757946fa394716ea51b6a1bc9d7 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72bda8f733bd016a15f3d7ad3112e28 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#af72bda8f733bd016a15f3d7ad3112e28">~accessor_base</a> ()</td></tr>
<tr class="separator:af72bda8f733bd016a15f3d7ad3112e28 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__execution.html">trisycl::facade::accessor&lt; mixin::accessor&lt; T, Dimensions &gt; &gt;</a></td></tr>
<tr class="memitem:a6eef273a240060cb62a4a80c51b35eb9 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6eef273a240060cb62a4a80c51b35eb9">operator[]</a> (T... indices)</td></tr>
<tr class="memdesc:a6eef273a240060cb62a4a80c51b35eb9 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...].  <a href="group__execution.html#a6eef273a240060cb62a4a80c51b35eb9">More...</a><br /></td></tr>
<tr class="separator:a6eef273a240060cb62a4a80c51b35eb9 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc322d386c9d5a3bbc0b89ab12213f77 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#adc322d386c9d5a3bbc0b89ab12213f77">operator[]</a> (T... indices) const</td></tr>
<tr class="memdesc:adc322d386c9d5a3bbc0b89ab12213f77 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the accessor with integers à la [i1][i2][i3] or C++23 [i1, i2,...].  <a href="group__execution.html#adc322d386c9d5a3bbc0b89ab12213f77">More...</a><br /></td></tr>
<tr class="separator:adc322d386c9d5a3bbc0b89ab12213f77 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3f661bde509189c29f05660c1d1708 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a5d3f661bde509189c29f05660c1d1708">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; mixin::rank()&gt; &amp;index)</td></tr>
<tr class="memdesc:a5d3f661bde509189c29f05660c1d1708 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the accessor with [id&lt;&gt;].  <a href="group__execution.html#a5d3f661bde509189c29f05660c1d1708">More...</a><br /></td></tr>
<tr class="separator:a5d3f661bde509189c29f05660c1d1708 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61bbf4173c57c5a8ae49ffe81cde40d inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af61bbf4173c57c5a8ae49ffe81cde40d">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; mixin::rank()&gt; &amp;index) const</td></tr>
<tr class="memdesc:af61bbf4173c57c5a8ae49ffe81cde40d inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use the accessor with [id&lt;&gt;].  <a href="group__execution.html#af61bbf4173c57c5a8ae49ffe81cde40d">More...</a><br /></td></tr>
<tr class="separator:af61bbf4173c57c5a8ae49ffe81cde40d inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04d40ff5615efd2d3682ebda7863c2b inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af04d40ff5615efd2d3682ebda7863c2b">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; mixin::rank()&gt; &amp;index)</td></tr>
<tr class="memdesc:af04d40ff5615efd2d3682ebda7863c2b inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with [item&lt;&gt;].  <a href="group__execution.html#af04d40ff5615efd2d3682ebda7863c2b">More...</a><br /></td></tr>
<tr class="separator:af04d40ff5615efd2d3682ebda7863c2b inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b08cda0ba2d9f6b937855a083225df2 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a5b08cda0ba2d9f6b937855a083225df2">operator[]</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; mixin::rank()&gt; &amp;index) const</td></tr>
<tr class="memdesc:a5b08cda0ba2d9f6b937855a083225df2 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with [item&lt;&gt;].  <a href="group__execution.html#a5b08cda0ba2d9f6b937855a083225df2">More...</a><br /></td></tr>
<tr class="separator:a5b08cda0ba2d9f6b937855a083225df2 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09adf470b84dc7e295b9a821c828634e inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a09adf470b84dc7e295b9a821c828634e">operator[]</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; mixin::rank()&gt; &amp;index)</td></tr>
<tr class="memdesc:a09adf470b84dc7e295b9a821c828634e inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with an [nd_item&lt;&gt;].  <a href="group__execution.html#a09adf470b84dc7e295b9a821c828634e">More...</a><br /></td></tr>
<tr class="separator:a09adf470b84dc7e295b9a821c828634e inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9613839bd22a392c4ca84f598889424c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a9613839bd22a392c4ca84f598889424c">operator[]</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1nd__item">nd_item</a>&lt; mixin::rank()&gt; &amp;index) const</td></tr>
<tr class="memdesc:a9613839bd22a392c4ca84f598889424c inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">To use an accessor with an [nd_item&lt;&gt;].  <a href="group__execution.html#a9613839bd22a392c4ca84f598889424c">More...</a><br /></td></tr>
<tr class="separator:a9613839bd22a392c4ca84f598889424c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb116683e03d6fa44cee3f2901465244 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">mixin::reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#afb116683e03d6fa44cee3f2901465244">operator*</a> ()</td></tr>
<tr class="memdesc:afb116683e03d6fa44cee3f2901465244 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of the accessor.  <a href="group__execution.html#afb116683e03d6fa44cee3f2901465244">More...</a><br /></td></tr>
<tr class="separator:afb116683e03d6fa44cee3f2901465244 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb77f9ba773cf177f4464e51deeffa3 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">mixin::reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aabb77f9ba773cf177f4464e51deeffa3">operator*</a> () const</td></tr>
<tr class="memdesc:aabb77f9ba773cf177f4464e51deeffa3 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first element of the accessor.  <a href="group__execution.html#aabb77f9ba773cf177f4464e51deeffa3">More...</a><br /></td></tr>
<tr class="separator:aabb77f9ba773cf177f4464e51deeffa3 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402ca1b3328d01fea7fa8953d303a208 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a402ca1b3328d01fea7fa8953d303a208">get_pointer</a> ()</td></tr>
<tr class="memdesc:a402ca1b3328d01fea7fa8953d303a208 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer to the data.  <a href="group__execution.html#a402ca1b3328d01fea7fa8953d303a208">More...</a><br /></td></tr>
<tr class="separator:a402ca1b3328d01fea7fa8953d303a208 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe2f0ac3385cfe2c5127490a0b868db inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a0fe2f0ac3385cfe2c5127490a0b868db">begin</a> ()</td></tr>
<tr class="memdesc:a0fe2f0ac3385cfe2c5127490a0b868db inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward all the iterator functions to the implementation.  <a href="group__execution.html#a0fe2f0ac3385cfe2c5127490a0b868db">More...</a><br /></td></tr>
<tr class="separator:a0fe2f0ac3385cfe2c5127490a0b868db inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1e639022a7e80f5934dedefd860b82 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a7e1e639022a7e80f5934dedefd860b82">end</a> ()</td></tr>
<tr class="separator:a7e1e639022a7e80f5934dedefd860b82 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d19d8277ca63b730cad67d7e17d5b6c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a4d19d8277ca63b730cad67d7e17d5b6c">cbegin</a> ()</td></tr>
<tr class="separator:a4d19d8277ca63b730cad67d7e17d5b6c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb172a662af09174e2686c4412be40f2 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aeb172a662af09174e2686c4412be40f2">cend</a> ()</td></tr>
<tr class="separator:aeb172a662af09174e2686c4412be40f2 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b54e3307c9ed22506e90ca8d89f26f inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a2187a41b81c402735f83bd7aed70c136">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ae2b54e3307c9ed22506e90ca8d89f26f">rbegin</a> ()</td></tr>
<tr class="separator:ae2b54e3307c9ed22506e90ca8d89f26f inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581bd7d35303570b9b708f0ac29b9c22 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a2187a41b81c402735f83bd7aed70c136">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a581bd7d35303570b9b708f0ac29b9c22">rend</a> ()</td></tr>
<tr class="separator:a581bd7d35303570b9b708f0ac29b9c22 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a188afc42b14b542fce66bc076b73ff inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae46a2abe59ad97ea115f7c6f125e5f80">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a1a188afc42b14b542fce66bc076b73ff">crbegin</a> () const</td></tr>
<tr class="separator:a1a188afc42b14b542fce66bc076b73ff inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d2c16439fcb44fd0cad68097cb1177 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#ae46a2abe59ad97ea115f7c6f125e5f80">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a78d2c16439fcb44fd0cad68097cb1177">crend</a> () const</td></tr>
<tr class="separator:a78d2c16439fcb44fd0cad68097cb1177 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aa952a1cd3084acfd5848c96e1307b722">accessor</a> ()=default</td></tr>
<tr class="memdesc:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the local accessor hack on top of host accessor.  <a href="group__execution.html#aa952a1cd3084acfd5848c96e1307b722">More...</a><br /></td></tr>
<tr class="separator:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a4bee5e8e1a4cc07794c8603ceb05449c">accessor</a> (<a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> <a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;r)</td></tr>
<tr class="memdesc:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor of dimensions r on top of data storage.  <a href="group__execution.html#a4bee5e8e1a4cc07794c8603ceb05449c">More...</a><br /></td></tr>
<tr class="separator:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#addcb16193eee7d27f95ad2562a3647c1">accessor</a> (const <a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> &amp;m)</td></tr>
<tr class="memdesc:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor from another mdspan.  <a href="group__execution.html#addcb16193eee7d27f95ad2562a3647c1">More...</a><br /></td></tr>
<tr class="separator:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">update</a> (<a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> <a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;r)</td></tr>
<tr class="memdesc:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the accessor to target somewhere else.  <a href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">More...</a><br /></td></tr>
<tr class="separator:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">get_range</a> () const</td></tr>
<tr class="memdesc:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor.  <a href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">More...</a><br /></td></tr>
<tr class="separator:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">get_count</a> () const</td></tr>
<tr class="memdesc:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in the buffer.  <a href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">More...</a><br /></td></tr>
<tr class="separator:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">get_size</a> () const</td></tr>
<tr class="memdesc:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the buffer storage in bytes.  <a href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">More...</a><br /></td></tr>
<tr class="separator:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a> ()</td></tr>
<tr class="memdesc:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying storage.  <a href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">More...</a><br /></td></tr>
<tr class="separator:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6e1886294408463407c1beccd8ca683d">tuple_indexed_access</a> (const auto &amp;tuple_like_indices)</td></tr>
<tr class="memdesc:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element with indices implementing a tuple interface.  <a href="group__execution.html#a6e1886294408463407c1beccd8ca683d">More...</a><br /></td></tr>
<tr class="separator:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Member Functions</h3></td></tr>
<tr class="memitem:a4c51168df9f102bc21423a5c01285450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a4c51168df9f102bc21423a5c01285450">set_buffer</a> (std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>)</td></tr>
<tr class="memdesc:a4c51168df9f102bc21423a5c01285450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set later the current buffer associated to this accessor.  <a href="group__data.html#a4c51168df9f102bc21423a5c01285450">More...</a><br /></td></tr>
<tr class="separator:a4c51168df9f102bc21423a5c01285450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memTemplParams" colspan="2">template&lt;typename BasicType , typename FinalType &gt; </td></tr>
<tr class="memitem:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memTemplItemLeft" align="right" valign="top">const std::array&lt; typename mdspan::size_type, <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__execution.html#a255326fb325821d440d826dabda8f043">extents_cast</a> (const <a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">detail::small_array</a>&lt; BasicType, FinalType, <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;sa)</td></tr>
<tr class="memdesc:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a SYCL range/id-like into a mdspan index array, which is an array of std::size_t into an array of std::ptrdiff_t.  <a href="group__execution.html#a255326fb325821d440d826dabda8f043">More...</a><br /></td></tr>
<tr class="separator:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">set_access</a> (const <a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> &amp;<a class="el" href="opencl__spir_8h.html#afce50bc7a23ec77afc73ea78f6f569e9">a</a>)</td></tr>
<tr class="memdesc:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set later the mdspan associated to this accessor.  <a href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">More...</a><br /></td></tr>
<tr class="separator:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a462caca7b6559867db2efd6b57456d88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a462caca7b6559867db2efd6b57456d88">facade</a> = <a class="el" href="group__execution.html#classtrisycl_1_1facade_1_1accessor">facade::accessor</a>&lt; <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">mixin::accessor</a>&lt; T, Dimensions &gt; &gt;</td></tr>
<tr class="memdesc:a462caca7b6559867db2efd6b57456d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where most of the user-facing interface dwells.  <a href="group__data.html#a462caca7b6559867db2efd6b57456d88">More...</a><br /></td></tr>
<tr class="separator:a462caca7b6559867db2efd6b57456d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Member Functions</h3></td></tr>
<tr class="memitem:a21266c6ebba45da03ee63e0342f8e7fc"><td class="memItemLeft" align="right" valign="top">boost::compute::buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a21266c6ebba45da03ee63e0342f8e7fc">get_cl_buffer</a> () const override</td></tr>
<tr class="memdesc:a21266c6ebba45da03ee63e0342f8e7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the boost::compute::buffer or throw if unset.  <a href="group__data.html#a21266c6ebba45da03ee63e0342f8e7fc">More...</a><br /></td></tr>
<tr class="separator:a21266c6ebba45da03ee63e0342f8e7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3394999b292edcaf3ffbab2d9355af95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a3394999b292edcaf3ffbab2d9355af95">copy_in_cl_buffer</a> ()</td></tr>
<tr class="memdesc:a3394999b292edcaf3ffbab2d9355af95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazily associate a CL buffer to the SYCL buffer and copy data in it if required, updates the state of the data in the buffer across contexts.  <a href="group__data.html#a3394999b292edcaf3ffbab2d9355af95">More...</a><br /></td></tr>
<tr class="separator:a3394999b292edcaf3ffbab2d9355af95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463851ea089a6686ef4042330fe33417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a463851ea089a6686ef4042330fe33417">copy_back_cl_buffer</a> ()</td></tr>
<tr class="memdesc:a463851ea089a6686ef4042330fe33417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing.  <a href="group__data.html#a463851ea089a6686ef4042330fe33417">More...</a><br /></td></tr>
<tr class="separator:a463851ea089a6686ef4042330fe33417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a5105567d37733e197cbefbc49cbb2067"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a></td></tr>
<tr class="memdesc:a5105567d37733e197cbefbc49cbb2067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep a reference to the accessed buffer.  <a href="group__data.html#a5105567d37733e197cbefbc49cbb2067">More...</a><br /></td></tr>
<tr class="separator:a5105567d37733e197cbefbc49cbb2067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c10b45aecd62eb5abc44b4e53b34edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfriend.html">friend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a8c10b45aecd62eb5abc44b4e53b34edb">handler</a></td></tr>
<tr class="separator:a8c10b45aecd62eb5abc44b4e53b34edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__execution.html">trisycl::facade::accessor&lt; mixin::accessor&lt; T, Dimensions &gt; &gt;</a></td></tr>
<tr class="memitem:ae117ebf0aa308a78a9eecf8df1f37510 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a> = typename <a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">mixin::pointer</a></td></tr>
<tr class="separator:ae117ebf0aa308a78a9eecf8df1f37510 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1fc9f365afffa58e2ebcf6d5ecb325 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a> = typename <a class="el" href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">mixin::const_pointer</a></td></tr>
<tr class="separator:a1a1fc9f365afffa58e2ebcf6d5ecb325 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2187a41b81c402735f83bd7aed70c136 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2187a41b81c402735f83bd7aed70c136">reverse_iterator</a> = typename std::reverse_iterator&lt; <a class="el" href="group__execution.html#ae117ebf0aa308a78a9eecf8df1f37510">iterator</a> &gt;</td></tr>
<tr class="separator:a2187a41b81c402735f83bd7aed70c136 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46a2abe59ad97ea115f7c6f125e5f80 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ae46a2abe59ad97ea115f7c6f125e5f80">const_reverse_iterator</a> = typename std::reverse_iterator&lt; <a class="el" href="group__execution.html#a1a1fc9f365afffa58e2ebcf6d5ecb325">const_iterator</a> &gt;</td></tr>
<tr class="separator:ae46a2abe59ad97ea115f7c6f125e5f80 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> = T</td></tr>
<tr class="memdesc:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to SYCL: provide pieces of STL container interface from mdspan.  <a href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">More...</a><br /></td></tr>
<tr class="separator:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">value_type</a> = std::remove_cv_t&lt; <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> &gt;</td></tr>
<tr class="memdesc:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Even if the buffer is read-only use a non-const type so at least the current implementation can copy the data too.  <a href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">More...</a><br /></td></tr>
<tr class="separator:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e2a9cdf64e350ee9993ad05f43d12 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aad9e2a9cdf64e350ee9993ad05f43d12">non_const_pointer</a> = <a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">value_type</a> *</td></tr>
<tr class="separator:aad9e2a9cdf64e350ee9993ad05f43d12 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> = typename mdspan::accessor_type::data_handle_type</td></tr>
<tr class="memdesc:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to element.  <a href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">More...</a><br /></td></tr>
<tr class="separator:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">const_pointer</a> = const <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> *</td></tr>
<tr class="memdesc:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to const element.  <a href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">More...</a><br /></td></tr>
<tr class="separator:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">reference</a> = typename mdspan::reference</td></tr>
<tr class="memdesc:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type to the elements.  <a href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">More...</a><br /></td></tr>
<tr class="separator:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a> ()</td></tr>
<tr class="memdesc:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions of the buffer.  <a href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">More...</a><br /></td></tr>
<tr class="separator:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="memItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#abd5445bd551db33605ec8fa2709a10e8">tuple_indexed_mdspan_access</a> (auto &amp;&amp;some_mdspan, const auto &amp;tuple_like_indices)</td></tr>
<tr class="memdesc:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an mdspan element with indices implementing a tuple interface.  <a href="group__execution.html#abd5445bd551db33605ec8fa2709a10e8">More...</a><br /></td></tr>
<tr class="separator:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__debug__trace"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__debug__trace')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__debug__trace.html">trisycl::detail::debug&lt; accessor&lt; T, Dimensions, Mode, Target &gt; &gt;</a></td></tr>
<tr class="memitem:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">type_pretty_name</a> ()</td></tr>
<tr class="memdesc:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pretty name of T itself.  <a href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">More...</a><br /></td></tr>
<tr class="separator:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> = std::mdspan&lt; <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a>, std::dextents&lt; std::size_t, Dimensions &gt; &gt;</td></tr>
<tr class="memdesc:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory lay-out of a buffer is a dynamic multidimensional array.  <a href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">More...</a><br /></td></tr>
<tr class="separator:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group__data"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group__data')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">trisycl::detail::accessor_base</a></td></tr>
<tr class="memitem:ae542f16a71fdeb8797e59d711b7ed124 inherit pro_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a></td></tr>
<tr class="memdesc:ae542f16a71fdeb8797e59d711b7ed124 inherit pro_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task where the accessor is used in.  <a href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">More...</a><br /></td></tr>
<tr class="separator:ae542f16a71fdeb8797e59d711b7ed124 inherit pro_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b32ac13bfd168d1318d7b5e84b8370 inherit pro_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">order</a></td></tr>
<tr class="memdesc:a75b32ac13bfd168d1318d7b5e84b8370 inherit pro_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">The declaration order of the accessor.  <a href="group__data.html#a75b32ac13bfd168d1318d7b5e84b8370">More...</a><br /></td></tr>
<tr class="separator:a75b32ac13bfd168d1318d7b5e84b8370 inherit pro_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">trisycl::mixin::accessor&lt; T, Dimensions &gt;</a></td></tr>
<tr class="memitem:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">access</a></td></tr>
<tr class="memdesc:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the multi-dimensional interface to the data that may point to either allocation in the case of storage managed by SYCL itself or to some other memory location in the case of host memory or storage&lt;&gt; abstraction use.  <a href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">More...</a><br /></td></tr>
<tr class="separator:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a462caca7b6559867db2efd6b57456d88" name="a462caca7b6559867db2efd6b57456d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462caca7b6559867db2efd6b57456d88">&#9670;&nbsp;</a></span>facade</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::facade =  <a class="el" href="group__execution.html#classtrisycl_1_1facade_1_1accessor">facade::accessor</a>&lt;<a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">mixin::accessor</a>&lt;T, Dimensions&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Where most of the user-facing interface dwells. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00069">69</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a21380463aebdb51ae93dd80e37669bfa" name="a21380463aebdb51ae93dd80e37669bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21380463aebdb51ae93dd80e37669bfa">&#9670;&nbsp;</a></span>accessor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by the local accessor hack on top of host accessor. </p>

</div>
</div>
<a id="ab4881bcc1d0dc6fcdd30ebafc37ceada" name="ab4881bcc1d0dc6fcdd30ebafc37ceada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4881bcc1d0dc6fcdd30ebafc37ceada">&#9670;&nbsp;</a></span>accessor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt;&#160;</td>
          <td class="paramname"><em>target_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a host accessor from an existing buffer. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000139">Todo:</a></b></dt><dd>fix the specification to rename target that shadows template parm </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00091">91</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   92</span>      : <a class="code hl_typedef" href="group__data.html#a462caca7b6559867db2efd6b57456d88">facade</a> { target_buffer-&gt;<a class="code hl_variable" href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">access</a> }</div>
<div class="line"><span class="lineno">   93</span>      , <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a> { target_buffer } {</div>
<div class="line"><span class="lineno">   94</span>    target_buffer-&gt;template track_access_mode&lt;Mode&gt;();</div>
<div class="line"><span class="lineno">   95</span>    <a class="code hl_define" href="triSYCL_2detail_2debug_8hpp.html#a7d15187cc29c2a3ec4ad62acccaa242e">TRISYCL_DUMP_T</a>(<span class="stringliteral">&quot;Create a host accessor write = &quot;</span> &lt;&lt; <a class="code hl_function" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">is_write_access</a>());</div>
<div class="line"><span class="lineno">   96</span>    <span class="keyword">static_assert</span>(Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">access::target::host_buffer</a>,</div>
<div class="line"><span class="lineno">   97</span>                  <span class="stringliteral">&quot;without a handler, access target should be host_buffer&quot;</span>);</div>
<div class="line"><span class="lineno">   98</span>    <span class="comment">/* The host needs to wait for all the producers of the buffer to</span></div>
<div class="line"><span class="lineno">   99</span><span class="comment">       have finished */</span></div>
<div class="line"><span class="lineno">  100</span>    <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a>-&gt;wait();</div>
<div class="line"><span class="lineno">  101</span> </div>
<div class="line"><span class="lineno">  102</span><span class="preprocessor">#ifdef TRISYCL_OPENCL</span></div>
<div class="line"><span class="lineno">  103</span>    <span class="comment">/* For the host context, we are obligated to update the buffer state</span></div>
<div class="line"><span class="lineno">  104</span><span class="comment">       during the accessors creation, otherwise we have no way of knowing</span></div>
<div class="line"><span class="lineno">  105</span><span class="comment">       if a buffer was modified on the host. This is only true because</span></div>
<div class="line"><span class="lineno">  106</span><span class="comment">       host accessors are blocking</span></div>
<div class="line"><span class="lineno">  107</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  108</span>    <a class="code hl_class" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> ctx;</div>
<div class="line"><span class="lineno">  109</span>    <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a>-&gt;update_buffer_state(ctx, Mode, <a class="code hl_function" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">facade::get_size</a>(), <a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">facade::data</a>());</div>
<div class="line"><span class="lineno">  110</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  111</span>  }</div>
<div class="ttc" id="agroup__data_html_a462caca7b6559867db2efd6b57456d88"><div class="ttname"><a href="group__data.html#a462caca7b6559867db2efd6b57456d88">trisycl::detail::accessor::facade</a></div><div class="ttdeci">facade::accessor&lt; mixin::accessor&lt; T, Dimensions &gt; &gt; facade</div><div class="ttdoc">Where most of the user-facing interface dwells.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00069">accessor.hpp:69</a></div></div>
<div class="ttc" id="agroup__data_html_a5105567d37733e197cbefbc49cbb2067"><div class="ttname"><a href="group__data.html#a5105567d37733e197cbefbc49cbb2067">trisycl::detail::accessor::buf</a></div><div class="ttdeci">std::shared_ptr&lt; detail::buffer&lt; T, Dimensions &gt; &gt; buf</div><div class="ttdoc">Keep a reference to the accessed buffer.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">accessor.hpp:66</a></div></div>
<div class="ttc" id="agroup__data_html_ae93b6f20bc4c61705ae616c02b5ad8ed"><div class="ttname"><a href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">trisycl::detail::accessor::is_write_access</a></div><div class="ttdeci">constexpr bool is_write_access() const</div><div class="ttdoc">Test if the accessor has a write access right.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00187">accessor.hpp:187</a></div></div>
<div class="ttc" id="agroup__execution_html_a2148e7f785dcd09aa05272a378c31817"><div class="ttname"><a href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">trisycl::mixin::accessor::data</a></div><div class="ttdeci">auto data()</div><div class="ttdoc">Get the underlying storage.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00133">accessor.hpp:133</a></div></div>
<div class="ttc" id="agroup__execution_html_a9466bab0b0a9d8ebb6ac731a45f7d7c9"><div class="ttname"><a href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">trisycl::mixin::accessor::get_size</a></div><div class="ttdeci">std::size_t get_size() const</div><div class="ttdoc">Returns the size of the buffer storage in bytes.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00130">accessor.hpp:130</a></div></div>
<div class="ttc" id="agroup__execution_html_adc74a5ffc79e1d0c93ab5ef1c492a17f"><div class="ttname"><a href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">trisycl::mixin::accessor::access</a></div><div class="ttdeci">mdspan access</div><div class="ttdoc">This is the multi-dimensional interface to the data that may point to either allocation in the case o...</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00055">accessor.hpp:55</a></div></div>
<div class="ttc" id="agroup__execution_html_classtrisycl_1_1context"><div class="ttname"><a href="group__execution.html#classtrisycl_1_1context">trisycl::context</a></div><div class="ttdoc">SYCL context.</div><div class="ttdef"><b>Definition:</b> <a href="context_8hpp_source.html#l00046">context.hpp:50</a></div></div>
<div class="ttc" id="atriSYCL_2detail_2debug_8hpp_html_a7d15187cc29c2a3ec4ad62acccaa242e"><div class="ttname"><a href="triSYCL_2detail_2debug_8hpp.html#a7d15187cc29c2a3ec4ad62acccaa242e">TRISYCL_DUMP_T</a></div><div class="ttdeci">#define TRISYCL_DUMP_T(expression)</div><div class="ttdoc">Same as TRISYCL_DUMP() but with thread id first.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2detail_2debug_8hpp_source.html#l00047">debug.hpp:47</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::buf</a>, <a class="el" href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00133">trisycl::mixin::accessor&lt; T, Dimensions &gt;::data()</a>, <a class="el" href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00130">trisycl::mixin::accessor&lt; T, Dimensions &gt;::get_size()</a>, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716faa0599d72026e3c6df4a0488cdf4e18d7">trisycl::access::host_buffer</a>, <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00187">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::is_write_access()</a>, and <a class="el" href="triSYCL_2detail_2debug_8hpp_source.html#l00047">TRISYCL_DUMP_T</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ab4881bcc1d0dc6fcdd30ebafc37ceada_cgraph.png" border="0" usemap="#agroup__data_ab4881bcc1d0dc6fcdd30ebafc37ceada_cgraph" alt=""/></div>
<map name="agroup__data_ab4881bcc1d0dc6fcdd30ebafc37ceada_cgraph" id="agroup__data_ab4881bcc1d0dc6fcdd30ebafc37ceada_cgraph">
<area shape="rect" title="Construct a host accessor from an existing buffer." alt="" coords="5,71,163,112"/>
<area shape="rect" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817" title="Get the underlying storage." alt="" coords="211,5,368,47"/>
<area shape="rect" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9" title="Returns the size of the buffer storage in bytes." alt="" coords="211,71,368,112"/>
<area shape="rect" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed" title="Test if the accessor has a write access right." alt="" coords="211,136,368,177"/>
<area shape="rect" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4" title="Returns the total number of elements in the buffer." alt="" coords="416,71,573,112"/>
</map>
</div>

</div>
</div>
<a id="a9a0ea8db6d7a56a5226b59c7127e6d1d" name="a9a0ea8db6d7a56a5226b59c7127e6d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0ea8db6d7a56a5226b59c7127e6d1d">&#9670;&nbsp;</a></span>accessor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::accessor </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt;&#160;</td>
          <td class="paramname"><em>target_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> &amp;&#160;</td>
          <td class="paramname"><em>command_group_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a device accessor from an existing buffer. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000140">Todo:</a></b></dt><dd>fix the specification to rename target that shadows template parm </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00118">118</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  120</span>      : <a class="code hl_typedef" href="group__data.html#a462caca7b6559867db2efd6b57456d88">facade</a> { target_buffer-&gt;<a class="code hl_variable" href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">access</a> }</div>
<div class="line"><span class="lineno">  121</span>      , <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a> { target_buffer } {</div>
<div class="line"><span class="lineno">  122</span>    target_buffer-&gt;template track_access_mode&lt;Mode&gt;();</div>
<div class="line"><span class="lineno">  123</span>    <a class="code hl_define" href="triSYCL_2detail_2debug_8hpp.html#a7d15187cc29c2a3ec4ad62acccaa242e">TRISYCL_DUMP_T</a>(<span class="stringliteral">&quot;Create a kernel accessor write = &quot;</span> &lt;&lt; <a class="code hl_function" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">is_write_access</a>());</div>
<div class="line"><span class="lineno">  124</span>    <span class="keyword">static_assert</span>(Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b">access::target::global_buffer</a> ||</div>
<div class="line"><span class="lineno">  125</span>                      Target == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b">access::target::constant_buffer</a>,</div>
<div class="line"><span class="lineno">  126</span>                  <span class="stringliteral">&quot;access target should be global_buffer or constant_buffer &quot;</span></div>
<div class="line"><span class="lineno">  127</span>                  <span class="stringliteral">&quot;when a handler is used&quot;</span>);</div>
<div class="line"><span class="lineno">  128</span>    <span class="comment">// Register the buffer to the task dependencies</span></div>
<div class="line"><span class="lineno">  129</span>    <a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a> = <a class="code hl_function" href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7">buffer_add_to_task</a>(<a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a>, &amp;command_group_handler, <a class="code hl_function" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed">is_write_access</a>());</div>
<div class="line"><span class="lineno">  130</span>  }</div>
<div class="ttc" id="agroup__data_html_ae542f16a71fdeb8797e59d711b7ed124"><div class="ttname"><a href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">trisycl::detail::accessor_base::task</a></div><div class="ttdeci">std::shared_ptr&lt; detail::task &gt; task</div><div class="ttdoc">The task where the accessor is used in.</div><div class="ttdef"><b>Definition:</b> <a href="accessor__base_8hpp_source.html#l00042">accessor_base.hpp:42</a></div></div>
<div class="ttc" id="agroup__data_html_gae5b7896e8e1e3224f735bd410e98b7e7"><div class="ttname"><a href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7">trisycl::detail::buffer_add_to_task</a></div><div class="ttdeci">static std::shared_ptr&lt; detail::task &gt; buffer_add_to_task(BufferDetail buf, handler *command_group_handler, bool is_write_mode)</div><div class="ttdoc">Proxy function to avoid some circular type recursion.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00352">buffer.hpp:352</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::buf</a>, <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00352">trisycl::detail::buffer_add_to_task()</a>, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716fade1df516592d6089a5a1d4c9280f257b">trisycl::access::constant_buffer</a>, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716facb1529b5988261a81704f0f39d6c287b">trisycl::access::global_buffer</a>, <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00187">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::is_write_access()</a>, and <a class="el" href="triSYCL_2detail_2debug_8hpp_source.html#l00047">TRISYCL_DUMP_T</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a9a0ea8db6d7a56a5226b59c7127e6d1d_cgraph.png" border="0" usemap="#agroup__data_a9a0ea8db6d7a56a5226b59c7127e6d1d_cgraph" alt=""/></div>
<map name="agroup__data_a9a0ea8db6d7a56a5226b59c7127e6d1d_cgraph" id="agroup__data_a9a0ea8db6d7a56a5226b59c7127e6d1d_cgraph">
<area shape="rect" title="Construct a device accessor from an existing buffer." alt="" coords="5,39,163,80"/>
<area shape="rect" href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7" title="Proxy function to avoid some circular type recursion." alt="" coords="221,5,358,47"/>
<area shape="rect" href="group__data.html#ae93b6f20bc4c61705ae616c02b5ad8ed" title="Test if the accessor has a write access right." alt="" coords="211,71,368,112"/>
</map>
</div>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a463851ea089a6686ef4042330fe33417" name="a463851ea089a6686ef4042330fe33417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463851ea089a6686ef4042330fe33417">&#9670;&nbsp;</a></span>copy_back_cl_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::copy_back_cl_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does nothing. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00217">217</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  217</span>                             {</div>
<div class="line"><span class="lineno">  218</span>    <span class="comment">/* The copy back is handled by the host accessor and the buffer destructor.</span></div>
<div class="line"><span class="lineno">  219</span><span class="comment">       We don&#39;t need to systematically transfer the data after the</span></div>
<div class="line"><span class="lineno">  220</span><span class="comment">       kernel execution</span></div>
<div class="line"><span class="lineno">  221</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="comment">       \todo Figure out what to do with this function</span></div>
<div class="line"><span class="lineno">  223</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  224</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3394999b292edcaf3ffbab2d9355af95" name="a3394999b292edcaf3ffbab2d9355af95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3394999b292edcaf3ffbab2d9355af95">&#9670;&nbsp;</a></span>copy_in_cl_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::copy_in_cl_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lazily associate a CL buffer to the SYCL buffer and copy data in it if required, updates the state of the data in the buffer across contexts. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00208">208</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  208</span>                           {</div>
<div class="line"><span class="lineno">  209</span>    <span class="comment">/* Create the OpenCL buffer and copy in it the data from the host if</span></div>
<div class="line"><span class="lineno">  210</span><span class="comment">       the buffer doesn&#39;t already exists or if the data is not up to date</span></div>
<div class="line"><span class="lineno">  211</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  212</span>    <span class="keyword">auto</span> ctx = <a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a>-&gt;get_queue()-&gt;get_context();</div>
<div class="line"><span class="lineno">  213</span>    <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a>-&gt;update_buffer_state(ctx, Mode, <a class="code hl_function" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">facade::get_size</a>(), <a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">facade::data</a>());</div>
<div class="line"><span class="lineno">  214</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::buf</a>, <a class="el" href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00133">trisycl::mixin::accessor&lt; T, Dimensions &gt;::data()</a>, <a class="el" href="task_8hpp_source.html#l00244">trisycl::detail::task::get_queue()</a>, and <a class="el" href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00130">trisycl::mixin::accessor&lt; T, Dimensions &gt;::get_size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a3394999b292edcaf3ffbab2d9355af95_cgraph.png" border="0" usemap="#agroup__data_a3394999b292edcaf3ffbab2d9355af95_cgraph" alt=""/></div>
<map name="agroup__data_a3394999b292edcaf3ffbab2d9355af95_cgraph" id="agroup__data_a3394999b292edcaf3ffbab2d9355af95_cgraph">
<area shape="rect" title="Lazily associate a CL buffer to the SYCL buffer and copy data in it if required, updates the state of..." alt="" coords="5,71,163,112"/>
<area shape="rect" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817" title="Get the underlying storage." alt="" coords="211,5,368,47"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1task.html#aef85e4bc2c97856581c09a62484b3f91" title="Get the queue behind the task to run a kernel on." alt="" coords="225,71,354,112"/>
<area shape="rect" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9" title="Returns the size of the buffer storage in bytes." alt="" coords="211,136,368,177"/>
<area shape="rect" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4" title="Returns the total number of elements in the buffer." alt="" coords="416,136,573,177"/>
</map>
</div>

</div>
</div>
<a id="a46e87e3b06183000b805e1d60808cfca" name="a46e87e3b06183000b805e1d60808cfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e87e3b06183000b805e1d60808cfca">&#9670;&nbsp;</a></span>get_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &amp; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::get_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the buffer used to create the accessor. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00164">164</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  164</span>{ <span class="keywordflow">return</span> *<a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a>; }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::buf</a>.</p>

</div>
</div>
<a id="a21266c6ebba45da03ee63e0342f8e7fc" name="a21266c6ebba45da03ee63e0342f8e7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21266c6ebba45da03ee63e0342f8e7fc">&#9670;&nbsp;</a></span>get_cl_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::buffer <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::get_cl_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the boost::compute::buffer or throw if unset. </p>

<p>Implements <a class="el" href="group__data.html#a980d5757946fa394716ea51b6a1bc9d7">trisycl::detail::accessor_base</a>.</p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00199">199</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  199</span>                                                    {</div>
<div class="line"><span class="lineno">  200</span>    <span class="comment">// This throws if not set</span></div>
<div class="line"><span class="lineno">  201</span>    <span class="keyword">auto</span> ctx = <a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a>-&gt;get_queue()-&gt;get_context();</div>
<div class="line"><span class="lineno">  202</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a>-&gt;get_cl_buffer(ctx);</div>
<div class="line"><span class="lineno">  203</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::buf</a>, and <a class="el" href="task_8hpp_source.html#l00244">trisycl::detail::task::get_queue()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a21266c6ebba45da03ee63e0342f8e7fc_cgraph.png" border="0" usemap="#agroup__data_a21266c6ebba45da03ee63e0342f8e7fc_cgraph" alt=""/></div>
<map name="agroup__data_a21266c6ebba45da03ee63e0342f8e7fc_cgraph" id="agroup__data_a21266c6ebba45da03ee63e0342f8e7fc_cgraph">
<area shape="rect" title="Get the boost::compute::buffer or throw if unset." alt="" coords="5,5,163,47"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1task.html#aef85e4bc2c97856581c09a62484b3f91" title="Get the queue behind the task to run a kernel on." alt="" coords="211,5,340,47"/>
</map>
</div>

</div>
</div>
<a id="a48edd495ed98735815a64a4ebfb2942e" name="a48edd495ed98735815a64a4ebfb2942e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48edd495ed98735815a64a4ebfb2942e">&#9670;&nbsp;</a></span>is_read_access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::is_read_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the accessor has a read access right. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000142">Todo:</a></b></dt><dd>Strangely, it is not really constexpr because it is not a static method...</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000143">Todo:</a></b></dt><dd>to move in the <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c" title="This describes the type of the access mode to be used via accessor.">access::mode</a> enum class and add to the specification ? </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00174">174</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  174</span>                                        {</div>
<div class="line"><span class="lineno">  175</span>    <span class="keywordflow">return</span> Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a> || Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">access::mode::read_write</a> ||</div>
<div class="line"><span class="lineno">  176</span>           Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">access::mode::discard_read_write</a>;</div>
<div class="line"><span class="lineno">  177</span>  }</div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">trisycl::access::mode::read_write</a></div><div class="ttdeci">@ read_write</div><div class="ttdoc">Read and write access.</div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">trisycl::access::mode::discard_read_write</a></div><div class="ttdeci">@ discard_read_write</div><div class="ttdoc">Read and write access and previous content discarded.</div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">trisycl::access::mode::read</a></div><div class="ttdeci">@ read</div><div class="ttdoc">Read-only access.</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">trisycl::access::discard_read_write</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">trisycl::access::read</a>, and <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">trisycl::access::read_write</a>.</p>

</div>
</div>
<a id="ae93b6f20bc4c61705ae616c02b5ad8ed" name="ae93b6f20bc4c61705ae616c02b5ad8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93b6f20bc4c61705ae616c02b5ad8ed">&#9670;&nbsp;</a></span>is_write_access()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::is_write_access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the accessor has a write access right. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000144">Todo:</a></b></dt><dd>Strangely, it is not really constexpr because it is not a static method...</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000145">Todo:</a></b></dt><dd>to move in the <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c" title="This describes the type of the access mode to be used via accessor.">access::mode</a> enum class and add to the specification ? </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00187">187</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  187</span>                                         {</div>
<div class="line"><span class="lineno">  188</span>    <span class="keywordflow">return</span> Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">access::mode::write</a> || Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">access::mode::read_write</a> ||</div>
<div class="line"><span class="lineno">  189</span>           Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">access::mode::discard_write</a> ||</div>
<div class="line"><span class="lineno">  190</span>           Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">access::mode::discard_read_write</a>;</div>
<div class="line"><span class="lineno">  191</span>  }</div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">trisycl::access::mode::write</a></div><div class="ttdeci">@ write</div><div class="ttdoc">Write-only access, but previous content not discarded.</div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">trisycl::access::mode::discard_write</a></div><div class="ttdeci">@ discard_write</div><div class="ttdoc">Write-only access and previous content discarded.</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">trisycl::access::discard_read_write</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">trisycl::access::discard_write</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">trisycl::access::read_write</a>, and <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">trisycl::access::write</a>.</p>

<p class="reference">Referenced by <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00091">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::accessor()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ae93b6f20bc4c61705ae616c02b5ad8ed_icgraph.png" border="0" usemap="#agroup__data_ae93b6f20bc4c61705ae616c02b5ad8ed_icgraph" alt=""/></div>
<map name="agroup__data_ae93b6f20bc4c61705ae616c02b5ad8ed_icgraph" id="agroup__data_ae93b6f20bc4c61705ae616c02b5ad8ed_icgraph">
<area shape="rect" title="Test if the accessor has a write access right." alt="" coords="211,5,368,47"/>
<area shape="rect" href="group__data.html#ab4881bcc1d0dc6fcdd30ebafc37ceada" title="Construct a host accessor from an existing buffer." alt="" coords="5,5,163,47"/>
</map>
</div>

</div>
</div>
<a id="a9acc187ff81ce7b877785d2fd9116e52" name="a9acc187ff81ce7b877785d2fd9116e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acc187ff81ce7b877785d2fd9116e52">&#9670;&nbsp;</a></span>register_accessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::register_accessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the accessor once a <code>std::shared_ptr</code> is created on it. </p>
<p >This is to be called from outside once the object is created. It has been tried directly inside the contructor, but calling <code>shared_from_this()</code> from the constructor dead-lock with libstdc++6</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000141">Todo:</a></b></dt><dd>Double-check with the C++ committee on this issue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00141">141</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  141</span>                           {</div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a>-&gt;get_queue()-&gt;is_host()) {</div>
<div class="line"><span class="lineno">  143</span>      <span class="comment">// To keep alive this accessor in the following lambdas</span></div>
<div class="line"><span class="lineno">  144</span>      <span class="keyword">auto</span> acc = this-&gt;shared_from_this();</div>
<div class="line"><span class="lineno">  145</span>      <span class="comment">// Attach the accessor to the task and get its order</span></div>
<div class="line"><span class="lineno">  146</span>      <a class="code hl_function" href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">set_order</a>(<a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a>-&gt;register_accessor(acc));</div>
<div class="line"><span class="lineno">  147</span><span class="preprocessor">#ifdef TRISYCL_OPENCL</span></div>
<div class="line"><span class="lineno">  148</span>      <span class="comment">/* Before running the kernel, make sure the cl_mem behind this</span></div>
<div class="line"><span class="lineno">  149</span><span class="comment">         accessor is up-to-date on the device if needed and pass it to</span></div>
<div class="line"><span class="lineno">  150</span><span class="comment">         the kernel */</span></div>
<div class="line"><span class="lineno">  151</span>      <a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a>-&gt;add_prelude([=] { acc-&gt;copy_in_cl_buffer(); });</div>
<div class="line"><span class="lineno">  152</span>      <span class="comment">// After running the kernel, deal with some copy-back if needed</span></div>
<div class="line"><span class="lineno">  153</span>      <a class="code hl_variable" href="group__data.html#ae542f16a71fdeb8797e59d711b7ed124">task</a>-&gt;add_postlude([=] {</div>
<div class="line"><span class="lineno">  154</span>        <span class="comment">/* Even if this function does nothing, it is required to</span></div>
<div class="line"><span class="lineno">  155</span><span class="comment">           have the capture of acc to keep the accessor alive across</span></div>
<div class="line"><span class="lineno">  156</span><span class="comment">           the kernel execution up to the execution postlude */</span></div>
<div class="line"><span class="lineno">  157</span>        acc-&gt;copy_back_cl_buffer();</div>
<div class="line"><span class="lineno">  158</span>      });</div>
<div class="line"><span class="lineno">  159</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  160</span>    }</div>
<div class="line"><span class="lineno">  161</span>  }</div>
<div class="ttc" id="agroup__data_html_a0f17346e18ae668ecb8175ff3b2ccb76"><div class="ttname"><a href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76">trisycl::detail::accessor_base::set_order</a></div><div class="ttdeci">void set_order(std::size_t o)</div><div class="ttdoc">Set the order of the accessor.</div><div class="ttdef"><b>Definition:</b> <a href="accessor__base_8hpp_source.html#l00050">accessor_base.hpp:50</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="task_8hpp_source.html#l00238">trisycl::detail::task::add_postlude()</a>, <a class="el" href="task_8hpp_source.html#l00230">trisycl::detail::task::add_prelude()</a>, <a class="el" href="task_8hpp_source.html#l00244">trisycl::detail::task::get_queue()</a>, <a class="el" href="task_8hpp_source.html#l00304">trisycl::detail::task::register_accessor()</a>, and <a class="el" href="accessor__base_8hpp_source.html#l00050">trisycl::detail::accessor_base::set_order()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a9acc187ff81ce7b877785d2fd9116e52_cgraph.png" border="0" usemap="#agroup__data_a9acc187ff81ce7b877785d2fd9116e52_cgraph" alt=""/></div>
<map name="agroup__data_a9acc187ff81ce7b877785d2fd9116e52_cgraph" id="agroup__data_a9acc187ff81ce7b877785d2fd9116e52_cgraph">
<area shape="rect" title="Register the accessor once a std::shared_ptr is created on it." alt="" coords="5,136,163,177"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1task.html#ab27a8d3c2bb97ad431a0917778065b21" title="Add a function to the postlude to run after kernel execution." alt="" coords="225,5,354,47"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1task.html#a9d4b2c6c423e3ddf52f802800b2fa70f" title="Add a function to the prelude to run before kernel execution." alt="" coords="225,71,354,112"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1task.html#aef85e4bc2c97856581c09a62484b3f91" title="Get the queue behind the task to run a kernel on." alt="" coords="225,136,354,177"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1task.html#a630e6c1b3c6f7b21029d401c78b1a2cc" title="Register an accessor and return its registration order." alt="" coords="223,201,356,243"/>
<area shape="rect" href="group__data.html#a0f17346e18ae668ecb8175ff3b2ccb76" title="Set the order of the accessor." alt="" coords="211,267,368,308"/>
</map>
</div>

</div>
</div>
<a id="a4c51168df9f102bc21423a5c01285450" name="a4c51168df9f102bc21423a5c01285450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c51168df9f102bc21423a5c01285450">&#9670;&nbsp;</a></span>set_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::set_buffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; &gt;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set later the current buffer associated to this accessor. </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00229">229</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  229</span>                                                                {</div>
<div class="line"><span class="lineno">  230</span>    <a class="code hl_variable" href="group__data.html#a5105567d37733e197cbefbc49cbb2067">buf</a> = <a class="code hl_variable" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>;</div>
<div class="line"><span class="lineno">  231</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="opencl__spir_8h_source.html#l00915">b</a>, and <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::buf</a>.</p>

<p class="reference">Referenced by <a class="el" href="local__accessor_8hpp_source.html#l00057">trisycl::detail::accessor&lt; T, Dimensions, Mode, access::target::local &gt;::accessor()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a4c51168df9f102bc21423a5c01285450_icgraph.png" border="0" usemap="#agroup__data_a4c51168df9f102bc21423a5c01285450_icgraph" alt=""/></div>
<map name="agroup__data_a4c51168df9f102bc21423a5c01285450_icgraph" id="agroup__data_a4c51168df9f102bc21423a5c01285450_icgraph">
<area shape="rect" title="Set later the current buffer associated to this accessor." alt="" coords="215,20,372,61"/>
<area shape="rect" href="group__data.html#aab5e6102db9388ea1d8a50d0ec01abdb" title="Construct a local accessor of the right size." alt="" coords="5,5,167,76"/>
</map>
</div>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a5105567d37733e197cbefbc49cbb2067" name="a5105567d37733e197cbefbc49cbb2067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5105567d37733e197cbefbc49cbb2067">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt;T, Dimensions&gt; &gt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::buf</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keep a reference to the accessed buffer. </p>
<p >Beware that it owns the buffer, which means that the accessor has to be destroyed to release the buffer and potentially unblock a kernel at the end of its execution </p>

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00066">66</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00091">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::accessor()</a>, <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00208">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::copy_in_cl_buffer()</a>, <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00164">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::get_buffer()</a>, <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00199">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::get_cl_buffer()</a>, and <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00229">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::set_buffer()</a>.</p>

</div>
</div>
<a id="a8c10b45aecd62eb5abc44b4e53b34edb" name="a8c10b45aecd62eb5abc44b4e53b34edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c10b45aecd62eb5abc44b4e53b34edb">&#9670;&nbsp;</a></span>handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">trisycl::detail::accessor</a>&lt; T, Dimensions, Mode, Target &gt;::handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00196">196</a> of file <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html">accessor.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1detail_1_1buffer" id="classtrisycl_1_1detail_1_1buffer"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1detail_1_1buffer">&#9670;&nbsp;</a></span>trisycl::detail::buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::detail::buffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, int Dimensions = 1&gt;<br />
class trisycl::detail::buffer&lt; T, Dimensions &gt;</div><p >A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that is used to store data to work on. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00037">37</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::detail::buffer&lt; T, Dimensions &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1buffer__inherit__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1buffer_3_01T_00_01Dimensions_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1detail_1_1buffer_3_01T_00_01Dimensions_01_4_inherit__map" id="atrisycl_1_1detail_1_1buffer_3_01T_00_01Dimensions_01_4_inherit__map">
<area shape="rect" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ..." alt="" coords="448,64,585,105"/>
<area shape="rect" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base" title="Factorize some template independent buffer aspects in a base class." alt="" coords="228,13,400,39"/>
<area shape="rect" title=" " alt="" coords="5,5,180,47"/>
<area shape="rect" href="group__execution.html" title=" " alt="" coords="235,64,393,105"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="245,129,383,171"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::detail::buffer&lt; T, Dimensions &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1buffer__coll__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1buffer_3_01T_00_01Dimensions_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1detail_1_1buffer_3_01T_00_01Dimensions_01_4_coll__map" id="atrisycl_1_1detail_1_1buffer_3_01T_00_01Dimensions_01_4_coll__map">
<area shape="rect" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ..." alt="" coords="1027,589,1164,631"/>
<area shape="rect" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base" title="Factorize some template independent buffer aspects in a base class." alt="" coords="681,239,853,266"/>
<area shape="rect" title=" " alt="" coords="305,5,480,47"/>
<area shape="rect" title=" " alt="" coords="333,71,453,98"/>
<area shape="rect" title=" " alt="" coords="327,123,458,164"/>
<area shape="rect" title=" " alt="" coords="363,189,422,215"/>
<area shape="rect" title=" " alt="" coords="329,239,456,266"/>
<area shape="rect" title=" " alt="" coords="317,291,468,332"/>
<area shape="rect" title=" " alt="" coords="317,356,468,397"/>
<area shape="rect" title=" " alt="" coords="307,422,478,478"/>
<area shape="rect" href="group__execution.html" title=" " alt="" coords="689,400,846,441"/>
<area shape="rect" title=" " alt="" coords="311,502,474,558"/>
<area shape="rect" href="group__debug__trace.html" title=" " alt="" coords="698,465,837,507"/>
<area shape="rect" title=" " alt="" coords="697,531,837,572"/>
<area shape="rect" title=" " alt="" coords="703,597,831,623"/>
<area shape="rect" title=" " alt="" coords="692,648,843,689"/>
<area shape="rect" title=" " alt="" coords="691,714,844,741"/>
<area shape="rect" href="classbool.html" title=" " alt="" coords="744,770,791,797"/>
<area shape="rect" href="group__execution.html#classtrisycl_1_1context" title="SYCL context." alt="" coords="713,821,821,847"/>
<area shape="rect" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html" title=" " alt="" coords="293,806,492,862"/>
<area shape="rect" title=" " alt="" coords="5,780,152,821"/>
<area shape="rect" href="classstd_1_1shared__ptr_3_01detail_1_1context_01_4.html" title=" " alt="" coords="15,845,142,887"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ac3824b2602bacdc61cd136c3251f0fb3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ac3824b2602bacdc61cd136c3251f0fb3">buffer</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r)</td></tr>
<tr class="memdesc:ac3824b2602bacdc61cd136c3251f0fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new read-write buffer of size.  <a href="group__data.html#ac3824b2602bacdc61cd136c3251f0fb3">More...</a><br /></td></tr>
<tr class="separator:ac3824b2602bacdc61cd136c3251f0fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a390bf223926b02a880f352f3e8b86d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a5a390bf223926b02a880f352f3e8b86d">buffer</a> (T *host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r)</td></tr>
<tr class="memdesc:a5a390bf223926b02a880f352f3e8b86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new read-write buffer from.  <a href="group__data.html#a5a390bf223926b02a880f352f3e8b86d">More...</a><br /></td></tr>
<tr class="separator:a5a390bf223926b02a880f352f3e8b86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716bac4639f7aae0c96662df1d9b18a7"><td class="memTemplParams" colspan="2">template&lt;typename Dependent  = T, typename  = std::enable_if_t&lt;!std::is_const&lt;Dependent&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a716bac4639f7aae0c96662df1d9b18a7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a716bac4639f7aae0c96662df1d9b18a7">buffer</a> (const T *host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r)</td></tr>
<tr class="memdesc:a716bac4639f7aae0c96662df1d9b18a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new read-only buffer from.  <a href="group__data.html#a716bac4639f7aae0c96662df1d9b18a7">More...</a><br /></td></tr>
<tr class="separator:a716bac4639f7aae0c96662df1d9b18a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc9bcb7edbffa95a2bea5e2ba4a8d76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a5dc9bcb7edbffa95a2bea5e2ba4a8d76">buffer</a> (<a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt; &amp;host_data, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r)</td></tr>
<tr class="memdesc:a5dc9bcb7edbffa95a2bea5e2ba4a8d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer with associated memory, using the data in host_data.  <a href="group__data.html#a5dc9bcb7edbffa95a2bea5e2ba4a8d76">More...</a><br /></td></tr>
<tr class="separator:a5dc9bcb7edbffa95a2bea5e2ba4a8d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e66dde02a1747614506a3028af30ab"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ad2e66dde02a1747614506a3028af30ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ad2e66dde02a1747614506a3028af30ab">buffer</a> (Iterator start_iterator, Iterator end_iterator)</td></tr>
<tr class="memdesc:ad2e66dde02a1747614506a3028af30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new allocated 1D buffer from the given elements.  <a href="group__data.html#ad2e66dde02a1747614506a3028af30ab">More...</a><br /></td></tr>
<tr class="separator:ad2e66dde02a1747614506a3028af30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360bd2887a957b3ef46e7af5dec9c2bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a360bd2887a957b3ef46e7af5dec9c2bc">~buffer</a> ()</td></tr>
<tr class="memdesc:a360bd2887a957b3ef46e7af5dec9c2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new sub-buffer without allocation to have separate accessors later.  <a href="group__data.html#a360bd2887a957b3ef46e7af5dec9c2bc">More...</a><br /></td></tr>
<tr class="separator:a360bd2887a957b3ef46e7af5dec9c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f0bd47cf9eb37ae0a684917d9f8a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aa40f0bd47cf9eb37ae0a684917d9f8a1">mark_as_written</a> ()</td></tr>
<tr class="memdesc:aa40f0bd47cf9eb37ae0a684917d9f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce the buffer to be considered as being modified.  <a href="group__data.html#aa40f0bd47cf9eb37ae0a684917d9f8a1">More...</a><br /></td></tr>
<tr class="separator:aa40f0bd47cf9eb37ae0a684917d9f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f7171b1ab0944411293437500ff5f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::host_buffer&gt; </td></tr>
<tr class="memitem:a405f7171b1ab0944411293437500ff5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a405f7171b1ab0944411293437500ff5f">track_access_mode</a> ()</td></tr>
<tr class="memdesc:a405f7171b1ab0944411293437500ff5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is to be called whenever an accessor is created.  <a href="group__data.html#a405f7171b1ab0944411293437500ff5f">More...</a><br /></td></tr>
<tr class="separator:a405f7171b1ab0944411293437500ff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e68f4c0f16de28b8e9fdb76c5cfd22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae7e68f4c0f16de28b8e9fdb76c5cfd22">set_final_data</a> (std::weak_ptr&lt; T &gt; final_data)</td></tr>
<tr class="memdesc:ae7e68f4c0f16de28b8e9fdb76c5cfd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weak pointer as destination for write-back on buffer destruction.  <a href="group__data.html#ae7e68f4c0f16de28b8e9fdb76c5cfd22">More...</a><br /></td></tr>
<tr class="separator:ae7e68f4c0f16de28b8e9fdb76c5cfd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500142688acee4dba1029647f1a5196d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a500142688acee4dba1029647f1a5196d">set_final_data</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a500142688acee4dba1029647f1a5196d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable write-back on buffer destruction as an iterator.  <a href="group__data.html#a500142688acee4dba1029647f1a5196d">More...</a><br /></td></tr>
<tr class="separator:a500142688acee4dba1029647f1a5196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f9728d9c3731350b1e63dfbd4997e8"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename ValueType  = typename std::iterator_traits&lt;Iterator&gt;::value_type&gt; </td></tr>
<tr class="memitem:ab2f9728d9c3731350b1e63dfbd4997e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ab2f9728d9c3731350b1e63dfbd4997e8">set_final_data</a> (Iterator final_data)</td></tr>
<tr class="memdesc:ab2f9728d9c3731350b1e63dfbd4997e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide destination for write-back on buffer destruction as an iterator.  <a href="group__data.html#ab2f9728d9c3731350b1e63dfbd4997e8">More...</a><br /></td></tr>
<tr class="separator:ab2f9728d9c3731350b1e63dfbd4997e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a845aaca998a0a78d3b05a4cef1efb"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::future&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aa0a845aaca998a0a78d3b05a4cef1efb">get_destructor_future</a> ()</td></tr>
<tr class="memdesc:aa0a845aaca998a0a78d3b05a4cef1efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <code>future</code> to wait from inside the <code><a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a></code> in case there is something to copy back to the host.  <a href="group__data.html#aa0a845aaca998a0a78d3b05a4cef1efb">More...</a><br /></td></tr>
<tr class="separator:aa0a845aaca998a0a78d3b05a4cef1efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__data"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__data')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">trisycl::detail::buffer_base</a></td></tr>
<tr class="memitem:ab7b11b9a72e16dbbab0401ab0dfeb14a inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab7b11b9a72e16dbbab0401ab0dfeb14a">buffer_base</a> ()</td></tr>
<tr class="memdesc:ab7b11b9a72e16dbbab0401ab0dfeb14a inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer base and marks the host context as the context that holds the most recent version of the data.  <a href="group__data.html#ab7b11b9a72e16dbbab0401ab0dfeb14a">More...</a><br /></td></tr>
<tr class="separator:ab7b11b9a72e16dbbab0401ab0dfeb14a inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775086e6f28f56d4a76879b09562bc7c inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a775086e6f28f56d4a76879b09562bc7c">~buffer_base</a> ()</td></tr>
<tr class="memdesc:a775086e6f28f56d4a76879b09562bc7c inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor waits for not being used anymore.  <a href="group__data.html#a775086e6f28f56d4a76879b09562bc7c">More...</a><br /></td></tr>
<tr class="separator:a775086e6f28f56d4a76879b09562bc7c inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c75ff99123dc8dd4eca7dc5dc446d72 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72">wait</a> ()</td></tr>
<tr class="memdesc:a6c75ff99123dc8dd4eca7dc5dc446d72 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for this buffer to be ready, which is no longer in use.  <a href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72">More...</a><br /></td></tr>
<tr class="separator:a6c75ff99123dc8dd4eca7dc5dc446d72 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe31d2f9f9eca682ea798abc155a90b inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#affe31d2f9f9eca682ea798abc155a90b">use</a> ()</td></tr>
<tr class="memdesc:affe31d2f9f9eca682ea798abc155a90b inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this buffer in use by a task.  <a href="group__data.html#affe31d2f9f9eca682ea798abc155a90b">More...</a><br /></td></tr>
<tr class="separator:affe31d2f9f9eca682ea798abc155a90b inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859472c44cb2df3b882340892b962e2b inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a859472c44cb2df3b882340892b962e2b">release</a> ()</td></tr>
<tr class="memdesc:a859472c44cb2df3b882340892b962e2b inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task has released the buffer.  <a href="group__data.html#a859472c44cb2df3b882340892b962e2b">More...</a><br /></td></tr>
<tr class="separator:a859472c44cb2df3b882340892b962e2b inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f103aa2bb2c90ab2932c1abe0daaac inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a20f103aa2bb2c90ab2932c1abe0daaac">get_latest_producer</a> ()</td></tr>
<tr class="memdesc:a20f103aa2bb2c90ab2932c1abe0daaac inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest producer for the buffer.  <a href="group__data.html#a20f103aa2bb2c90ab2932c1abe0daaac">More...</a><br /></td></tr>
<tr class="separator:a20f103aa2bb2c90ab2932c1abe0daaac inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d93e1925b952a630223550d29da754 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a18d93e1925b952a630223550d29da754">set_latest_producer</a> (std::weak_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; newer_latest_producer)</td></tr>
<tr class="memdesc:a18d93e1925b952a630223550d29da754 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest producer for the buffer and set another future producer.  <a href="group__data.html#a18d93e1925b952a630223550d29da754">More...</a><br /></td></tr>
<tr class="separator:a18d93e1925b952a630223550d29da754 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6b63a27d571669233aa06255628fc4 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#afa6b63a27d571669233aa06255628fc4">add_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:afa6b63a27d571669233aa06255628fc4 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a buffer to the task running the command group.  <a href="group__data.html#afa6b63a27d571669233aa06255628fc4">More...</a><br /></td></tr>
<tr class="separator:afa6b63a27d571669233aa06255628fc4 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b361442b007be017d62301d726ef3e inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a42b361442b007be017d62301d726ef3e">is_data_up_to_date</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx)</td></tr>
<tr class="memdesc:a42b361442b007be017d62301d726ef3e inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data of this buffer is up-to-date in a certain context.  <a href="group__data.html#a42b361442b007be017d62301d726ef3e">More...</a><br /></td></tr>
<tr class="separator:a42b361442b007be017d62301d726ef3e inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae652de9b841f564c285311373fa96563 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae652de9b841f564c285311373fa96563">is_cached</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx)</td></tr>
<tr class="memdesc:ae652de9b841f564c285311373fa96563 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is already cached for a certain context.  <a href="group__data.html#ae652de9b841f564c285311373fa96563">More...</a><br /></td></tr>
<tr class="separator:ae652de9b841f564c285311373fa96563 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31930d97b31c40b843a1de541060cc24 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a31930d97b31c40b843a1de541060cc24">create_in_cache</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx, size_t size, cl_mem_flags flags, void *data)</td></tr>
<tr class="memdesc:a31930d97b31c40b843a1de541060cc24 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>boost::compute::buffer</code> for this <code><a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a></code> in the cache and associate it with a given context.  <a href="group__data.html#a31930d97b31c40b843a1de541060cc24">More...</a><br /></td></tr>
<tr class="separator:a31930d97b31c40b843a1de541060cc24 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d380bc456be55b375c6b31852236c02 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9d380bc456be55b375c6b31852236c02">sync_with_host</a> (std::size_t size, void *data)</td></tr>
<tr class="memdesc:a9d380bc456be55b375c6b31852236c02 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the most up-to-date version of the data to the host if the host version is not already up-to-date.  <a href="group__data.html#a9d380bc456be55b375c6b31852236c02">More...</a><br /></td></tr>
<tr class="separator:a9d380bc456be55b375c6b31852236c02 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6218af1679f6e4f06ae001a36a86bb inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb">update_buffer_state</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;target_ctx, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> mode, std::size_t size, void *data)</td></tr>
<tr class="memdesc:aad6218af1679f6e4f06ae001a36a86bb inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a transfer is requested this function is called, it will update the state of the buffer according to the context in which the accessor is created and the access mode.  <a href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb">More...</a><br /></td></tr>
<tr class="separator:aad6218af1679f6e4f06ae001a36a86bb inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8cc10dc36264d8358faced02819899 inherit pub_methods_group__data"><td class="memItemLeft" align="right" valign="top">boost::compute::buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aad8cc10dc36264d8358faced02819899">get_cl_buffer</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;<a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1context">context</a>)</td></tr>
<tr class="memdesc:aad8cc10dc36264d8358faced02819899 inherit pub_methods_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cl_buffer for a given context.  <a href="group__data.html#aad8cc10dc36264d8358faced02819899">More...</a><br /></td></tr>
<tr class="separator:aad8cc10dc36264d8358faced02819899 inherit pub_methods_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__execution.html">trisycl::mixin::accessor&lt; T, 1 &gt;</a></td></tr>
<tr class="memitem:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aa952a1cd3084acfd5848c96e1307b722">accessor</a> ()=default</td></tr>
<tr class="memdesc:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the local accessor hack on top of host accessor.  <a href="group__execution.html#aa952a1cd3084acfd5848c96e1307b722">More...</a><br /></td></tr>
<tr class="separator:aa952a1cd3084acfd5848c96e1307b722 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a4bee5e8e1a4cc07794c8603ceb05449c">accessor</a> (<a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> <a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;r)</td></tr>
<tr class="memdesc:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor of dimensions r on top of data storage.  <a href="group__execution.html#a4bee5e8e1a4cc07794c8603ceb05449c">More...</a><br /></td></tr>
<tr class="separator:a4bee5e8e1a4cc07794c8603ceb05449c inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#addcb16193eee7d27f95ad2562a3647c1">accessor</a> (const <a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> &amp;m)</td></tr>
<tr class="memdesc:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an accessor from another mdspan.  <a href="group__execution.html#addcb16193eee7d27f95ad2562a3647c1">More...</a><br /></td></tr>
<tr class="separator:addcb16193eee7d27f95ad2562a3647c1 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">update</a> (<a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> <a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;r)</td></tr>
<tr class="memdesc:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the accessor to target somewhere else.  <a href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">More...</a><br /></td></tr>
<tr class="separator:a991db73408f7b4fddb39d6b3a7d6b6ba inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">get_range</a> () const</td></tr>
<tr class="memdesc:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range object representing the size of the buffer in terms of number of elements in each dimension as passed to the constructor.  <a href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">More...</a><br /></td></tr>
<tr class="separator:af2a82185db89eb932bd151d7408a1ed4 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">get_count</a> () const</td></tr>
<tr class="memdesc:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in the buffer.  <a href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">More...</a><br /></td></tr>
<tr class="separator:aa144c18cd7c500dd696bc3916c8897b4 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">get_size</a> () const</td></tr>
<tr class="memdesc:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the buffer storage in bytes.  <a href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">More...</a><br /></td></tr>
<tr class="separator:a9466bab0b0a9d8ebb6ac731a45f7d7c9 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a> ()</td></tr>
<tr class="memdesc:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the underlying storage.  <a href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">More...</a><br /></td></tr>
<tr class="separator:a2148e7f785dcd09aa05272a378c31817 inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6e1886294408463407c1beccd8ca683d">tuple_indexed_access</a> (const auto &amp;tuple_like_indices)</td></tr>
<tr class="memdesc:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an element with indices implementing a tuple interface.  <a href="group__execution.html#a6e1886294408463407c1beccd8ca683d">More...</a><br /></td></tr>
<tr class="separator:a6e1886294408463407c1beccd8ca683d inherit pub_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a681f178c42064797dad5643f1a004351"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a681f178c42064797dad5643f1a004351">mixin</a> = <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">mixin::accessor</a>&lt; T, Dimensions &gt;</td></tr>
<tr class="separator:a681f178c42064797dad5643f1a004351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Member Functions</h3></td></tr>
<tr class="memitem:aae2f9755df12109f3d7c7fa55e2805a5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aae2f9755df12109f3d7c7fa55e2805a5">allocate_buffer</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;r)</td></tr>
<tr class="memdesc:aae2f9755df12109f3d7c7fa55e2805a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate uninitialized buffer memory.  <a href="group__data.html#aae2f9755df12109f3d7c7fa55e2805a5">More...</a><br /></td></tr>
<tr class="separator:aae2f9755df12109f3d7c7fa55e2805a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e395a1d1167c1fc6954a96fe2885a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aa3e395a1d1167c1fc6954a96fe2885a9">deallocate_buffer</a> ()</td></tr>
<tr class="memdesc:aa3e395a1d1167c1fc6954a96fe2885a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate buffer memory if required.  <a href="group__data.html#aa3e395a1d1167c1fc6954a96fe2885a9">More...</a><br /></td></tr>
<tr class="separator:aa3e395a1d1167c1fc6954a96fe2885a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905c7d7aeee6bee36a2e26fd02988f08"><td class="memTemplParams" colspan="2">template&lt;typename StartIter , typename EndIter &gt; </td></tr>
<tr class="memitem:a905c7d7aeee6bee36a2e26fd02988f08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a905c7d7aeee6bee36a2e26fd02988f08">assign</a> (StartIter start_iterator, EndIter end_iterator)</td></tr>
<tr class="memdesc:a905c7d7aeee6bee36a2e26fd02988f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the 1-D storage behind the accessor.  <a href="group__data.html#a905c7d7aeee6bee36a2e26fd02988f08">More...</a><br /></td></tr>
<tr class="separator:a905c7d7aeee6bee36a2e26fd02988f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b12d4ce70f0cc9b280db0e5ab05320"><td class="memTemplParams" colspan="2">template&lt;typename BaseType  = T, typename DataType &gt; </td></tr>
<tr class="memitem:ad9b12d4ce70f0cc9b280db0e5ab05320"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ad9b12d4ce70f0cc9b280db0e5ab05320">call_update_buffer_state</a> (<a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> ctx, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> mode, size_t size, DataType *<a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, std::enable_if_t&lt;!std::is_const&lt; BaseType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:ad9b12d4ce70f0cc9b280db0e5ab05320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pair to work around the fact that T might be a <code>const</code> type.  <a href="group__data.html#ad9b12d4ce70f0cc9b280db0e5ab05320">More...</a><br /></td></tr>
<tr class="separator:ad9b12d4ce70f0cc9b280db0e5ab05320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612d00c3d754c326024fc6dae96f0ecc"><td class="memTemplParams" colspan="2">template&lt;typename BaseType  = T, typename DataType &gt; </td></tr>
<tr class="memitem:a612d00c3d754c326024fc6dae96f0ecc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#a612d00c3d754c326024fc6dae96f0ecc">call_update_buffer_state</a> (<a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> ctx, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> mode, size_t size, DataType *<a class="el" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>, std::enable_if_t&lt; std::is_const&lt; BaseType &gt;::value &gt; *=0)</td></tr>
<tr class="memdesc:a612d00c3d754c326024fc6dae96f0ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code>call_update_buffer_state</code> that does nothing.  <a href="group__data.html#a612d00c3d754c326024fc6dae96f0ecc">More...</a><br /></td></tr>
<tr class="separator:a612d00c3d754c326024fc6dae96f0ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:ab7bed0b90bb2b4c6907ae4c710709f6e"><td class="memItemLeft" align="right" valign="top">std::allocator&lt; typename <a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">mixin::value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab7bed0b90bb2b4c6907ae4c710709f6e">alloc</a></td></tr>
<tr class="memdesc:ab7bed0b90bb2b4c6907ae4c710709f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator to be used when some memory is needed.  <a href="group__data.html#ab7bed0b90bb2b4c6907ae4c710709f6e">More...</a><br /></td></tr>
<tr class="separator:ab7bed0b90bb2b4c6907ae4c710709f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11ddfc14c512c5098a5b807e6476ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#aad9e2a9cdf64e350ee9993ad05f43d12">mixin::non_const_pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">allocation</a> = nullptr</td></tr>
<tr class="memdesc:ac11ddfc14c512c5098a5b807e6476ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If some allocation is requested on the host for the buffer memory, this is where the memory is attached to.  <a href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">More...</a><br /></td></tr>
<tr class="separator:ac11ddfc14c512c5098a5b807e6476ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ba98019b68c831025ad567e5786ca6"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::function&lt; void(void)&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a07ba98019b68c831025ad567e5786ca6">final_write_back</a></td></tr>
<tr class="memdesc:a07ba98019b68c831025ad567e5786ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">How to copy back data on buffer destruction, can be modified with set_final_data( ... )  <a href="group__data.html#a07ba98019b68c831025ad567e5786ca6">More...</a><br /></td></tr>
<tr class="separator:a07ba98019b68c831025ad567e5786ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c88bf569397d729c66b2fdda36d22d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ac5c88bf569397d729c66b2fdda36d22d">input_shared_pointer</a></td></tr>
<tr class="memdesc:ac5c88bf569397d729c66b2fdda36d22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep the shared pointer used to create the buffer.  <a href="group__data.html#ac5c88bf569397d729c66b2fdda36d22d">More...</a><br /></td></tr>
<tr class="separator:ac5c88bf569397d729c66b2fdda36d22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23710c429991bccf12300fa783228db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a23710c429991bccf12300fa783228db9">data_host</a> = false</td></tr>
<tr class="memdesc:a23710c429991bccf12300fa783228db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track if the buffer memory is backed by user-provided host memory.  <a href="group__data.html#a23710c429991bccf12300fa783228db9">More...</a><br /></td></tr>
<tr class="separator:a23710c429991bccf12300fa783228db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5fafeb5fd56c5a00d533c899e4c479"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ada5fafeb5fd56c5a00d533c899e4c479">copy_if_modified</a> = false</td></tr>
<tr class="memdesc:ada5fafeb5fd56c5a00d533c899e4c479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track if data should be copied into buffer-owned memory if a modification occurs.  <a href="group__data.html#ada5fafeb5fd56c5a00d533c899e4c479">More...</a><br /></td></tr>
<tr class="separator:ada5fafeb5fd56c5a00d533c899e4c479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8f9147d8c6c779178ec6d4eb833e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a8b8f9147d8c6c779178ec6d4eb833e6b">modified</a> = false</td></tr>
<tr class="separator:a8b8f9147d8c6c779178ec6d4eb833e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8b3db12fae6ace52a918ced41cec73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a3b8b3db12fae6ace52a918ced41cec73">host_context</a> { <a class="el" href="group__execution.html#classtrisycl_1_1device">trisycl::device</a> {} }</td></tr>
<tr class="memdesc:a3b8b3db12fae6ace52a918ced41cec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track the host context.  <a href="group__data.html#a3b8b3db12fae6ace52a918ced41cec73">More...</a><br /></td></tr>
<tr class="separator:a3b8b3db12fae6ace52a918ced41cec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr class="memitem:ab08f084bec0b5b516e0a88ded211cb94"><td class="memTemplParams" colspan="2">template&lt;typename U , int D, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </td></tr>
<tr class="memitem:ab08f084bec0b5b516e0a88ded211cb94"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ab08f084bec0b5b516e0a88ded211cb94">detail::accessor</a></td></tr>
<tr class="separator:ab08f084bec0b5b516e0a88ded211cb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__execution.html">trisycl::mixin::accessor&lt; T, 1 &gt;</a></td></tr>
<tr class="memitem:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> = T</td></tr>
<tr class="memdesc:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to SYCL: provide pieces of STL container interface from mdspan.  <a href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">More...</a><br /></td></tr>
<tr class="separator:a2a963137d3ddb4dbf1523648b85e1a2f inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">value_type</a> = std::remove_cv_t&lt; <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> &gt;</td></tr>
<tr class="memdesc:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Even if the buffer is read-only use a non-const type so at least the current implementation can copy the data too.  <a href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">More...</a><br /></td></tr>
<tr class="separator:a8fdc0d810bd40c67fcdc465cbc85c25e inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e2a9cdf64e350ee9993ad05f43d12 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#aad9e2a9cdf64e350ee9993ad05f43d12">non_const_pointer</a> = <a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">value_type</a> *</td></tr>
<tr class="separator:aad9e2a9cdf64e350ee9993ad05f43d12 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">pointer</a> = typename mdspan::accessor_type::data_handle_type</td></tr>
<tr class="memdesc:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to element.  <a href="group__execution.html#afa158ec7dbea25957c590f7cb1c937ac">More...</a><br /></td></tr>
<tr class="separator:afa158ec7dbea25957c590f7cb1c937ac inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">const_pointer</a> = const <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a> *</td></tr>
<tr class="memdesc:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer type to const element.  <a href="group__execution.html#a6189699fe9dbcc759408ba889abf2832">More...</a><br /></td></tr>
<tr class="separator:a6189699fe9dbcc759408ba889abf2832 inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">reference</a> = typename mdspan::reference</td></tr>
<tr class="memdesc:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference type to the elements.  <a href="group__execution.html#a313e5afa84fb81dd5e2110679d370a8a">More...</a><br /></td></tr>
<tr class="separator:a313e5afa84fb81dd5e2110679d370a8a inherit pub_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__execution.html">trisycl::mixin::accessor&lt; T, 1 &gt;</a></td></tr>
<tr class="memitem:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a> ()</td></tr>
<tr class="memdesc:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions of the buffer.  <a href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">More...</a><br /></td></tr>
<tr class="separator:a67e0bd652641192aeb41a0b8adf2d8f3 inherit pub_static_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="memItemLeft" align="right" valign="top">static decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#abd5445bd551db33605ec8fa2709a10e8">tuple_indexed_mdspan_access</a> (auto &amp;&amp;some_mdspan, const auto &amp;tuple_like_indices)</td></tr>
<tr class="memdesc:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to an mdspan element with indices implementing a tuple interface.  <a href="group__execution.html#abd5445bd551db33605ec8fa2709a10e8">More...</a><br /></td></tr>
<tr class="separator:abd5445bd551db33605ec8fa2709a10e8 inherit pub_static_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__debug__trace"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__debug__trace')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__debug__trace.html">trisycl::detail::debug&lt; buffer&lt; T, 1 &gt; &gt;</a></td></tr>
<tr class="memitem:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memItemLeft" align="right" valign="top">static auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">type_pretty_name</a> ()</td></tr>
<tr class="memdesc:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pretty name of T itself.  <a href="group__debug__trace.html#a72fe3311447501d1ef9696f85bba4393">More...</a><br /></td></tr>
<tr class="separator:a72fe3311447501d1ef9696f85bba4393 inherit pub_static_methods_group__debug__trace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_group__data"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_group__data')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">trisycl::detail::buffer_base</a></td></tr>
<tr class="memitem:a9fca0380c4d885643b67ecbc3331bb24 inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">number_of_users</a></td></tr>
<tr class="separator:a9fca0380c4d885643b67ecbc3331bb24 inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6ceffab31b10a04e5630cf87d82e15 inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::weak_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">latest_producer</a></td></tr>
<tr class="memdesc:a7c6ceffab31b10a04e5630cf87d82e15 inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track the latest task to produce this buffer.  <a href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">More...</a><br /></td></tr>
<tr class="separator:a7c6ceffab31b10a04e5630cf87d82e15 inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98b22e92161a8c1f53076193ba37b0 inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">latest_producer_mutex</a></td></tr>
<tr class="memdesc:aca98b22e92161a8c1f53076193ba37b0 inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">To protect the access to latest_producer.  <a href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">More...</a><br /></td></tr>
<tr class="separator:aca98b22e92161a8c1f53076193ba37b0 inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b119c0884d169781464d3760cb3714 inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab7b119c0884d169781464d3760cb3714">ready</a></td></tr>
<tr class="memdesc:ab7b119c0884d169781464d3760cb3714 inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">To signal when this buffer ready.  <a href="group__data.html#ab7b119c0884d169781464d3760cb3714">More...</a><br /></td></tr>
<tr class="separator:ab7b119c0884d169781464d3760cb3714 inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14f60e26326adc7c1560d2b7dd6020 inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">ready_mutex</a></td></tr>
<tr class="memdesc:adf14f60e26326adc7c1560d2b7dd6020 inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">To protect the access to the condition variable.  <a href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">More...</a><br /></td></tr>
<tr class="separator:adf14f60e26326adc7c1560d2b7dd6020 inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dc376284def25f3e0db0895e14770f inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::promise&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a53dc376284def25f3e0db0895e14770f">notify_buffer_destructor</a></td></tr>
<tr class="memdesc:a53dc376284def25f3e0db0895e14770f inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the SYCL user buffer destructor is blocking, use this to block until this buffer implementation is destroyed.  <a href="group__data.html#a53dc376284def25f3e0db0895e14770f">More...</a><br /></td></tr>
<tr class="separator:a53dc376284def25f3e0db0895e14770f inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bac87bde2756bf2c7bbc175b6a9fbe inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a></td></tr>
<tr class="memdesc:a15bac87bde2756bf2c7bbc175b6a9fbe inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">To track contexts in which the data is up-to-date.  <a href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">More...</a><br /></td></tr>
<tr class="separator:a15bac87bde2756bf2c7bbc175b6a9fbe inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e44368d757ce1eb92ef1538ff213aef inherit pub_attribs_group__data"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>, boost::compute::buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a></td></tr>
<tr class="memdesc:a9e44368d757ce1eb92ef1538ff213aef inherit pub_attribs_group__data"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer-side cache that keeps the <code>boost::compute::buffer</code> (and the underlying <code>cl_buffer</code> ) so that if the buffer already exists inside the same context it is not recreated.  <a href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">More...</a><br /></td></tr>
<tr class="separator:a9e44368d757ce1eb92ef1538ff213aef inherit pub_attribs_group__data"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_types_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="group__execution.html">trisycl::mixin::accessor&lt; T, 1 &gt;</a></td></tr>
<tr class="memitem:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> = std::mdspan&lt; <a class="el" href="group__execution.html#a2a963137d3ddb4dbf1523648b85e1a2f">element_type</a>, std::dextents&lt; std::size_t, Dimensions &gt; &gt;</td></tr>
<tr class="memdesc:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory lay-out of a buffer is a dynamic multidimensional array.  <a href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">More...</a><br /></td></tr>
<tr class="separator:a6b1878e7097b9407d3033a451f34daef inherit pro_types_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="group__execution.html">trisycl::mixin::accessor&lt; T, 1 &gt;</a></td></tr>
<tr class="memitem:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memItemLeft" align="right" valign="top">const std::array&lt; typename mdspan::size_type, <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a255326fb325821d440d826dabda8f043">extents_cast</a> (const <a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">detail::small_array</a>&lt; BasicType, FinalType, <a class="el" href="group__execution.html#a67e0bd652641192aeb41a0b8adf2d8f3">rank</a>()&gt; &amp;sa)</td></tr>
<tr class="memdesc:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a SYCL range/id-like into a mdspan index array, which is an array of std::size_t into an array of std::ptrdiff_t.  <a href="group__execution.html#a255326fb325821d440d826dabda8f043">More...</a><br /></td></tr>
<tr class="separator:a255326fb325821d440d826dabda8f043 inherit pro_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">set_access</a> (const <a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a> &amp;<a class="el" href="opencl__spir_8h.html#afce50bc7a23ec77afc73ea78f6f569e9">a</a>)</td></tr>
<tr class="memdesc:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set later the mdspan associated to this accessor.  <a href="group__execution.html#a8dc014b33aba699cc4a9e2810df68c0f">More...</a><br /></td></tr>
<tr class="separator:a8dc014b33aba699cc4a9e2810df68c0f inherit pro_methods_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_group__execution"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_group__execution')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="group__execution.html">trisycl::mixin::accessor&lt; T, 1 &gt;</a></td></tr>
<tr class="memitem:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__execution.html#a6b1878e7097b9407d3033a451f34daef">mdspan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">access</a></td></tr>
<tr class="memdesc:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the multi-dimensional interface to the data that may point to either allocation in the case of storage managed by SYCL itself or to some other memory location in the case of host memory or storage&lt;&gt; abstraction use.  <a href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">More...</a><br /></td></tr>
<tr class="separator:adc74a5ffc79e1d0c93ab5ef1c492a17f inherit pro_attribs_group__execution"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a681f178c42064797dad5643f1a004351" name="a681f178c42064797dad5643f1a004351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681f178c42064797dad5643f1a004351">&#9670;&nbsp;</a></span>mixin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::mixin =  <a class="el" href="group__execution.html#classtrisycl_1_1mixin_1_1accessor">mixin::accessor</a>&lt;T, Dimensions&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00043">43</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ac3824b2602bacdc61cd136c3251f0fb3" name="ac3824b2602bacdc61cd136c3251f0fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3824b2602bacdc61cd136c3251f0fb3">&#9670;&nbsp;</a></span>buffer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new read-write buffer of size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000148">Todo:</a></b></dt><dd>Lazily allocate memory since it might not be used on host </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00088">88</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   90</span>      : <a class="code hl_typedef" href="group__data.html#a681f178c42064797dad5643f1a004351">mixin</a> { <a class="code hl_function" href="group__data.html#aae2f9755df12109f3d7c7fa55e2805a5">allocate_buffer</a>(r), r } {}</div>
<div class="ttc" id="agroup__data_html_a681f178c42064797dad5643f1a004351"><div class="ttname"><a href="group__data.html#a681f178c42064797dad5643f1a004351">trisycl::detail::buffer::mixin</a></div><div class="ttdeci">mixin::accessor&lt; T, Dimensions &gt; mixin</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00043">buffer.hpp:43</a></div></div>
<div class="ttc" id="agroup__data_html_aae2f9755df12109f3d7c7fa55e2805a5"><div class="ttname"><a href="group__data.html#aae2f9755df12109f3d7c7fa55e2805a5">trisycl::detail::buffer::allocate_buffer</a></div><div class="ttdeci">auto allocate_buffer(const range&lt; Dimensions &gt; &amp;r)</div><div class="ttdoc">Allocate uninitialized buffer memory.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00259">buffer.hpp:259</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5a390bf223926b02a880f352f3e8b86d" name="a5a390bf223926b02a880f352f3e8b86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a390bf223926b02a880f352f3e8b86d">&#9670;&nbsp;</a></span>buffer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new read-write buffer from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_data</td><td>of size </td></tr>
    <tr><td class="paramname">r</td><td>without further allocation </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00094">94</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   95</span>      : <a class="code hl_typedef" href="group__data.html#a681f178c42064797dad5643f1a004351">mixin</a> { host_data, r }</div>
<div class="line"><span class="lineno">   96</span>      , <a class="code hl_variable" href="group__data.html#a23710c429991bccf12300fa783228db9">data_host</a> { <span class="keyword">true</span> } {}</div>
<div class="ttc" id="agroup__data_html_a23710c429991bccf12300fa783228db9"><div class="ttname"><a href="group__data.html#a23710c429991bccf12300fa783228db9">trisycl::detail::buffer::data_host</a></div><div class="ttdeci">bool data_host</div><div class="ttdoc">Track if the buffer memory is backed by user-provided host memory.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00074">buffer.hpp:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a716bac4639f7aae0c96662df1d9b18a7" name="a716bac4639f7aae0c96662df1d9b18a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716bac4639f7aae0c96662df1d9b18a7">&#9670;&nbsp;</a></span>buffer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename Dependent  = T, typename  = std::enable_if_t&lt;!std::is_const&lt;Dependent&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new read-only buffer from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host_data</td><td>of size</td></tr>
    <tr><td class="paramname">r</td><td>without further allocation</td></tr>
  </table>
  </dd>
</dl>
<p>If the buffer is non const, use a copy-on-write mechanism with internal writable memory.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000149">Todo:</a></b></dt><dd>Clarify the semantics in the spec. What happens if the host change the host_data after buffer creation?</dd></dl>
<p >Only enable this constructor if the value type is not constant, because if it is constant, the buffer is constant too. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00112">112</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  113</span>      : <span class="comment">/* The buffer is read-only, even if the internal multidimensional</span></div>
<div class="line"><span class="lineno">  114</span><span class="comment">           wrapper is not. If a write accessor is requested, there should</span></div>
<div class="line"><span class="lineno">  115</span><span class="comment">           be a copy on write. So this pointer should not be written and</span></div>
<div class="line"><span class="lineno">  116</span><span class="comment">           this const_cast should be acceptable. */</span></div>
<div class="line"><span class="lineno">  117</span>      <a class="code hl_typedef" href="group__data.html#a681f178c42064797dad5643f1a004351">mixin</a> { <span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(host_data), r }</div>
<div class="line"><span class="lineno">  118</span>      , <a class="code hl_variable" href="group__data.html#a23710c429991bccf12300fa783228db9">data_host</a> { <span class="keyword">true</span> }</div>
<div class="line"><span class="lineno">  119</span>      ,</div>
<div class="line"><span class="lineno">  120</span>      <span class="comment">/* Set copy_if_modified to true, so that if an accessor with write</span></div>
<div class="line"><span class="lineno">  121</span><span class="comment">         access is created, data are copied before to be modified. */</span></div>
<div class="line"><span class="lineno">  122</span>      <a class="code hl_variable" href="group__data.html#ada5fafeb5fd56c5a00d533c899e4c479">copy_if_modified</a> { <span class="keyword">true</span> } {}</div>
<div class="ttc" id="agroup__data_html_ada5fafeb5fd56c5a00d533c899e4c479"><div class="ttname"><a href="group__data.html#ada5fafeb5fd56c5a00d533c899e4c479">trisycl::detail::buffer::copy_if_modified</a></div><div class="ttdeci">bool copy_if_modified</div><div class="ttdoc">Track if data should be copied into buffer-owned memory if a modification occurs.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00078">buffer.hpp:78</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5dc9bcb7edbffa95a2bea5e2ba4a8d76" name="a5dc9bcb7edbffa95a2bea5e2ba4a8d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc9bcb7edbffa95a2bea5e2ba4a8d76">&#9670;&nbsp;</a></span>buffer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>host_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new buffer with associated memory, using the data in host_data. </p>
<p >The ownership of the host_data is shared between the runtime and the user. In order to enable both the user application and the SYCL runtime to use the same pointer, a <a class="el" href="namespacetrisycl.html#aa3bd3b66b2b8b0d4de44838b05c4ae1d">trisycl::mutex_class</a> is used. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00132">132</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  133</span>      : <a class="code hl_typedef" href="group__data.html#a681f178c42064797dad5643f1a004351">mixin</a> { host_data.get(), r }</div>
<div class="line"><span class="lineno">  134</span>      , <a class="code hl_variable" href="group__data.html#ac5c88bf569397d729c66b2fdda36d22d">input_shared_pointer</a> { host_data }</div>
<div class="line"><span class="lineno">  135</span>      , <a class="code hl_variable" href="group__data.html#a23710c429991bccf12300fa783228db9">data_host</a> { <span class="keyword">true</span> } {}</div>
<div class="ttc" id="agroup__data_html_ac5c88bf569397d729c66b2fdda36d22d"><div class="ttname"><a href="group__data.html#ac5c88bf569397d729c66b2fdda36d22d">trisycl::detail::buffer::input_shared_pointer</a></div><div class="ttdeci">shared_ptr_class&lt; T &gt; input_shared_pointer</div><div class="ttdoc">Keep the shared pointer used to create the buffer.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00071">buffer.hpp:71</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2e66dde02a1747614506a3028af30ab" name="ad2e66dde02a1747614506a3028af30ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e66dde02a1747614506a3028af30ab">&#9670;&nbsp;</a></span>buffer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::buffer </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>start_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new allocated 1D buffer from the given elements. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00139">139</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  140</span>      : <a class="code hl_typedef" href="group__data.html#a681f178c42064797dad5643f1a004351">mixin</a> { <a class="code hl_function" href="group__data.html#aae2f9755df12109f3d7c7fa55e2805a5">allocate_buffer</a>(std::distance(start_iterator, end_iterator)),</div>
<div class="line"><span class="lineno">  141</span>                range&lt;1&gt; { <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(</div>
<div class="line"><span class="lineno">  142</span>                    std::distance(start_iterator, end_iterator)) } } {</div>
<div class="line"><span class="lineno">  143</span>    <a class="code hl_function" href="group__data.html#a905c7d7aeee6bee36a2e26fd02988f08">assign</a>(start_iterator, end_iterator);</div>
<div class="line"><span class="lineno">  144</span>  }</div>
<div class="ttc" id="agroup__data_html_a905c7d7aeee6bee36a2e26fd02988f08"><div class="ttname"><a href="group__data.html#a905c7d7aeee6bee36a2e26fd02988f08">trisycl::detail::buffer::assign</a></div><div class="ttdeci">void assign(StartIter start_iterator, EndIter end_iterator)</div><div class="ttdoc">Assign the 1-D storage behind the accessor.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00278">buffer.hpp:278</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a360bd2887a957b3ef46e7af5dec9c2bc" name="a360bd2887a957b3ef46e7af5dec9c2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360bd2887a957b3ef46e7af5dec9c2bc">&#9670;&nbsp;</a></span>~buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::~<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new sub-buffer without allocation to have separate accessors later. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000150">Todo:</a></b></dt><dd>To implement and deal with reference counting buffer(buffer&lt;T, Dimensions&gt; b,
       index&lt;Dimensions&gt; base_index,
       range&lt;Dimensions&gt; sub_range) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000151">Todo:</a></b></dt><dd>Allow CLHPP objects too? </dd></dl>
<p>The buffer content may be copied back on destruction to some final location </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00165">165</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  165</span>            {</div>
<div class="line"><span class="lineno">  166</span><span class="preprocessor">#ifdef TRISYCL_OPENCL</span></div>
<div class="line"><span class="lineno">  167</span>    <span class="comment">/* We ensure that the host has the most up-to-date version of the data</span></div>
<div class="line"><span class="lineno">  168</span><span class="comment">       before the buffer is destroyed. This is necessary because we do not</span></div>
<div class="line"><span class="lineno">  169</span><span class="comment">       systematically transfer the data back from a device with</span></div>
<div class="line"><span class="lineno">  170</span><span class="comment">       \c copy_back_cl_buffer any more.</span></div>
<div class="line"><span class="lineno">  171</span><span class="comment">       \todo Optimize for the case the buffer is not based on host memory</span></div>
<div class="line"><span class="lineno">  172</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  173</span>    <a class="code hl_function" href="group__data.html#ad9b12d4ce70f0cc9b280db0e5ab05320">call_update_buffer_state</a>(<a class="code hl_variable" href="group__data.html#a3b8b3db12fae6ace52a918ced41cec73">host_context</a>, <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a>,</div>
<div class="line"><span class="lineno">  174</span>                             <a class="code hl_function" href="group__execution.html#a9466bab0b0a9d8ebb6ac731a45f7d7c9">mixin::get_size</a>(), <a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">mixin::data</a>());</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  177</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="group__data.html#a8b8f9147d8c6c779178ec6d4eb833e6b">modified</a> &amp;&amp; <a class="code hl_variable" href="group__data.html#a07ba98019b68c831025ad567e5786ca6">final_write_back</a>)</div>
<div class="line"><span class="lineno">  178</span>      (*final_write_back)();</div>
<div class="line"><span class="lineno">  179</span>    <span class="comment">// Allocate explicitly allocated memory if required</span></div>
<div class="line"><span class="lineno">  180</span>    <a class="code hl_function" href="group__data.html#aa3e395a1d1167c1fc6954a96fe2885a9">deallocate_buffer</a>();</div>
<div class="line"><span class="lineno">  181</span>  }</div>
<div class="ttc" id="agroup__data_html_a07ba98019b68c831025ad567e5786ca6"><div class="ttname"><a href="group__data.html#a07ba98019b68c831025ad567e5786ca6">trisycl::detail::buffer::final_write_back</a></div><div class="ttdeci">boost::optional&lt; std::function&lt; void(void)&gt; &gt; final_write_back</div><div class="ttdoc">How to copy back data on buffer destruction, can be modified with set_final_data( ....</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00068">buffer.hpp:68</a></div></div>
<div class="ttc" id="agroup__data_html_a3b8b3db12fae6ace52a918ced41cec73"><div class="ttname"><a href="group__data.html#a3b8b3db12fae6ace52a918ced41cec73">trisycl::detail::buffer::host_context</a></div><div class="ttdeci">trisycl::context host_context</div><div class="ttdoc">Track the host context.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00084">buffer.hpp:84</a></div></div>
<div class="ttc" id="agroup__data_html_a8b8f9147d8c6c779178ec6d4eb833e6b"><div class="ttname"><a href="group__data.html#a8b8f9147d8c6c779178ec6d4eb833e6b">trisycl::detail::buffer::modified</a></div><div class="ttdeci">bool modified</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00081">buffer.hpp:81</a></div></div>
<div class="ttc" id="agroup__data_html_aa3e395a1d1167c1fc6954a96fe2885a9"><div class="ttname"><a href="group__data.html#aa3e395a1d1167c1fc6954a96fe2885a9">trisycl::detail::buffer::deallocate_buffer</a></div><div class="ttdeci">void deallocate_buffer()</div><div class="ttdoc">Deallocate buffer memory if required.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00267">buffer.hpp:267</a></div></div>
<div class="ttc" id="agroup__data_html_ad9b12d4ce70f0cc9b280db0e5ab05320"><div class="ttname"><a href="group__data.html#ad9b12d4ce70f0cc9b280db0e5ab05320">trisycl::detail::buffer::call_update_buffer_state</a></div><div class="ttdeci">void call_update_buffer_state(trisycl::context ctx, access::mode mode, size_t size, DataType *data, std::enable_if_t&lt;!std::is_const&lt; BaseType &gt;::value &gt; *=0)</div><div class="ttdoc">Function pair to work around the fact that T might be a const type.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00290">buffer.hpp:290</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">trisycl::access::read</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="aae2f9755df12109f3d7c7fa55e2805a5" name="aae2f9755df12109f3d7c7fa55e2805a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2f9755df12109f3d7c7fa55e2805a5">&#9670;&nbsp;</a></span>allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::allocate_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate uninitialized buffer memory. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00259">259</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  259</span>                                                   {</div>
<div class="line"><span class="lineno">  260</span>    <span class="keyword">auto</span> count = r.size();</div>
<div class="line"><span class="lineno">  261</span>    <span class="comment">// Allocate uninitialized memory</span></div>
<div class="line"><span class="lineno">  262</span>    <a class="code hl_variable" href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">allocation</a> = <a class="code hl_variable" href="group__data.html#ab7bed0b90bb2b4c6907ae4c710709f6e">alloc</a>.allocate(count);</div>
<div class="line"><span class="lineno">  263</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">allocation</a>;</div>
<div class="line"><span class="lineno">  264</span>  }</div>
<div class="ttc" id="agroup__data_html_ab7bed0b90bb2b4c6907ae4c710709f6e"><div class="ttname"><a href="group__data.html#ab7bed0b90bb2b4c6907ae4c710709f6e">trisycl::detail::buffer::alloc</a></div><div class="ttdeci">std::allocator&lt; typename mixin::value_type &gt; alloc</div><div class="ttdoc">The allocator to be used when some memory is needed.</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00055">buffer.hpp:55</a></div></div>
<div class="ttc" id="agroup__data_html_ac11ddfc14c512c5098a5b807e6476ed0"><div class="ttname"><a href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">trisycl::detail::buffer::allocation</a></div><div class="ttdeci">mixin::non_const_pointer allocation</div><div class="ttdoc">If some allocation is requested on the host for the buffer memory, this is where the memory is attach...</div><div class="ttdef"><b>Definition:</b> <a href="buffer_2detail_2buffer_8hpp_source.html#l00063">buffer.hpp:63</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="range_8hpp_source.html#l00053">trisycl::range&lt; Dimensions &gt;::size()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_aae2f9755df12109f3d7c7fa55e2805a5_cgraph.png" border="0" usemap="#agroup__data_aae2f9755df12109f3d7c7fa55e2805a5_cgraph" alt=""/></div>
<map name="agroup__data_aae2f9755df12109f3d7c7fa55e2805a5_cgraph" id="agroup__data_aae2f9755df12109f3d7c7fa55e2805a5_cgraph">
<area shape="rect" title="Allocate uninitialized buffer memory." alt="" coords="5,5,143,47"/>
<area shape="rect" href="group__parallelism.html#a55c2d38bfa586195fc9e1d789e011a0f" title="Return the number of elements in the range." alt="" coords="191,13,320,39"/>
</map>
</div>

</div>
</div>
<a id="a905c7d7aeee6bee36a2e26fd02988f08" name="a905c7d7aeee6bee36a2e26fd02988f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905c7d7aeee6bee36a2e26fd02988f08">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename StartIter , typename EndIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">StartIter&#160;</td>
          <td class="paramname"><em>start_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EndIter&#160;</td>
          <td class="paramname"><em>end_iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the 1-D storage behind the accessor. </p>
<p >Use 2 different iterator types since in C++20 ranges it is now the case. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00278">278</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  278</span>                                                              {</div>
<div class="line"><span class="lineno">  279</span>    std::copy(start_iterator, end_iterator, <a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">mixin::data</a>());</div>
<div class="line"><span class="lineno">  280</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a612d00c3d754c326024fc6dae96f0ecc" name="a612d00c3d754c326024fc6dae96f0ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612d00c3d754c326024fc6dae96f0ecc">&#9670;&nbsp;</a></span>call_update_buffer_state() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename BaseType  = T, typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::call_update_buffer_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_const&lt; BaseType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Version of <code>call_update_buffer_state</code> that does nothing. </p>
<p >It is called if the type of the data in the buffer is <code>const</code> </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00300">300</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  302</span>                                                       {}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9b12d4ce70f0cc9b280db0e5ab05320" name="ad9b12d4ce70f0cc9b280db0e5ab05320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b12d4ce70f0cc9b280db0e5ab05320">&#9670;&nbsp;</a></span>call_update_buffer_state() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename BaseType  = T, typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::call_update_buffer_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataType *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_const&lt; BaseType &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function pair to work around the fact that T might be a <code>const</code> type. </p>
<p >We call update_buffer_state only if T is not <code>const</code>, we have to use <code>enable_if</code> otherwise the compiler will try to cast <code>const</code> <code>void*</code> to <code>void*</code> if we create a buffer with a <code>const</code> type</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000152">Todo:</a></b></dt><dd>Use <code>if</code> <code>constexpr</code> when it is available with C++17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00290">290</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  292</span>                                                        {</div>
<div class="line"><span class="lineno">  293</span>    <a class="code hl_function" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb">update_buffer_state</a>(ctx, <a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a>, size, <a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">data</a>);</div>
<div class="line"><span class="lineno">  294</span>  }</div>
<div class="ttc" id="agroup__data_html_aad6218af1679f6e4f06ae001a36a86bb"><div class="ttname"><a href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb">trisycl::detail::buffer_base::update_buffer_state</a></div><div class="ttdeci">void update_buffer_state(const trisycl::context &amp;target_ctx, access::mode mode, std::size_t size, void *data)</div><div class="ttdoc">When a transfer is requested this function is called, it will update the state of the buffer accordin...</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00208">buffer_base.hpp:208</a></div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297c"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">trisycl::access::mode</a></div><div class="ttdeci">mode</div><div class="ttdoc">This describes the type of the access mode to be used via accessor.</div><div class="ttdef"><b>Definition:</b> <a href="access_8hpp_source.html#l00032">access.hpp:32</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3e395a1d1167c1fc6954a96fe2885a9" name="aa3e395a1d1167c1fc6954a96fe2885a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e395a1d1167c1fc6954a96fe2885a9">&#9670;&nbsp;</a></span>deallocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::deallocate_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate buffer memory if required. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00267">267</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  267</span>                           {</div>
<div class="line"><span class="lineno">  268</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">allocation</a>)</div>
<div class="line"><span class="lineno">  269</span>      <a class="code hl_variable" href="group__data.html#ab7bed0b90bb2b4c6907ae4c710709f6e">alloc</a>.deallocate(<a class="code hl_variable" href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">allocation</a>, <a class="code hl_function" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">mixin::get_count</a>());</div>
<div class="line"><span class="lineno">  270</span>  }</div>
<div class="ttc" id="agroup__execution_html_aa144c18cd7c500dd696bc3916c8897b4"><div class="ttname"><a href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">trisycl::mixin::accessor::get_count</a></div><div class="ttdeci">std::size_t get_count() const</div><div class="ttdoc">Returns the total number of elements in the buffer.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00118">accessor.hpp:118</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa0a845aaca998a0a78d3b05a4cef1efb" name="aa0a845aaca998a0a78d3b05a4cef1efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a845aaca998a0a78d3b05a4cef1efb">&#9670;&nbsp;</a></span>get_destructor_future()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::future&lt; void &gt; &gt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::get_destructor_future </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <code>future</code> to wait from inside the <code><a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a></code> in case there is something to copy back to the host. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>future</code> in the <code>optional</code> if there is something to wait for, otherwise an empty <code>optional</code> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000153">Todo:</a></b></dt><dd>Make the function private again </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00312">312</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  312</span>                                                         {</div>
<div class="line"><span class="lineno">  313</span>    <span class="comment">/* If there is only 1 shared_ptr user of the buffer, this is the</span></div>
<div class="line"><span class="lineno">  314</span><span class="comment">       caller of this function, the \c buffer_waiter, so there is no</span></div>
<div class="line"><span class="lineno">  315</span><span class="comment">       need to get a \ future otherwise there will be a dead-lock if</span></div>
<div class="line"><span class="lineno">  316</span><span class="comment">       there is only 1 thread waiting for itself.</span></div>
<div class="line"><span class="lineno">  317</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  318</span><span class="comment">       Since \c use_count() is applied to a \c shared_ptr just created</span></div>
<div class="line"><span class="lineno">  319</span><span class="comment">       for this purpose, it actually increase locally the count by 1,</span></div>
<div class="line"><span class="lineno">  320</span><span class="comment">       so check for 1 + 1 use count instead...</span></div>
<div class="line"><span class="lineno">  321</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  322</span>    <span class="comment">// If the buffer&#39;s destruction triggers a write-back, wait</span></div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">if</span> ((shared_from_this().use_count() &gt; 2) &amp;&amp; <a class="code hl_variable" href="group__data.html#a8b8f9147d8c6c779178ec6d4eb833e6b">modified</a> &amp;&amp;</div>
<div class="line"><span class="lineno">  324</span>        (<a class="code hl_variable" href="group__data.html#a07ba98019b68c831025ad567e5786ca6">final_write_back</a> || <a class="code hl_variable" href="group__data.html#a23710c429991bccf12300fa783228db9">data_host</a>)) {</div>
<div class="line"><span class="lineno">  325</span>      <span class="comment">// Create a promise to wait for</span></div>
<div class="line"><span class="lineno">  326</span>      <a class="code hl_variable" href="group__data.html#a53dc376284def25f3e0db0895e14770f">notify_buffer_destructor</a> = std::promise&lt;void&gt; {};</div>
<div class="line"><span class="lineno">  327</span>      <span class="comment">// And return the future to wait for it</span></div>
<div class="line"><span class="lineno">  328</span>      <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a53dc376284def25f3e0db0895e14770f">notify_buffer_destructor</a>-&gt;get_future();</div>
<div class="line"><span class="lineno">  329</span>    }</div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">return</span> boost::none;</div>
<div class="line"><span class="lineno">  331</span>  }</div>
<div class="ttc" id="agroup__data_html_a53dc376284def25f3e0db0895e14770f"><div class="ttname"><a href="group__data.html#a53dc376284def25f3e0db0895e14770f">trisycl::detail::buffer_base::notify_buffer_destructor</a></div><div class="ttdeci">boost::optional&lt; std::promise&lt; void &gt; &gt; notify_buffer_destructor</div><div class="ttdoc">If the SYCL user buffer destructor is blocking, use this to block until this buffer implementation is...</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00069">buffer_base.hpp:69</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa40f0bd47cf9eb37ae0a684917d9f8a1" name="aa40f0bd47cf9eb37ae0a684917d9f8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f0bd47cf9eb37ae0a684917d9f8a1">&#9670;&nbsp;</a></span>mark_as_written()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::mark_as_written </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enforce the buffer to be considered as being modified. </p>
<p >Same as creating an accessor with write access. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00186">186</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  186</span>{ <a class="code hl_variable" href="group__data.html#a8b8f9147d8c6c779178ec6d4eb833e6b">modified</a> = <span class="keyword">true</span>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2f9728d9c3731350b1e63dfbd4997e8" name="ab2f9728d9c3731350b1e63dfbd4997e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f9728d9c3731350b1e63dfbd4997e8">&#9670;&nbsp;</a></span>set_final_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename Iterator , typename ValueType  = typename std::iterator_traits&lt;Iterator&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>final_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide destination for write-back on buffer destruction as an iterator. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00246">246</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  246</span>                                           {</div>
<div class="line"><span class="lineno">  247</span>    <span class="comment">/*   using type_ = typename iterator_value_type&lt;Iterator&gt;::value_type;</span></div>
<div class="line"><span class="lineno">  248</span><span class="comment">         static_assert(std::is_same&lt;type_, T&gt;::value, &quot;buffer type mismatch&quot;);</span></div>
<div class="line"><span class="lineno">  249</span><span class="comment">         static_assert(!(std::is_const&lt;type_&gt;::value),</span></div>
<div class="line"><span class="lineno">  250</span><span class="comment">                       &quot;const iterator is not allowed&quot;);*/</span></div>
<div class="line"><span class="lineno">  251</span>    <span class="comment">// Capture this by reference is enough since the buffer will still exist</span></div>
<div class="line"><span class="lineno">  252</span>    <a class="code hl_variable" href="group__data.html#a07ba98019b68c831025ad567e5786ca6">final_write_back</a> = [<span class="keyword">this</span>, final_data = std::move(final_data)] {</div>
<div class="line"><span class="lineno">  253</span>      std::copy_n(<a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">mixin::data</a>(), <a class="code hl_function" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">mixin::get_count</a>(), final_data);</div>
<div class="line"><span class="lineno">  254</span>    };</div>
<div class="line"><span class="lineno">  255</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a500142688acee4dba1029647f1a5196d" name="a500142688acee4dba1029647f1a5196d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500142688acee4dba1029647f1a5196d">&#9670;&nbsp;</a></span>set_final_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable write-back on buffer destruction as an iterator. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00238">238</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  238</span>{ <a class="code hl_variable" href="group__data.html#a07ba98019b68c831025ad567e5786ca6">final_write_back</a> = boost::none; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7e68f4c0f16de28b8e9fdb76c5cfd22" name="ae7e68f4c0f16de28b8e9fdb76c5cfd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e68f4c0f16de28b8e9fdb76c5cfd22">&#9670;&nbsp;</a></span>set_final_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::set_final_data </td>
          <td>(</td>
          <td class="paramtype">std::weak_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>final_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the weak pointer as destination for write-back on buffer destruction. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00227">227</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  227</span>                                                 {</div>
<div class="line"><span class="lineno">  228</span>    <span class="comment">// Capture this by reference is enough since the buffer will still exist</span></div>
<div class="line"><span class="lineno">  229</span>    <a class="code hl_variable" href="group__data.html#a07ba98019b68c831025ad567e5786ca6">final_write_back</a> = [<span class="keyword">this</span>, final_data = std::move(final_data)] {</div>
<div class="line"><span class="lineno">  230</span>      <span class="keywordflow">if</span> (<span class="keyword">auto</span> sptr = final_data.lock()) {</div>
<div class="line"><span class="lineno">  231</span>        std::copy_n(<a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">mixin::data</a>(), <a class="code hl_function" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">mixin::get_count</a>(), sptr.get());</div>
<div class="line"><span class="lineno">  232</span>      }</div>
<div class="line"><span class="lineno">  233</span>    };</div>
<div class="line"><span class="lineno">  234</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a405f7171b1ab0944411293437500ff5f" name="a405f7171b1ab0944411293437500ff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f7171b1ab0944411293437500ff5f">&#9670;&nbsp;</a></span>track_access_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target = access::target::host_buffer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::track_access_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is to be called whenever an accessor is created. </p>
<p >Its current purpose is to track if an accessor with write access is created and acting accordingly. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00195">195</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  195</span>                           {</div>
<div class="line"><span class="lineno">  196</span>    <span class="comment">// test if write access is required</span></div>
<div class="line"><span class="lineno">  197</span>    <span class="keywordflow">if</span> (Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">access::mode::write</a> || Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">access::mode::read_write</a> ||</div>
<div class="line"><span class="lineno">  198</span>        Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">access::mode::discard_write</a> ||</div>
<div class="line"><span class="lineno">  199</span>        Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">access::mode::discard_read_write</a> ||</div>
<div class="line"><span class="lineno">  200</span>        Mode == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca23d33884d600e542d097cd3933df2ae4">access::mode::atomic</a>) {</div>
<div class="line"><span class="lineno">  201</span>      <a class="code hl_variable" href="group__data.html#a8b8f9147d8c6c779178ec6d4eb833e6b">modified</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  202</span>      <span class="keywordflow">if</span> (<a class="code hl_variable" href="group__data.html#ada5fafeb5fd56c5a00d533c899e4c479">copy_if_modified</a>) {</div>
<div class="line"><span class="lineno">  203</span>        <span class="comment">// Implement the allocate &amp; copy-on-write optimization</span></div>
<div class="line"><span class="lineno">  204</span>        <a class="code hl_variable" href="group__data.html#ada5fafeb5fd56c5a00d533c899e4c479">copy_if_modified</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  205</span>        <span class="comment">// Since the mixin store the geometry, keep a copy before updating</span></div>
<div class="line"><span class="lineno">  206</span>        <span class="keyword">auto</span> current_access = <a class="code hl_variable" href="group__execution.html#adc74a5ffc79e1d0c93ab5ef1c492a17f">mixin::access</a>;</div>
<div class="line"><span class="lineno">  207</span>        <span class="comment">/* The range is actually computed from \c access itself, so</span></div>
<div class="line"><span class="lineno">  208</span><span class="comment">           save it */</span></div>
<div class="line"><span class="lineno">  209</span>        <span class="keyword">auto</span> current_range = <a class="code hl_function" href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">mixin::get_range</a>();</div>
<div class="line"><span class="lineno">  210</span>        <a class="code hl_function" href="group__data.html#aae2f9755df12109f3d7c7fa55e2805a5">allocate_buffer</a>(current_range);</div>
<div class="line"><span class="lineno">  211</span>        <span class="comment">/* Update the mixin accessor to point to the new allocated</span></div>
<div class="line"><span class="lineno">  212</span><span class="comment">           memory instead */</span></div>
<div class="line"><span class="lineno">  213</span>        <a class="code hl_function" href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">mixin::update</a>(<a class="code hl_variable" href="group__data.html#ac11ddfc14c512c5098a5b807e6476ed0">allocation</a>, current_range);</div>
<div class="line"><span class="lineno">  214</span>        <span class="comment">// Then copy the read-only data to the new allocated place</span></div>
<div class="line"><span class="lineno">  215</span>        std::uninitialized_copy_n(current_access.data_handle(), <a class="code hl_function" href="group__execution.html#aa144c18cd7c500dd696bc3916c8897b4">mixin::get_count</a>(),</div>
<div class="line"><span class="lineno">  216</span>                                  <a class="code hl_function" href="group__execution.html#a2148e7f785dcd09aa05272a378c31817">mixin::data</a>());</div>
<div class="line"><span class="lineno">  217</span>        <span class="comment">/* Now the data of the buffer is no longer backed-up by host</span></div>
<div class="line"><span class="lineno">  218</span><span class="comment">           user provided memory */</span></div>
<div class="line"><span class="lineno">  219</span>        <a class="code hl_variable" href="group__data.html#a23710c429991bccf12300fa783228db9">data_host</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  220</span>      }</div>
<div class="line"><span class="lineno">  221</span>    }</div>
<div class="line"><span class="lineno">  222</span>  }</div>
<div class="ttc" id="agroup__execution_html_a991db73408f7b4fddb39d6b3a7d6b6ba"><div class="ttname"><a href="group__execution.html#a991db73408f7b4fddb39d6b3a7d6b6ba">trisycl::mixin::accessor::update</a></div><div class="ttdeci">void update(pointer data, const range&lt; rank()&gt; &amp;r)</div><div class="ttdoc">Update the accessor to target somewhere else.</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00092">accessor.hpp:92</a></div></div>
<div class="ttc" id="agroup__execution_html_af2a82185db89eb932bd151d7408a1ed4"><div class="ttname"><a href="group__execution.html#af2a82185db89eb932bd151d7408a1ed4">trisycl::mixin::accessor::get_range</a></div><div class="ttdeci">auto get_range() const</div><div class="ttdoc">Return a range object representing the size of the buffer in terms of number of elements in each dime...</div><div class="ttdef"><b>Definition:</b> <a href="triSYCL_2accessor_2mixin_2accessor_8hpp_source.html#l00102">accessor.hpp:102</a></div></div>
<div class="ttc" id="anamespacetrisycl_1_1access_html_a2ee71c8ee80896e782636c805fab297ca23d33884d600e542d097cd3933df2ae4"><div class="ttname"><a href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca23d33884d600e542d097cd3933df2ae4">trisycl::access::mode::atomic</a></div><div class="ttdeci">@ atomic</div><div class="ttdoc">Atomic access.</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca23d33884d600e542d097cd3933df2ae4">trisycl::access::atomic</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">trisycl::access::discard_read_write</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">trisycl::access::discard_write</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">trisycl::access::read_write</a>, and <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">trisycl::access::write</a>.</p>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="ab08f084bec0b5b516e0a88ded211cb94" name="ab08f084bec0b5b516e0a88ded211cb94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08f084bec0b5b516e0a88ded211cb94">&#9670;&nbsp;</a></span>detail::accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<div class="memtemplate">
template&lt;typename U , int D, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> Mode, <a class="el" href="namespacetrisycl_1_1access.html#a258ca109c2018a5bee3afa063c75716f">access::target</a> Target&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> class <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">detail::accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00049">49</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="ab7bed0b90bb2b4c6907ae4c710709f6e" name="ab7bed0b90bb2b4c6907ae4c710709f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bed0b90bb2b4c6907ae4c710709f6e">&#9670;&nbsp;</a></span>alloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::allocator&lt;typename <a class="el" href="group__execution.html#a8fdc0d810bd40c67fcdc465cbc85c25e">mixin::value_type</a>&gt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The allocator to be used when some memory is needed. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000147">Todo:</a></b></dt><dd>Implement user-provided allocator </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00055">55</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="ac11ddfc14c512c5098a5b807e6476ed0" name="ac11ddfc14c512c5098a5b807e6476ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11ddfc14c512c5098a5b807e6476ed0">&#9670;&nbsp;</a></span>allocation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__execution.html#aad9e2a9cdf64e350ee9993ad05f43d12">mixin::non_const_pointer</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::allocation = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If some allocation is requested on the host for the buffer memory, this is where the memory is attached to. </p>
<p >Note that this is uninitialized memory, as stated in SYCL specification. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00063">63</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="ada5fafeb5fd56c5a00d533c899e4c479" name="ada5fafeb5fd56c5a00d533c899e4c479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5fafeb5fd56c5a00d533c899e4c479">&#9670;&nbsp;</a></span>copy_if_modified</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::copy_if_modified = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Track if data should be copied into buffer-owned memory if a modification occurs. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00078">78</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="a23710c429991bccf12300fa783228db9" name="a23710c429991bccf12300fa783228db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23710c429991bccf12300fa783228db9">&#9670;&nbsp;</a></span>data_host</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::data_host = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Track if the buffer memory is backed by user-provided host memory. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00074">74</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="a07ba98019b68c831025ad567e5786ca6" name="a07ba98019b68c831025ad567e5786ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ba98019b68c831025ad567e5786ca6">&#9670;&nbsp;</a></span>final_write_back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt;std::function&lt;void(void)&gt; &gt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::final_write_back</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How to copy back data on buffer destruction, can be modified with set_final_data( ... ) </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00068">68</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="a3b8b3db12fae6ace52a918ced41cec73" name="a3b8b3db12fae6ace52a918ced41cec73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8b3db12fae6ace52a918ced41cec73">&#9670;&nbsp;</a></span>host_context</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::host_context { <a class="el" href="group__execution.html#classtrisycl_1_1device">trisycl::device</a> {} }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Track the host context. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00084">84</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="ac5c88bf569397d729c66b2fdda36d22d" name="ac5c88bf569397d729c66b2fdda36d22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c88bf569397d729c66b2fdda36d22d">&#9670;&nbsp;</a></span>input_shared_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetrisycl.html#a05295c66f4814460764872f606f33b89">shared_ptr_class</a>&lt;T&gt; <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::input_shared_pointer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keep the shared pointer used to create the buffer. </p>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00071">71</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a id="a8b8f9147d8c6c779178ec6d4eb833e6b" name="a8b8f9147d8c6c779178ec6d4eb833e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8f9147d8c6c779178ec6d4eb833e6b">&#9670;&nbsp;</a></span>modified</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">trisycl::detail::buffer</a>&lt; T, Dimensions &gt;::modified = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00081">81</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="structtrisycl_1_1detail_1_1buffer__base" id="structtrisycl_1_1detail_1_1buffer__base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtrisycl_1_1detail_1_1buffer__base">&#9670;&nbsp;</a></span>trisycl::detail::buffer_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct trisycl::detail::buffer_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >Factorize some template independent buffer aspects in a base class. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00049">49</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::detail::buffer_base:</div>
<div class="dyncontent">
<div class="center"><img src="structtrisycl_1_1detail_1_1buffer__base__inherit__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1buffer__base_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1detail_1_1buffer__base_inherit__map" id="atrisycl_1_1detail_1_1buffer__base_inherit__map">
<area shape="rect" title="Factorize some template independent buffer aspects in a base class." alt="" coords="7,95,179,121"/>
<area shape="rect" href="group__data.html#classtrisycl_1_1detail_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ..." alt="" coords="24,169,161,211"/>
<area shape="rect" title=" " alt="" coords="5,5,180,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::detail::buffer_base:</div>
<div class="dyncontent">
<div class="center"><img src="structtrisycl_1_1detail_1_1buffer__base__coll__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1buffer__base_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1detail_1_1buffer__base_coll__map" id="atrisycl_1_1detail_1_1buffer__base_coll__map">
<area shape="rect" title="Factorize some template independent buffer aspects in a base class." alt="" coords="369,215,541,242"/>
<area shape="rect" title=" " alt="" coords="5,5,180,47"/>
<area shape="rect" title=" " alt="" coords="33,71,153,98"/>
<area shape="rect" title=" " alt="" coords="27,123,158,164"/>
<area shape="rect" title=" " alt="" coords="63,189,122,215"/>
<area shape="rect" title=" " alt="" coords="29,239,156,266"/>
<area shape="rect" title=" " alt="" coords="17,291,168,332"/>
<area shape="rect" title=" " alt="" coords="17,356,168,397"/>
<area shape="rect" title=" " alt="" coords="7,422,178,478"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab7b11b9a72e16dbbab0401ab0dfeb14a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab7b11b9a72e16dbbab0401ab0dfeb14a">buffer_base</a> ()</td></tr>
<tr class="memdesc:ab7b11b9a72e16dbbab0401ab0dfeb14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a buffer base and marks the host context as the context that holds the most recent version of the data.  <a href="group__data.html#ab7b11b9a72e16dbbab0401ab0dfeb14a">More...</a><br /></td></tr>
<tr class="separator:ab7b11b9a72e16dbbab0401ab0dfeb14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775086e6f28f56d4a76879b09562bc7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a775086e6f28f56d4a76879b09562bc7c">~buffer_base</a> ()</td></tr>
<tr class="memdesc:a775086e6f28f56d4a76879b09562bc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor waits for not being used anymore.  <a href="group__data.html#a775086e6f28f56d4a76879b09562bc7c">More...</a><br /></td></tr>
<tr class="separator:a775086e6f28f56d4a76879b09562bc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c75ff99123dc8dd4eca7dc5dc446d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72">wait</a> ()</td></tr>
<tr class="memdesc:a6c75ff99123dc8dd4eca7dc5dc446d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for this buffer to be ready, which is no longer in use.  <a href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72">More...</a><br /></td></tr>
<tr class="separator:a6c75ff99123dc8dd4eca7dc5dc446d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe31d2f9f9eca682ea798abc155a90b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#affe31d2f9f9eca682ea798abc155a90b">use</a> ()</td></tr>
<tr class="memdesc:affe31d2f9f9eca682ea798abc155a90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this buffer in use by a task.  <a href="group__data.html#affe31d2f9f9eca682ea798abc155a90b">More...</a><br /></td></tr>
<tr class="separator:affe31d2f9f9eca682ea798abc155a90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859472c44cb2df3b882340892b962e2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a859472c44cb2df3b882340892b962e2b">release</a> ()</td></tr>
<tr class="memdesc:a859472c44cb2df3b882340892b962e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task has released the buffer.  <a href="group__data.html#a859472c44cb2df3b882340892b962e2b">More...</a><br /></td></tr>
<tr class="separator:a859472c44cb2df3b882340892b962e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f103aa2bb2c90ab2932c1abe0daaac"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a20f103aa2bb2c90ab2932c1abe0daaac">get_latest_producer</a> ()</td></tr>
<tr class="memdesc:a20f103aa2bb2c90ab2932c1abe0daaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest producer for the buffer.  <a href="group__data.html#a20f103aa2bb2c90ab2932c1abe0daaac">More...</a><br /></td></tr>
<tr class="separator:a20f103aa2bb2c90ab2932c1abe0daaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d93e1925b952a630223550d29da754"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a18d93e1925b952a630223550d29da754">set_latest_producer</a> (std::weak_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; newer_latest_producer)</td></tr>
<tr class="memdesc:a18d93e1925b952a630223550d29da754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest producer for the buffer and set another future producer.  <a href="group__data.html#a18d93e1925b952a630223550d29da754">More...</a><br /></td></tr>
<tr class="separator:a18d93e1925b952a630223550d29da754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6b63a27d571669233aa06255628fc4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#afa6b63a27d571669233aa06255628fc4">add_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:afa6b63a27d571669233aa06255628fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a buffer to the task running the command group.  <a href="group__data.html#afa6b63a27d571669233aa06255628fc4">More...</a><br /></td></tr>
<tr class="separator:afa6b63a27d571669233aa06255628fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b361442b007be017d62301d726ef3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a42b361442b007be017d62301d726ef3e">is_data_up_to_date</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx)</td></tr>
<tr class="memdesc:a42b361442b007be017d62301d726ef3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the data of this buffer is up-to-date in a certain context.  <a href="group__data.html#a42b361442b007be017d62301d726ef3e">More...</a><br /></td></tr>
<tr class="separator:a42b361442b007be017d62301d726ef3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae652de9b841f564c285311373fa96563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae652de9b841f564c285311373fa96563">is_cached</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx)</td></tr>
<tr class="memdesc:ae652de9b841f564c285311373fa96563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the buffer is already cached for a certain context.  <a href="group__data.html#ae652de9b841f564c285311373fa96563">More...</a><br /></td></tr>
<tr class="separator:ae652de9b841f564c285311373fa96563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31930d97b31c40b843a1de541060cc24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a31930d97b31c40b843a1de541060cc24">create_in_cache</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;ctx, size_t size, cl_mem_flags flags, void *data)</td></tr>
<tr class="memdesc:a31930d97b31c40b843a1de541060cc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code>boost::compute::buffer</code> for this <code><a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a></code> in the cache and associate it with a given context.  <a href="group__data.html#a31930d97b31c40b843a1de541060cc24">More...</a><br /></td></tr>
<tr class="separator:a31930d97b31c40b843a1de541060cc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d380bc456be55b375c6b31852236c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9d380bc456be55b375c6b31852236c02">sync_with_host</a> (std::size_t size, void *data)</td></tr>
<tr class="memdesc:a9d380bc456be55b375c6b31852236c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the most up-to-date version of the data to the host if the host version is not already up-to-date.  <a href="group__data.html#a9d380bc456be55b375c6b31852236c02">More...</a><br /></td></tr>
<tr class="separator:a9d380bc456be55b375c6b31852236c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6218af1679f6e4f06ae001a36a86bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb">update_buffer_state</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;target_ctx, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a> mode, std::size_t size, void *data)</td></tr>
<tr class="memdesc:aad6218af1679f6e4f06ae001a36a86bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a transfer is requested this function is called, it will update the state of the buffer according to the context in which the accessor is created and the access mode.  <a href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb">More...</a><br /></td></tr>
<tr class="separator:aad6218af1679f6e4f06ae001a36a86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8cc10dc36264d8358faced02819899"><td class="memItemLeft" align="right" valign="top">boost::compute::buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aad8cc10dc36264d8358faced02819899">get_cl_buffer</a> (const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;<a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1context">context</a>)</td></tr>
<tr class="memdesc:aad8cc10dc36264d8358faced02819899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cl_buffer for a given context.  <a href="group__data.html#aad8cc10dc36264d8358faced02819899">More...</a><br /></td></tr>
<tr class="separator:aad8cc10dc36264d8358faced02819899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Attributes</h3></td></tr>
<tr class="memitem:a9fca0380c4d885643b67ecbc3331bb24"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">number_of_users</a></td></tr>
<tr class="separator:a9fca0380c4d885643b67ecbc3331bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6ceffab31b10a04e5630cf87d82e15"><td class="memItemLeft" align="right" valign="top">std::weak_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">latest_producer</a></td></tr>
<tr class="memdesc:a7c6ceffab31b10a04e5630cf87d82e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track the latest task to produce this buffer.  <a href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">More...</a><br /></td></tr>
<tr class="separator:a7c6ceffab31b10a04e5630cf87d82e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98b22e92161a8c1f53076193ba37b0"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">latest_producer_mutex</a></td></tr>
<tr class="memdesc:aca98b22e92161a8c1f53076193ba37b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">To protect the access to latest_producer.  <a href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">More...</a><br /></td></tr>
<tr class="separator:aca98b22e92161a8c1f53076193ba37b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b119c0884d169781464d3760cb3714"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ab7b119c0884d169781464d3760cb3714">ready</a></td></tr>
<tr class="memdesc:ab7b119c0884d169781464d3760cb3714"><td class="mdescLeft">&#160;</td><td class="mdescRight">To signal when this buffer ready.  <a href="group__data.html#ab7b119c0884d169781464d3760cb3714">More...</a><br /></td></tr>
<tr class="separator:ab7b119c0884d169781464d3760cb3714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf14f60e26326adc7c1560d2b7dd6020"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">ready_mutex</a></td></tr>
<tr class="memdesc:adf14f60e26326adc7c1560d2b7dd6020"><td class="mdescLeft">&#160;</td><td class="mdescRight">To protect the access to the condition variable.  <a href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">More...</a><br /></td></tr>
<tr class="separator:adf14f60e26326adc7c1560d2b7dd6020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dc376284def25f3e0db0895e14770f"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::promise&lt; void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a53dc376284def25f3e0db0895e14770f">notify_buffer_destructor</a></td></tr>
<tr class="memdesc:a53dc376284def25f3e0db0895e14770f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the SYCL user buffer destructor is blocking, use this to block until this buffer implementation is destroyed.  <a href="group__data.html#a53dc376284def25f3e0db0895e14770f">More...</a><br /></td></tr>
<tr class="separator:a53dc376284def25f3e0db0895e14770f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bac87bde2756bf2c7bbc175b6a9fbe"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a></td></tr>
<tr class="memdesc:a15bac87bde2756bf2c7bbc175b6a9fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">To track contexts in which the data is up-to-date.  <a href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">More...</a><br /></td></tr>
<tr class="separator:a15bac87bde2756bf2c7bbc175b6a9fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e44368d757ce1eb92ef1538ff213aef"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>, boost::compute::buffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a></td></tr>
<tr class="memdesc:a9e44368d757ce1eb92ef1538ff213aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer-side cache that keeps the <code>boost::compute::buffer</code> (and the underlying <code>cl_buffer</code> ) so that if the buffer already exists inside the same context it is not recreated.  <a href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">More...</a><br /></td></tr>
<tr class="separator:a9e44368d757ce1eb92ef1538ff213aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="ab7b11b9a72e16dbbab0401ab0dfeb14a" name="ab7b11b9a72e16dbbab0401ab0dfeb14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b11b9a72e16dbbab0401ab0dfeb14a">&#9670;&nbsp;</a></span>buffer_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">trisycl::detail::buffer_base::buffer_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a buffer base and marks the host context as the context that holds the most recent version of the data. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000154">Todo:</a></b></dt><dd>Use lazy allocation for the context tracking set </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00086">86</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   86</span>                : <a class="code hl_variable" href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">number_of_users</a> { 0 },</div>
<div class="line"><span class="lineno">   87</span>                  <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a> { <a class="code hl_class" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> {} } {}</div>
<div class="ttc" id="agroup__data_html_a15bac87bde2756bf2c7bbc175b6a9fbe"><div class="ttname"><a href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">trisycl::detail::buffer_base::fresh_ctx</a></div><div class="ttdeci">std::unordered_set&lt; trisycl::context &gt; fresh_ctx</div><div class="ttdoc">To track contexts in which the data is up-to-date.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00072">buffer_base.hpp:72</a></div></div>
<div class="ttc" id="agroup__data_html_a9fca0380c4d885643b67ecbc3331bb24"><div class="ttname"><a href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">trisycl::detail::buffer_base::number_of_users</a></div><div class="ttdeci">std::atomic&lt; size_t &gt; number_of_users</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00052">buffer_base.hpp:52</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a775086e6f28f56d4a76879b09562bc7c" name="a775086e6f28f56d4a76879b09562bc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775086e6f28f56d4a76879b09562bc7c">&#9670;&nbsp;</a></span>~buffer_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">trisycl::detail::buffer_base::~buffer_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor waits for not being used anymore. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00091">91</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   91</span>                 {</div>
<div class="line"><span class="lineno">   92</span>    <a class="code hl_function" href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72">wait</a>();</div>
<div class="line"><span class="lineno">   93</span>    <span class="comment">// If there is the last SYCL user buffer waiting, notify it</span></div>
<div class="line"><span class="lineno">   94</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="group__data.html#a53dc376284def25f3e0db0895e14770f">notify_buffer_destructor</a>)</div>
<div class="line"><span class="lineno">   95</span>      <a class="code hl_variable" href="group__data.html#a53dc376284def25f3e0db0895e14770f">notify_buffer_destructor</a>-&gt;set_value();</div>
<div class="line"><span class="lineno">   96</span>  }</div>
<div class="ttc" id="agroup__data_html_a6c75ff99123dc8dd4eca7dc5dc446d72"><div class="ttname"><a href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72">trisycl::detail::buffer_base::wait</a></div><div class="ttdeci">void wait()</div><div class="ttdoc">Wait for this buffer to be ready, which is no longer in use.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00100">buffer_base.hpp:100</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00069">notify_buffer_destructor</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00100">wait()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a775086e6f28f56d4a76879b09562bc7c_cgraph.png" border="0" usemap="#agroup__data_a775086e6f28f56d4a76879b09562bc7c_cgraph" alt=""/></div>
<map name="agroup__data_a775086e6f28f56d4a76879b09562bc7c_cgraph" id="agroup__data_a775086e6f28f56d4a76879b09562bc7c_cgraph">
<area shape="rect" title="The destructor waits for not being used anymore." alt="" coords="5,5,147,47"/>
<area shape="rect" href="group__data.html#a6c75ff99123dc8dd4eca7dc5dc446d72" title="Wait for this buffer to be ready, which is no longer in use." alt="" coords="195,5,332,47"/>
</map>
</div>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="afa6b63a27d571669233aa06255628fc4" name="afa6b63a27d571669233aa06255628fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6b63a27d571669233aa06255628fc4">&#9670;&nbsp;</a></span>add_to_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; trisycl::detail::buffer_base::add_to_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *&#160;</td>
          <td class="paramname"><em>command_group_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_write_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a buffer to the task running the command group. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00153">153</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  153</span>                                                                  {</div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="group__data.html#gaae79251ae2eb2eb3f5f1418acf0f1c2f">add_buffer_to_task</a>(command_group_handler,</div>
<div class="line"><span class="lineno">  155</span>                              shared_from_this(),</div>
<div class="line"><span class="lineno">  156</span>                              is_write_mode);</div>
<div class="line"><span class="lineno">  157</span>  }</div>
<div class="ttc" id="agroup__data_html_gaae79251ae2eb2eb3f5f1418acf0f1c2f"><div class="ttname"><a href="group__data.html#gaae79251ae2eb2eb3f5f1418acf0f1c2f">trisycl::detail::add_buffer_to_task</a></div><div class="ttdeci">static std::shared_ptr&lt; detail::task &gt; add_buffer_to_task(handler *command_group_handler, std::shared_ptr&lt; detail::buffer_base &gt; b, bool is_write_mode)</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="group__data.html#gaae79251ae2eb2eb3f5f1418acf0f1c2f">trisycl::detail::add_buffer_to_task()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_afa6b63a27d571669233aa06255628fc4_cgraph.png" border="0" usemap="#agroup__data_afa6b63a27d571669233aa06255628fc4_cgraph" alt=""/></div>
<map name="agroup__data_afa6b63a27d571669233aa06255628fc4_cgraph" id="agroup__data_afa6b63a27d571669233aa06255628fc4_cgraph">
<area shape="rect" title="Add a buffer to the task running the command group." alt="" coords="5,5,143,47"/>
<area shape="rect" href="group__data.html#gaae79251ae2eb2eb3f5f1418acf0f1c2f" title=" " alt="" coords="191,5,316,47"/>
</map>
</div>

</div>
</div>
<a id="a31930d97b31c40b843a1de541060cc24" name="a31930d97b31c40b843a1de541060cc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31930d97b31c40b843a1de541060cc24">&#9670;&nbsp;</a></span>create_in_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::buffer_base::create_in_cache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_mem_flags&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code>boost::compute::buffer</code> for this <code><a class="el" href="group__data.html#classtrisycl_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">trisycl::buffer</a></code> in the cache and associate it with a given context. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00176">176</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  177</span>                                                       {</div>
<div class="line"><span class="lineno">  178</span>    <a class="code hl_variable" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a>[ctx] = <a class="code hl_function" href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d">boost::compute::buffer</a></div>
<div class="line"><span class="lineno">  179</span>      { ctx.<a class="code hl_function" href="group__execution.html#a2b662a3ac592ec2e32d98867755df76a">get_boost_compute</a>(),</div>
<div class="line"><span class="lineno">  180</span>        size,</div>
<div class="line"><span class="lineno">  181</span>        flags,</div>
<div class="line"><span class="lineno">  182</span>        data</div>
<div class="line"><span class="lineno">  183</span>      };</div>
<div class="line"><span class="lineno">  184</span>  }</div>
<div class="ttc" id="agroup__data_html_a9e44368d757ce1eb92ef1538ff213aef"><div class="ttname"><a href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">trisycl::detail::buffer_base::buffer_cache</a></div><div class="ttdeci">std::unordered_map&lt; trisycl::context, boost::compute::buffer &gt; buffer_cache</div><div class="ttdoc">Buffer-side cache that keeps the boost::compute::buffer (and the underlying cl_buffer ) so that if th...</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00079">buffer_base.hpp:79</a></div></div>
<div class="ttc" id="agroup__data_html_gacb39bd9d956d552c0a7b811158d6c31d"><div class="ttname"><a href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d">trisycl::buffer</a></div><div class="ttdeci">buffer(FIB begin, FIE end) -&gt; buffer&lt; typename std::iterator_traits&lt; FIB &gt;::value_type, 1 &gt;</div><div class="ttdoc">A deduction guide to infer the buffer type from the read-write forward iterators into a copy-in on co...</div></div>
<div class="ttc" id="agroup__execution_html_a2b662a3ac592ec2e32d98867755df76a"><div class="ttname"><a href="group__execution.html#a2b662a3ac592ec2e32d98867755df76a">trisycl::context::get_boost_compute</a></div><div class="ttdeci">boost::compute::context &amp; get_boost_compute() const</div><div class="ttdoc">Return the underlying boost::compute::context of the trisycl::context.</div><div class="ttdef"><b>Definition:</b> <a href="context_8hpp_source.html#l00165">context.hpp:165</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d">trisycl::buffer()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00079">buffer_cache</a>, and <a class="el" href="context_8hpp_source.html#l00165">trisycl::context::get_boost_compute()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00208">update_buffer_state()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a31930d97b31c40b843a1de541060cc24_cgraph.png" border="0" usemap="#agroup__data_a31930d97b31c40b843a1de541060cc24_cgraph" alt=""/></div>
<map name="agroup__data_a31930d97b31c40b843a1de541060cc24_cgraph" id="agroup__data_a31930d97b31c40b843a1de541060cc24_cgraph">
<area shape="rect" title="Create a boost::compute::buffer for this trisycl::buffer in the cache and associate it with a given c..." alt="" coords="5,27,165,69"/>
<area shape="rect" href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d" title="A deduction guide to infer the buffer type from the read&#45;write forward iterators into a copy&#45;in on co..." alt="" coords="231,5,330,32"/>
<area shape="rect" href="group__execution.html#a2b662a3ac592ec2e32d98867755df76a" title="Return the underlying boost::compute::context of the trisycl::context." alt="" coords="213,57,348,98"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a31930d97b31c40b843a1de541060cc24_icgraph.png" border="0" usemap="#agroup__data_a31930d97b31c40b843a1de541060cc24_icgraph" alt=""/></div>
<map name="agroup__data_a31930d97b31c40b843a1de541060cc24_icgraph" id="agroup__data_a31930d97b31c40b843a1de541060cc24_icgraph">
<area shape="rect" title="Create a boost::compute::buffer for this trisycl::buffer in the cache and associate it with a given c..." alt="" coords="233,5,393,47"/>
<area shape="rect" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb" title="When a transfer is requested this function is called, it will update the state of the buffer accordin..." alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="aad8cc10dc36264d8358faced02819899" name="aad8cc10dc36264d8358faced02819899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8cc10dc36264d8358faced02819899">&#9670;&nbsp;</a></span>get_cl_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::buffer trisycl::detail::buffer_base::get_cl_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cl_buffer for a given context. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00312">312</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  312</span>                                                                  {</div>
<div class="line"><span class="lineno">  313</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a>[<a class="code hl_enumeration" href="group__execution.html#ga7a94e9d7533e927f501e3844d05a7e27">context</a>];</div>
<div class="line"><span class="lineno">  314</span>  }</div>
<div class="ttc" id="agroup__execution_html_ga7a94e9d7533e927f501e3844d05a7e27"><div class="ttname"><a href="group__execution.html#ga7a94e9d7533e927f501e3844d05a7e27">trisycl::info::context</a></div><div class="ttdeci">context</div><div class="ttdoc">Context information descriptors.</div><div class="ttdef"><b>Definition:</b> <a href="info_2context_8hpp_source.html#l00025">context.hpp:25</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00079">buffer_cache</a>.</p>

</div>
</div>
<a id="a20f103aa2bb2c90ab2932c1abe0daaac" name="a20f103aa2bb2c90ab2932c1abe0daaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f103aa2bb2c90ab2932c1abe0daaac">&#9670;&nbsp;</a></span>get_latest_producer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; trisycl::detail::buffer_base::get_latest_producer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the latest producer for the buffer. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00130">130</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  130</span>                                                  {</div>
<div class="line"><span class="lineno">  131</span>    std::lock_guard&lt;std::mutex&gt; lg { <a class="code hl_variable" href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">latest_producer_mutex</a> };</div>
<div class="line"><span class="lineno">  132</span>    <span class="comment">// Return the valid shared_ptr to the task, if any</span></div>
<div class="line"><span class="lineno">  133</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">latest_producer</a>.lock();</div>
<div class="line"><span class="lineno">  134</span>  }</div>
<div class="ttc" id="agroup__data_html_a7c6ceffab31b10a04e5630cf87d82e15"><div class="ttname"><a href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">trisycl::detail::buffer_base::latest_producer</a></div><div class="ttdeci">std::weak_ptr&lt; detail::task &gt; latest_producer</div><div class="ttdoc">Track the latest task to produce this buffer.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00055">buffer_base.hpp:55</a></div></div>
<div class="ttc" id="agroup__data_html_aca98b22e92161a8c1f53076193ba37b0"><div class="ttname"><a href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">trisycl::detail::buffer_base::latest_producer_mutex</a></div><div class="ttdeci">std::mutex latest_producer_mutex</div><div class="ttdoc">To protect the access to latest_producer.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00057">buffer_base.hpp:57</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00055">latest_producer</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00057">latest_producer_mutex</a>.</p>

</div>
</div>
<a id="ae652de9b841f564c285311373fa96563" name="ae652de9b841f564c285311373fa96563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae652de9b841f564c285311373fa96563">&#9670;&nbsp;</a></span>is_cached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> trisycl::detail::buffer_base::is_cached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the buffer is already cached for a certain context. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00168">168</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  168</span>                                            {</div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a>.count(ctx);</div>
<div class="line"><span class="lineno">  170</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00079">buffer_cache</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00208">update_buffer_state()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_ae652de9b841f564c285311373fa96563_icgraph.png" border="0" usemap="#agroup__data_ae652de9b841f564c285311373fa96563_icgraph" alt=""/></div>
<map name="agroup__data_ae652de9b841f564c285311373fa96563_icgraph" id="agroup__data_ae652de9b841f564c285311373fa96563_icgraph">
<area shape="rect" title="Check if the buffer is already cached for a certain context." alt="" coords="233,5,371,47"/>
<area shape="rect" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb" title="When a transfer is requested this function is called, it will update the state of the buffer accordin..." alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="a42b361442b007be017d62301d726ef3e" name="a42b361442b007be017d62301d726ef3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b361442b007be017d62301d726ef3e">&#9670;&nbsp;</a></span>is_data_up_to_date()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> trisycl::detail::buffer_base::is_data_up_to_date </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the data of this buffer is up-to-date in a certain context. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00162">162</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  162</span>                                                     {</div>
<div class="line"><span class="lineno">  163</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.count(ctx);</div>
<div class="line"><span class="lineno">  164</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00072">fresh_ctx</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00190">sync_with_host()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00208">update_buffer_state()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a42b361442b007be017d62301d726ef3e_icgraph.png" border="0" usemap="#agroup__data_a42b361442b007be017d62301d726ef3e_icgraph" alt=""/></div>
<map name="agroup__data_a42b361442b007be017d62301d726ef3e_icgraph" id="agroup__data_a42b361442b007be017d62301d726ef3e_icgraph">
<area shape="rect" title="Check if the data of this buffer is up&#45;to&#45;date in a certain context." alt="" coords="437,35,616,76"/>
<area shape="rect" href="group__data.html#a9d380bc456be55b375c6b31852236c02" title="Transfer the most up&#45;to&#45;date version of the data to the host if the host version is not already up&#45;to..." alt="" coords="233,5,389,47"/>
<area shape="rect" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb" title="When a transfer is requested this function is called, it will update the state of the buffer accordin..." alt="" coords="5,35,185,76"/>
</map>
</div>

</div>
</div>
<a id="a859472c44cb2df3b882340892b962e2b" name="a859472c44cb2df3b882340892b962e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859472c44cb2df3b882340892b962e2b">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::buffer_base::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A task has released the buffer. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00117">117</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  117</span>                 {</div>
<div class="line"><span class="lineno">  118</span>    std::unique_lock&lt;std::mutex&gt; lock { <a class="code hl_variable" href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">ready_mutex</a> };</div>
<div class="line"><span class="lineno">  119</span>    <span class="keywordflow">if</span> (--<a class="code hl_variable" href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">number_of_users</a> == 0) {</div>
<div class="line"><span class="lineno">  120</span>      <span class="comment">// Micro-optimization: unlock before the notification</span></div>
<div class="line"><span class="lineno">  121</span>      <span class="comment">// https://en.cppreference.com/w/cpp/thread/condition_variable/notify_all</span></div>
<div class="line"><span class="lineno">  122</span>      lock.unlock();</div>
<div class="line"><span class="lineno">  123</span>      <span class="comment">// Notify the host consumers or the buffer destructor that it is ready</span></div>
<div class="line"><span class="lineno">  124</span>      <a class="code hl_variable" href="group__data.html#ab7b119c0884d169781464d3760cb3714">ready</a>.notify_all();</div>
<div class="line"><span class="lineno">  125</span>    }</div>
<div class="line"><span class="lineno">  126</span>  }</div>
<div class="ttc" id="agroup__data_html_ab7b119c0884d169781464d3760cb3714"><div class="ttname"><a href="group__data.html#ab7b119c0884d169781464d3760cb3714">trisycl::detail::buffer_base::ready</a></div><div class="ttdeci">std::condition_variable ready</div><div class="ttdoc">To signal when this buffer ready.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00060">buffer_base.hpp:60</a></div></div>
<div class="ttc" id="agroup__data_html_adf14f60e26326adc7c1560d2b7dd6020"><div class="ttname"><a href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">trisycl::detail::buffer_base::ready_mutex</a></div><div class="ttdeci">std::mutex ready_mutex</div><div class="ttdoc">To protect the access to the condition variable.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00062">buffer_base.hpp:62</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00052">number_of_users</a>, <a class="el" href="buffer__base_8hpp_source.html#l00060">ready</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00062">ready_mutex</a>.</p>

</div>
</div>
<a id="a18d93e1925b952a630223550d29da754" name="a18d93e1925b952a630223550d29da754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d93e1925b952a630223550d29da754">&#9670;&nbsp;</a></span>set_latest_producer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; trisycl::detail::buffer_base::set_latest_producer </td>
          <td>(</td>
          <td class="paramtype">std::weak_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td>
          <td class="paramname"><em>newer_latest_producer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the latest producer for the buffer and set another future producer. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00141">141</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  141</span>                                                                     {</div>
<div class="line"><span class="lineno">  142</span>    std::lock_guard&lt;std::mutex&gt; lg { <a class="code hl_variable" href="group__data.html#aca98b22e92161a8c1f53076193ba37b0">latest_producer_mutex</a> };</div>
<div class="line"><span class="lineno">  143</span>    <span class="keyword">using </span>std::swap;</div>
<div class="line"><span class="lineno">  144</span> </div>
<div class="line"><span class="lineno">  145</span>    swap(newer_latest_producer, <a class="code hl_variable" href="group__data.html#a7c6ceffab31b10a04e5630cf87d82e15">latest_producer</a>);</div>
<div class="line"><span class="lineno">  146</span>    <span class="comment">// Return the valid shared_ptr to the previous producing task, if any</span></div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">return</span> newer_latest_producer.lock();</div>
<div class="line"><span class="lineno">  148</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00055">latest_producer</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00057">latest_producer_mutex</a>.</p>

</div>
</div>
<a id="a9d380bc456be55b375c6b31852236c02" name="a9d380bc456be55b375c6b31852236c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d380bc456be55b375c6b31852236c02">&#9670;&nbsp;</a></span>sync_with_host()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::buffer_base::sync_with_host </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the most up-to-date version of the data to the host if the host version is not already up-to-date. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00190">190</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  190</span>                                                  {</div>
<div class="line"><span class="lineno">  191</span>    <a class="code hl_class" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> host_context;</div>
<div class="line"><span class="lineno">  192</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="group__data.html#a42b361442b007be017d62301d726ef3e">is_data_up_to_date</a>(host_context) &amp;&amp; !<a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.empty()) {</div>
<div class="line"><span class="lineno">  193</span>      <span class="comment">/* We know that the context(s) in \c fresh_ctx hold the most recent</span></div>
<div class="line"><span class="lineno">  194</span><span class="comment">         version of the buffer</span></div>
<div class="line"><span class="lineno">  195</span><span class="comment">      */</span></div>
<div class="line"><span class="lineno">  196</span>      <span class="keyword">auto</span> fresh_context = *(<a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.begin());</div>
<div class="line"><span class="lineno">  197</span>      <span class="keyword">auto</span> fresh_q = fresh_context.<a class="code hl_function" href="group__execution.html#ab7e1fe9395e93fbcbf0cb7883046cd7f">get_boost_queue</a>();</div>
<div class="line"><span class="lineno">  198</span>      fresh_q.enqueue_read_buffer(<a class="code hl_variable" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a>[fresh_context], 0, size, data);</div>
<div class="line"><span class="lineno">  199</span>      <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.insert(host_context);</div>
<div class="line"><span class="lineno">  200</span>    }</div>
<div class="line"><span class="lineno">  201</span>  }</div>
<div class="ttc" id="agroup__data_html_a42b361442b007be017d62301d726ef3e"><div class="ttname"><a href="group__data.html#a42b361442b007be017d62301d726ef3e">trisycl::detail::buffer_base::is_data_up_to_date</a></div><div class="ttdeci">bool is_data_up_to_date(const trisycl::context &amp;ctx)</div><div class="ttdoc">Check if the data of this buffer is up-to-date in a certain context.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00162">buffer_base.hpp:162</a></div></div>
<div class="ttc" id="agroup__execution_html_ab7e1fe9395e93fbcbf0cb7883046cd7f"><div class="ttname"><a href="group__execution.html#ab7e1fe9395e93fbcbf0cb7883046cd7f">trisycl::context::get_boost_queue</a></div><div class="ttdeci">boost::compute::command_queue &amp; get_boost_queue() const</div><div class="ttdoc">Return the internal queue that is associated to the context and used by triSYCL to move data between ...</div><div class="ttdef"><b>Definition:</b> <a href="context_8hpp_source.html#l00173">context.hpp:173</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00079">buffer_cache</a>, <a class="el" href="buffer__base_8hpp_source.html#l00072">fresh_ctx</a>, <a class="el" href="host__context_8hpp_source.html#l00063">trisycl::detail::host_context::get_boost_queue()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00162">is_data_up_to_date()</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00208">update_buffer_state()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a9d380bc456be55b375c6b31852236c02_cgraph.png" border="0" usemap="#agroup__data_a9d380bc456be55b375c6b31852236c02_cgraph" alt=""/></div>
<map name="agroup__data_a9d380bc456be55b375c6b31852236c02_cgraph" id="agroup__data_a9d380bc456be55b375c6b31852236c02_cgraph">
<area shape="rect" title="Transfer the most up&#45;to&#45;date version of the data to the host if the host version is not already up&#45;to..." alt="" coords="5,39,161,80"/>
<area shape="rect" href="group__execution.html#a770c8507039a7650fe4d6b98c12246da" title="Return the internal OpenCL queue that is associated to the host context." alt="" coords="209,5,388,47"/>
<area shape="rect" href="group__data.html#a42b361442b007be017d62301d726ef3e" title="Check if the data of this buffer is up&#45;to&#45;date in a certain context." alt="" coords="209,71,388,112"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a9d380bc456be55b375c6b31852236c02_icgraph.png" border="0" usemap="#agroup__data_a9d380bc456be55b375c6b31852236c02_icgraph" alt=""/></div>
<map name="agroup__data_a9d380bc456be55b375c6b31852236c02_icgraph" id="agroup__data_a9d380bc456be55b375c6b31852236c02_icgraph">
<area shape="rect" title="Transfer the most up&#45;to&#45;date version of the data to the host if the host version is not already up&#45;to..." alt="" coords="233,5,389,47"/>
<area shape="rect" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb" title="When a transfer is requested this function is called, it will update the state of the buffer accordin..." alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="aad6218af1679f6e4f06ae001a36a86bb" name="aad6218af1679f6e4f06ae001a36a86bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6218af1679f6e4f06ae001a36a86bb">&#9670;&nbsp;</a></span>update_buffer_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::buffer_base::update_buffer_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a> &amp;&#160;</td>
          <td class="paramname"><em>target_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">access::mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When a transfer is requested this function is called, it will update the state of the buffer according to the context in which the accessor is created and the access mode. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00208">208</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  209</span>                                                                        {</div>
<div class="line"><span class="lineno">  210</span>    <span class="comment">/* The \c cl_buffer we put in the cache might get accessed again in the</span></div>
<div class="line"><span class="lineno">  211</span><span class="comment">       future, this means that we have to always to create it in read/write</span></div>
<div class="line"><span class="lineno">  212</span><span class="comment">       mode to be able to write to it if it is accessed through a</span></div>
<div class="line"><span class="lineno">  213</span><span class="comment">       write accessor in the future</span></div>
<div class="line"><span class="lineno">  214</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  215</span>    <span class="keyword">auto</span> <span class="keyword">constexpr</span> flag = CL_MEM_READ_WRITE;</div>
<div class="line"><span class="lineno">  216</span> </div>
<div class="line"><span class="lineno">  217</span>    <span class="comment">/* The buffer is accessed in read mode, we want to transfer the data only if</span></div>
<div class="line"><span class="lineno">  218</span><span class="comment">       necessary. We start a transfer if the data on the target context is not</span></div>
<div class="line"><span class="lineno">  219</span><span class="comment">       up to date and then update the fresh context set.</span></div>
<div class="line"><span class="lineno">  220</span><span class="comment">     */</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">if</span> (<a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a> == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a>) {</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="group__data.html#a42b361442b007be017d62301d726ef3e">is_data_up_to_date</a>(target_ctx))</div>
<div class="line"><span class="lineno">  224</span>        <span class="comment">// If read mode and the data is up-to-date there is nothing to do</span></div>
<div class="line"><span class="lineno">  225</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span>      <span class="comment">// The data is not up-to-date, we need a transfer</span></div>
<div class="line"><span class="lineno">  228</span>      <span class="comment">// We also want to be sure that the host holds the most recent data</span></div>
<div class="line"><span class="lineno">  229</span>      <a class="code hl_function" href="group__data.html#a9d380bc456be55b375c6b31852236c02">sync_with_host</a>(size, data);</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span>      <span class="keywordflow">if</span> (!target_ctx.<a class="code hl_function" href="group__execution.html#a5cb11be9fe698ee1e6e44df9ea0e9e04">is_host</a>()) {</div>
<div class="line"><span class="lineno">  232</span>        <span class="comment">// If the target context is a device context</span></div>
<div class="line"><span class="lineno">  233</span>        <span class="keywordflow">if</span> (!<a class="code hl_function" href="group__data.html#ae652de9b841f564c285311373fa96563">is_cached</a>(target_ctx)) {</div>
<div class="line"><span class="lineno">  234</span>          <span class="comment">/* If not cached, we create the buffer and copy the data</span></div>
<div class="line"><span class="lineno">  235</span><span class="comment">             at the same time</span></div>
<div class="line"><span class="lineno">  236</span><span class="comment">          */</span></div>
<div class="line"><span class="lineno">  237</span>          <a class="code hl_function" href="group__data.html#a31930d97b31c40b843a1de541060cc24">create_in_cache</a>(target_ctx, size,</div>
<div class="line"><span class="lineno">  238</span>                          (flag | CL_MEM_COPY_HOST_PTR), data);</div>
<div class="line"><span class="lineno">  239</span>          <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.insert(target_ctx);</div>
<div class="line"><span class="lineno">  240</span>          <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  241</span>        }</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>        <span class="comment">/* Else we transfer the data to the existing buffer associated</span></div>
<div class="line"><span class="lineno">  244</span><span class="comment">           with the target context buffer</span></div>
<div class="line"><span class="lineno">  245</span><span class="comment">        */</span></div>
<div class="line"><span class="lineno">  246</span>        <span class="keyword">auto</span> q = target_ctx.<a class="code hl_function" href="group__execution.html#ab7e1fe9395e93fbcbf0cb7883046cd7f">get_boost_queue</a>();</div>
<div class="line"><span class="lineno">  247</span>        q.enqueue_write_buffer(<a class="code hl_variable" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a>[target_ctx], 0, size, data);</div>
<div class="line"><span class="lineno">  248</span>        <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.insert(target_ctx);</div>
<div class="line"><span class="lineno">  249</span>      }</div>
<div class="line"><span class="lineno">  250</span>      <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  251</span>    }</div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span>    <span class="comment">/* The buffer might be written to, this means that we have to consider</span></div>
<div class="line"><span class="lineno">  254</span><span class="comment">       every version of the data obsolete except in the target context</span></div>
<div class="line"><span class="lineno">  255</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="comment">       We go through the same process as in read mode but in addition</span></div>
<div class="line"><span class="lineno">  257</span><span class="comment">       we empty the fresh context set and just add the target context</span></div>
<div class="line"><span class="lineno">  258</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  259</span><span class="comment">       If the data is up to date on the target we just have to update</span></div>
<div class="line"><span class="lineno">  260</span><span class="comment">       the context set and nothing else</span></div>
<div class="line"><span class="lineno">  261</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="group__data.html#a42b361442b007be017d62301d726ef3e">is_data_up_to_date</a>(target_ctx)) {</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>      <span class="keywordflow">if</span> (   <a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a> == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">access::mode::read_write</a></div>
<div class="line"><span class="lineno">  265</span>          || <a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a> == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">access::mode::write</a></div>
<div class="line"><span class="lineno">  266</span>          || <a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a> == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca23d33884d600e542d097cd3933df2ae4">access::mode::atomic</a>) {</div>
<div class="line"><span class="lineno">  267</span>        <span class="comment">// If the data is not up-to-date in the target context</span></div>
<div class="line"><span class="lineno">  268</span>        <span class="comment">// We want to host to be up-to-date</span></div>
<div class="line"><span class="lineno">  269</span>        <a class="code hl_function" href="group__data.html#a9d380bc456be55b375c6b31852236c02">sync_with_host</a>(size, data);</div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span>        <span class="keywordflow">if</span> (!target_ctx.<a class="code hl_function" href="group__execution.html#a5cb11be9fe698ee1e6e44df9ea0e9e04">is_host</a>()) {</div>
<div class="line"><span class="lineno">  272</span>          <span class="comment">// If the target context is a device context</span></div>
<div class="line"><span class="lineno">  273</span>          <span class="keywordflow">if</span> (!<a class="code hl_function" href="group__data.html#ae652de9b841f564c285311373fa96563">is_cached</a>(target_ctx)) {</div>
<div class="line"><span class="lineno">  274</span>            <a class="code hl_function" href="group__data.html#a31930d97b31c40b843a1de541060cc24">create_in_cache</a>(target_ctx, size,</div>
<div class="line"><span class="lineno">  275</span>                            (flag | CL_MEM_COPY_HOST_PTR), data);</div>
<div class="line"><span class="lineno">  276</span>          }</div>
<div class="line"><span class="lineno">  277</span>          <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  278</span>            <span class="comment">// We update the buffer associated with the target context</span></div>
<div class="line"><span class="lineno">  279</span>            <span class="keyword">auto</span> q = target_ctx.<a class="code hl_function" href="group__execution.html#ab7e1fe9395e93fbcbf0cb7883046cd7f">get_boost_queue</a>();</div>
<div class="line"><span class="lineno">  280</span>            q.enqueue_write_buffer(<a class="code hl_variable" href="group__data.html#a9e44368d757ce1eb92ef1538ff213aef">buffer_cache</a>[target_ctx], 0, size, data);</div>
<div class="line"><span class="lineno">  281</span>          }</div>
<div class="line"><span class="lineno">  282</span>        }</div>
<div class="line"><span class="lineno">  283</span>      }</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>      <span class="comment">/* When in discard mode we don&#39;t need to transfer any data, we just create</span></div>
<div class="line"><span class="lineno">  286</span><span class="comment">         the \c cl_buffer if it doesn&#39;t exist in the cache</span></div>
<div class="line"><span class="lineno">  287</span><span class="comment">      */</span></div>
<div class="line"><span class="lineno">  288</span>      <span class="keywordflow">if</span> (   <a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a> == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">access::mode::discard_write</a></div>
<div class="line"><span class="lineno">  289</span>          || <a class="code hl_enumeration" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297c">mode</a> == <a class="code hl_enumvalue" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">access::mode::discard_read_write</a>) {</div>
<div class="line"><span class="lineno">  290</span>        <span class="comment">/* We only need to create the buffer if it doesn&#39;t exist</span></div>
<div class="line"><span class="lineno">  291</span><span class="comment">           but without copying any data because of the discard mode</span></div>
<div class="line"><span class="lineno">  292</span><span class="comment">        */</span></div>
<div class="line"><span class="lineno">  293</span>        <span class="keywordflow">if</span> (!target_ctx.<a class="code hl_function" href="group__execution.html#a5cb11be9fe698ee1e6e44df9ea0e9e04">is_host</a>() &amp;&amp; !<a class="code hl_function" href="group__data.html#ae652de9b841f564c285311373fa96563">is_cached</a>(target_ctx)) {</div>
<div class="line"><span class="lineno">  294</span>          <span class="comment">// If the context doesn&#39;t exist we create it.</span></div>
<div class="line"><span class="lineno">  295</span>          <span class="comment">/* We don&#39;t want to transfer any data so we don&#39;t</span></div>
<div class="line"><span class="lineno">  296</span><span class="comment">             add \c CL_MEM_COPY_HOST_PTR</span></div>
<div class="line"><span class="lineno">  297</span><span class="comment">          */</span></div>
<div class="line"><span class="lineno">  298</span>          <a class="code hl_function" href="group__data.html#a31930d97b31c40b843a1de541060cc24">create_in_cache</a>(target_ctx, size, flag, 0);</div>
<div class="line"><span class="lineno">  299</span>        }</div>
<div class="line"><span class="lineno">  300</span>      }</div>
<div class="line"><span class="lineno">  301</span>    }</div>
<div class="line"><span class="lineno">  302</span>    <span class="comment">/* Here we are sure that we are in some kind of write mode,</span></div>
<div class="line"><span class="lineno">  303</span><span class="comment">       we indicate that all contexts except the target context</span></div>
<div class="line"><span class="lineno">  304</span><span class="comment">       are not up-to-date anymore</span></div>
<div class="line"><span class="lineno">  305</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  306</span>    <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.clear();</div>
<div class="line"><span class="lineno">  307</span>    <a class="code hl_variable" href="group__data.html#a15bac87bde2756bf2c7bbc175b6a9fbe">fresh_ctx</a>.insert(target_ctx);</div>
<div class="line"><span class="lineno">  308</span>  }</div>
<div class="ttc" id="agroup__data_html_a31930d97b31c40b843a1de541060cc24"><div class="ttname"><a href="group__data.html#a31930d97b31c40b843a1de541060cc24">trisycl::detail::buffer_base::create_in_cache</a></div><div class="ttdeci">void create_in_cache(const trisycl::context &amp;ctx, size_t size, cl_mem_flags flags, void *data)</div><div class="ttdoc">Create a boost::compute::buffer for this trisycl::buffer in the cache and associate it with a given c...</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00176">buffer_base.hpp:176</a></div></div>
<div class="ttc" id="agroup__data_html_a9d380bc456be55b375c6b31852236c02"><div class="ttname"><a href="group__data.html#a9d380bc456be55b375c6b31852236c02">trisycl::detail::buffer_base::sync_with_host</a></div><div class="ttdeci">void sync_with_host(std::size_t size, void *data)</div><div class="ttdoc">Transfer the most up-to-date version of the data to the host if the host version is not already up-to...</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00190">buffer_base.hpp:190</a></div></div>
<div class="ttc" id="agroup__data_html_ae652de9b841f564c285311373fa96563"><div class="ttname"><a href="group__data.html#ae652de9b841f564c285311373fa96563">trisycl::detail::buffer_base::is_cached</a></div><div class="ttdeci">bool is_cached(const trisycl::context &amp;ctx)</div><div class="ttdoc">Check if the buffer is already cached for a certain context.</div><div class="ttdef"><b>Definition:</b> <a href="buffer__base_8hpp_source.html#l00168">buffer_base.hpp:168</a></div></div>
<div class="ttc" id="agroup__execution_html_a5cb11be9fe698ee1e6e44df9ea0e9e04"><div class="ttname"><a href="group__execution.html#a5cb11be9fe698ee1e6e44df9ea0e9e04">trisycl::context::is_host</a></div><div class="ttdeci">bool is_host() const</div><div class="ttdoc">Specifies whether the context is in SYCL Host Execution Mode.</div><div class="ttdef"><b>Definition:</b> <a href="context_8hpp_source.html#l00180">context.hpp:180</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca23d33884d600e542d097cd3933df2ae4">trisycl::access::atomic</a>, <a class="el" href="buffer__base_8hpp_source.html#l00079">buffer_cache</a>, <a class="el" href="buffer__base_8hpp_source.html#l00176">create_in_cache()</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca5521dbab91d3894807c5ad7e84e14f4b">trisycl::access::discard_read_write</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caf0d9952b32031a9b0c9606400dff53f9">trisycl::access::discard_write</a>, <a class="el" href="buffer__base_8hpp_source.html#l00072">fresh_ctx</a>, <a class="el" href="context_8hpp_source.html#l00173">trisycl::context::get_boost_queue()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00168">is_cached()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00162">is_data_up_to_date()</a>, <a class="el" href="context_8hpp_source.html#l00180">trisycl::context::is_host()</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caecae13117d6f0584c25a9da6c8f8415e">trisycl::access::read</a>, <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297ca06ad287ea83b37a6f9db3d8d10d72c8f">trisycl::access::read_write</a>, <a class="el" href="buffer__base_8hpp_source.html#l00190">sync_with_host()</a>, and <a class="el" href="namespacetrisycl_1_1access.html#a2ee71c8ee80896e782636c805fab297caefb2a684e4afb7d55e6147fbe5a332ee">trisycl::access::write</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_aad6218af1679f6e4f06ae001a36a86bb_cgraph.png" border="0" usemap="#agroup__data_aad6218af1679f6e4f06ae001a36a86bb_cgraph" alt=""/></div>
<map name="agroup__data_aad6218af1679f6e4f06ae001a36a86bb_cgraph" id="agroup__data_aad6218af1679f6e4f06ae001a36a86bb_cgraph">
<area shape="rect" title="When a transfer is requested this function is called, it will update the state of the buffer accordin..." alt="" coords="5,187,185,229"/>
<area shape="rect" href="group__data.html#a31930d97b31c40b843a1de541060cc24" title="Create a boost::compute::buffer for this trisycl::buffer in the cache and associate it with a given c..." alt="" coords="233,27,393,69"/>
<area shape="rect" href="group__execution.html#ab7e1fe9395e93fbcbf0cb7883046cd7f" title="Return the internal queue that is associated to the context and used by triSYCL to move data between ..." alt="" coords="246,93,381,134"/>
<area shape="rect" href="group__data.html#ae652de9b841f564c285311373fa96563" title="Check if the buffer is already cached for a certain context." alt="" coords="245,158,382,199"/>
<area shape="rect" href="group__data.html#a42b361442b007be017d62301d726ef3e" title="Check if the data of this buffer is up&#45;to&#45;date in a certain context." alt="" coords="441,238,620,279"/>
<area shape="rect" href="group__execution.html#a5cb11be9fe698ee1e6e44df9ea0e9e04" title="Specifies whether the context is in SYCL Host Execution Mode." alt="" coords="234,275,393,301"/>
<area shape="rect" href="group__data.html#a9d380bc456be55b375c6b31852236c02" title="Transfer the most up&#45;to&#45;date version of the data to the host if the host version is not already up&#45;to..." alt="" coords="235,326,391,367"/>
<area shape="rect" href="group__data.html#gacb39bd9d956d552c0a7b811158d6c31d" title="A deduction guide to infer the buffer type from the read&#45;write forward iterators into a copy&#45;in on co..." alt="" coords="481,5,580,32"/>
<area shape="rect" href="group__execution.html#a2b662a3ac592ec2e32d98867755df76a" title="Return the underlying boost::compute::context of the trisycl::context." alt="" coords="463,57,598,98"/>
<area shape="rect" href="group__execution.html#a770c8507039a7650fe4d6b98c12246da" title="Return the internal OpenCL queue that is associated to the host context." alt="" coords="441,326,620,367"/>
</map>
</div>

</div>
</div>
<a id="affe31d2f9f9eca682ea798abc155a90b" name="affe31d2f9f9eca682ea798abc155a90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe31d2f9f9eca682ea798abc155a90b">&#9670;&nbsp;</a></span>use()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::buffer_base::use </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark this buffer in use by a task. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00110">110</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  110</span>             {</div>
<div class="line"><span class="lineno">  111</span>    <span class="comment">// Increment the use count</span></div>
<div class="line"><span class="lineno">  112</span>    ++<a class="code hl_variable" href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">number_of_users</a>;</div>
<div class="line"><span class="lineno">  113</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00052">number_of_users</a>.</p>

</div>
</div>
<a id="a6c75ff99123dc8dd4eca7dc5dc446d72" name="a6c75ff99123dc8dd4eca7dc5dc446d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c75ff99123dc8dd4eca7dc5dc446d72">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::buffer_base::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for this buffer to be ready, which is no longer in use. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00100">100</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  100</span>              {</div>
<div class="line"><span class="lineno">  101</span>    std::unique_lock&lt;std::mutex&gt; ul { <a class="code hl_variable" href="group__data.html#adf14f60e26326adc7c1560d2b7dd6020">ready_mutex</a> };</div>
<div class="line"><span class="lineno">  102</span>    <a class="code hl_variable" href="group__data.html#ab7b119c0884d169781464d3760cb3714">ready</a>.wait(ul, [&amp;] {</div>
<div class="line"><span class="lineno">  103</span>        <span class="comment">// When there is no producer for this buffer, we are ready to use it</span></div>
<div class="line"><span class="lineno">  104</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#a9fca0380c4d885643b67ecbc3331bb24">number_of_users</a> == 0;</div>
<div class="line"><span class="lineno">  105</span>      });</div>
<div class="line"><span class="lineno">  106</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="buffer__base_8hpp_source.html#l00052">number_of_users</a>, <a class="el" href="buffer__base_8hpp_source.html#l00060">ready</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00062">ready_mutex</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00091">~buffer_base()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_a6c75ff99123dc8dd4eca7dc5dc446d72_icgraph.png" border="0" usemap="#agroup__data_a6c75ff99123dc8dd4eca7dc5dc446d72_icgraph" alt=""/></div>
<map name="agroup__data_a6c75ff99123dc8dd4eca7dc5dc446d72_icgraph" id="agroup__data_a6c75ff99123dc8dd4eca7dc5dc446d72_icgraph">
<area shape="rect" title="Wait for this buffer to be ready, which is no longer in use." alt="" coords="195,5,332,47"/>
<area shape="rect" href="group__data.html#a775086e6f28f56d4a76879b09562bc7c" title="The destructor waits for not being used anymore." alt="" coords="5,5,147,47"/>
</map>
</div>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a9e44368d757ce1eb92ef1538ff213aef" name="a9e44368d757ce1eb92ef1538ff213aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e44368d757ce1eb92ef1538ff213aef">&#9670;&nbsp;</a></span>buffer_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>, boost::compute::buffer&gt; trisycl::detail::buffer_base::buffer_cache</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer-side cache that keeps the <code>boost::compute::buffer</code> (and the underlying <code>cl_buffer</code> ) so that if the buffer already exists inside the same context it is not recreated. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00079">79</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00176">create_in_cache()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00312">get_cl_buffer()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00168">is_cached()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00190">sync_with_host()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00208">update_buffer_state()</a>.</p>

</div>
</div>
<a id="a15bac87bde2756bf2c7bbc175b6a9fbe" name="a15bac87bde2756bf2c7bbc175b6a9fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bac87bde2756bf2c7bbc175b6a9fbe">&#9670;&nbsp;</a></span>fresh_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="group__execution.html#classtrisycl_1_1context">trisycl::context</a>&gt; trisycl::detail::buffer_base::fresh_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To track contexts in which the data is up-to-date. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00072">72</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00162">is_data_up_to_date()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00190">sync_with_host()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00208">update_buffer_state()</a>.</p>

</div>
</div>
<a id="a7c6ceffab31b10a04e5630cf87d82e15" name="a7c6ceffab31b10a04e5630cf87d82e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6ceffab31b10a04e5630cf87d82e15">&#9670;&nbsp;</a></span>latest_producer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::weak_ptr&lt;<a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a>&gt; trisycl::detail::buffer_base::latest_producer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track the latest task to produce this buffer. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00055">55</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00130">get_latest_producer()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00141">set_latest_producer()</a>.</p>

</div>
</div>
<a id="aca98b22e92161a8c1f53076193ba37b0" name="aca98b22e92161a8c1f53076193ba37b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca98b22e92161a8c1f53076193ba37b0">&#9670;&nbsp;</a></span>latest_producer_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex trisycl::detail::buffer_base::latest_producer_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To protect the access to latest_producer. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00057">57</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00130">get_latest_producer()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00141">set_latest_producer()</a>.</p>

</div>
</div>
<a id="a53dc376284def25f3e0db0895e14770f" name="a53dc376284def25f3e0db0895e14770f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dc376284def25f3e0db0895e14770f">&#9670;&nbsp;</a></span>notify_buffer_destructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt;std::promise&lt;void&gt; &gt; trisycl::detail::buffer_base::notify_buffer_destructor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the SYCL user buffer destructor is blocking, use this to block until this buffer implementation is destroyed. </p>
<p >Use a void promise since there is no value to send, only waiting </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00069">69</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00091">~buffer_base()</a>.</p>

</div>
</div>
<a id="a9fca0380c4d885643b67ecbc3331bb24" name="a9fca0380c4d885643b67ecbc3331bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fca0380c4d885643b67ecbc3331bb24">&#9670;&nbsp;</a></span>number_of_users</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; trisycl::detail::buffer_base::number_of_users</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00052">52</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00117">release()</a>, <a class="el" href="buffer__base_8hpp_source.html#l00110">use()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00100">wait()</a>.</p>

</div>
</div>
<a id="ab7b119c0884d169781464d3760cb3714" name="ab7b119c0884d169781464d3760cb3714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b119c0884d169781464d3760cb3714">&#9670;&nbsp;</a></span>ready</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable trisycl::detail::buffer_base::ready</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To signal when this buffer ready. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00060">60</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00117">release()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00100">wait()</a>.</p>

</div>
</div>
<a id="adf14f60e26326adc7c1560d2b7dd6020" name="adf14f60e26326adc7c1560d2b7dd6020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf14f60e26326adc7c1560d2b7dd6020">&#9670;&nbsp;</a></span>ready_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex trisycl::detail::buffer_base::ready_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To protect the access to the condition variable. </p>

<p class="definition">Definition at line <a class="el" href="buffer__base_8hpp_source.html#l00062">62</a> of file <a class="el" href="buffer__base_8hpp_source.html">buffer_base.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00117">release()</a>, and <a class="el" href="buffer__base_8hpp_source.html#l00100">wait()</a>.</p>

</div>
</div>

</div>
</div>
<a name="classtrisycl_1_1detail_1_1buffer__waiter" id="classtrisycl_1_1detail_1_1buffer__waiter"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1detail_1_1buffer__waiter">&#9670;&nbsp;</a></span>trisycl::detail::buffer_waiter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::detail::buffer_waiter</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, int Dimensions = 1, typename Allocator = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt;<br />
class trisycl::detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;</div><p >A helper class to wait for the final buffer destruction if the conditions for blocking are met. </p>

<p class="definition">Definition at line <a class="el" href="buffer__waiter_8hpp_source.html#l00031">31</a> of file <a class="el" href="buffer__waiter_8hpp_source.html">buffer_waiter.hpp</a>.</p>
</div><div class="dynheader">
Inheritance diagram for trisycl::detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1buffer__waiter__inherit__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="atrisycl_1_1detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map" id="atrisycl_1_1detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_inherit__map">
<area shape="rect" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met." alt="" coords="248,82,411,138"/>
<area shape="rect" href="classdetail_1_1shared__ptr__implementation_3_01buffer__waiter_3_01T_00_011_00_01buffer__allocato7b497b9dd7ebde82483da44589505eb8.html" title=" " alt="" coords="5,5,200,105"/>
<area shape="rect" href="classdetail_1_1debug_3_01buffer__waiter_3_01T_00_011_00_01buffer__allocator_3_01std_1_1remove__ced304ddc047a8cabb638d52c96e3ea66.html" title=" " alt="" coords="25,129,180,200"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for trisycl::detail::buffer_waiter&lt; T, Dimensions, Allocator &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1detail_1_1buffer__waiter__coll__graph.png" border="0" usemap="#atrisycl_1_1detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map" id="atrisycl_1_1detail_1_1buffer__waiter_3_01T_00_01Dimensions_00_01Allocator_01_4_coll__map">
<area shape="rect" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met." alt="" coords="352,137,515,193"/>
<area shape="rect" href="classdetail_1_1shared__ptr__implementation_3_01buffer__waiter_3_01T_00_011_00_01buffer__allocato7b497b9dd7ebde82483da44589505eb8.html" title=" " alt="" coords="5,5,200,105"/>
<area shape="rect" href="classdetail_1_1debug_3_01buffer__waiter_3_01T_00_011_00_01buffer__allocator_3_01std_1_1remove__ced304ddc047a8cabb638d52c96e3ea66.html" title=" " alt="" coords="25,129,180,200"/>
<area shape="rect" href="classfriend.html" title=" " alt="" coords="75,225,130,251"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a88550e74aa3d0a52b75ff614337ee934"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a88550e74aa3d0a52b75ff614337ee934">buffer_waiter</a> (<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; *<a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>)</td></tr>
<tr class="memdesc:a88550e74aa3d0a52b75ff614337ee934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a> on top of a <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">detail::buffer</a>.  <a href="group__data.html#a88550e74aa3d0a52b75ff614337ee934">More...</a><br /></td></tr>
<tr class="separator:a88550e74aa3d0a52b75ff614337ee934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c22a326c873157bffbe674b3c0c9cf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a4c22a326c873157bffbe674b3c0c9cf9">~buffer_waiter</a> ()</td></tr>
<tr class="memdesc:a4c22a326c873157bffbe674b3c0c9cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a> destructor waits for any data to be written back to the host, if any.  <a href="group__data.html#a4c22a326c873157bffbe674b3c0c9cf9">More...</a><br /></td></tr>
<tr class="separator:a4c22a326c873157bffbe674b3c0c9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a10594330779e1bc4476d8272c9fffed4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a10594330779e1bc4476d8272c9fffed4">implementation_t</a> = typename buffer_waiter::shared_ptr_implementation</td></tr>
<tr class="separator:a10594330779e1bc4476d8272c9fffed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:aca718123e433338c3a0e0e3a90637d66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfriend.html">friend</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#aca718123e433338c3a0e0e3a90637d66">implementation_t</a></td></tr>
<tr class="separator:aca718123e433338c3a0e0e3a90637d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a10594330779e1bc4476d8272c9fffed4" name="a10594330779e1bc4476d8272c9fffed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10594330779e1bc4476d8272c9fffed4">&#9670;&nbsp;</a></span>implementation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">trisycl::detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt;::implementation_t =  typename buffer_waiter::shared_ptr_implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer__waiter_8hpp_source.html#l00039">39</a> of file <a class="el" href="buffer__waiter_8hpp_source.html">buffer_waiter.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a88550e74aa3d0a52b75ff614337ee934" name="a88550e74aa3d0a52b75ff614337ee934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88550e74aa3d0a52b75ff614337ee934">&#9670;&nbsp;</a></span>buffer_waiter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">trisycl::detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt;::buffer_waiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a> on top of a <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer" title="A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that ...">detail::buffer</a>. </p>

<p class="definition">Definition at line <a class="el" href="buffer__waiter_8hpp_source.html#l00050">50</a> of file <a class="el" href="buffer__waiter_8hpp_source.html">buffer_waiter.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   50</span>: <a class="code hl_typedef" href="group__data.html#a10594330779e1bc4476d8272c9fffed4">implementation_t</a> { <a class="code hl_variable" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a> } {}</div>
<div class="ttc" id="agroup__data_html_a10594330779e1bc4476d8272c9fffed4"><div class="ttname"><a href="group__data.html#a10594330779e1bc4476d8272c9fffed4">trisycl::detail::buffer_waiter::implementation_t</a></div><div class="ttdeci">typename buffer_waiter::shared_ptr_implementation implementation_t</div><div class="ttdef"><b>Definition:</b> <a href="buffer__waiter_8hpp_source.html#l00039">buffer_waiter.hpp:39</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4c22a326c873157bffbe674b3c0c9cf9" name="a4c22a326c873157bffbe674b3c0c9cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c22a326c873157bffbe674b3c0c9cf9">&#9670;&nbsp;</a></span>~buffer_waiter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">trisycl::detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt;::~<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">buffer_waiter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a> destructor waits for any data to be written back to the host, if any. </p>

<p class="definition">Definition at line <a class="el" href="buffer__waiter_8hpp_source.html#l00056">56</a> of file <a class="el" href="buffer__waiter_8hpp_source.html">buffer_waiter.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   56</span>                   {</div>
<div class="line"><span class="lineno">   57</span>    <span class="comment">/* Get a future from the implementation if we have to wait for its</span></div>
<div class="line"><span class="lineno">   58</span><span class="comment">       destruction */</span></div>
<div class="line"><span class="lineno">   59</span>    <span class="keyword">auto</span> f = implementation-&gt;get_destructor_future();</div>
<div class="line"><span class="lineno">   60</span>    <span class="keywordflow">if</span> (f) {</div>
<div class="line"><span class="lineno">   61</span>      <span class="comment">/* No longer carry for the implementation buffer which is free to</span></div>
<div class="line"><span class="lineno">   62</span><span class="comment">         live its life up to its destruction */</span></div>
<div class="line"><span class="lineno">   63</span>      implementation.reset();</div>
<div class="line"><span class="lineno">   64</span>      <a class="code hl_define" href="triSYCL_2detail_2debug_8hpp.html#a7d15187cc29c2a3ec4ad62acccaa242e">TRISYCL_DUMP_T</a>(<span class="stringliteral">&quot;~buffer_waiter() is waiting&quot;</span>);</div>
<div class="line"><span class="lineno">   65</span>      <span class="comment">// Then wait for its end in some other thread</span></div>
<div class="line"><span class="lineno">   66</span>      f-&gt;wait();</div>
<div class="line"><span class="lineno">   67</span>      <a class="code hl_define" href="triSYCL_2detail_2debug_8hpp.html#a7d15187cc29c2a3ec4ad62acccaa242e">TRISYCL_DUMP_T</a>(<span class="stringliteral">&quot;~buffer_waiter() is done&quot;</span>);</div>
<div class="line"><span class="lineno">   68</span>    }</div>
<div class="line"><span class="lineno">   69</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="triSYCL_2detail_2debug_8hpp_source.html#l00047">TRISYCL_DUMP_T</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="aca718123e433338c3a0e0e3a90637d66" name="aca718123e433338c3a0e0e3a90637d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca718123e433338c3a0e0e3a90637d66">&#9670;&nbsp;</a></span>implementation_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">trisycl::detail::buffer_waiter</a>&lt; T, Dimensions, Allocator &gt;::implementation_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="buffer__waiter_8hpp_source.html#l00042">42</a> of file <a class="el" href="buffer__waiter_8hpp_source.html">buffer_waiter.hpp</a>.</p>

</div>
</div>

</div>
</div>
<a name="structtrisycl_1_1image" id="structtrisycl_1_1image"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structtrisycl_1_1image">&#9670;&nbsp;</a></span>trisycl::image</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct trisycl::image</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;int Dimensions&gt;<br />
struct trisycl::image&lt; Dimensions &gt;</div><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000219">Todo:</a></b></dt><dd>implement image </dd></dl>

<p class="definition">Definition at line <a class="el" href="image_8hpp_source.html#l00022">22</a> of file <a class="el" href="image_8hpp_source.html">image.hpp</a>.</p>
</div>
</div>
</div>
<a name="classtrisycl_1_1pipe" id="classtrisycl_1_1pipe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classtrisycl_1_1pipe">&#9670;&nbsp;</a></span>trisycl::pipe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class trisycl::pipe</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Name, typename T, std::size_t MinCapacity = 0, typename SizeT = std::size_t&gt;<br />
class trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;</div><p >SYCL pipe object. </p>
<p >The member functions can throw for now to help debugging or implementation on CPU.</p>
<p >This is mainly a CPU implementation of the Intel extension described in</p>
<ul>
<li><a href="https://github.com/intel/llvm/pull/292">https://github.com/intel/llvm/pull/292</a></li>
<li><a href="https://github.com/intel/llvm/pull/635">https://github.com/intel/llvm/pull/635</a></li>
<li><p class="startli"><a href="https://github.com/intel/llvm/issues/832">https://github.com/intel/llvm/issues/832</a></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000248">Todo:</a></b></dt><dd>Bike-shed the naming &amp; API according to current C++ proposals or libraries about static sized FIFO</dd></dl>
</li>
</ul>
<p >This could be implemented on top of <a href="https://xilinx.github.io/XRT/master/html/streaming_data_support.html">https://xilinx.github.io/XRT/master/html/streaming_data_support.html</a> and/or expose some features from XRT </p>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00047">47</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>
</div><div class="dynheader">
Collaboration diagram for trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classtrisycl_1_1pipe__coll__graph.png" border="0" usemap="#atrisycl_1_1pipe_3_01Name_00_01T_00_01MinCapacity_00_01SizeT_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="atrisycl_1_1pipe_3_01Name_00_01T_00_01MinCapacity_00_01SizeT_01_4_coll__map" id="atrisycl_1_1pipe_3_01Name_00_01T_00_01MinCapacity_00_01SizeT_01_4_coll__map">
<area shape="rect" title="SYCL pipe object." alt="" coords="18,109,183,151"/>
<area shape="rect" title=" " alt="" coords="5,13,63,39"/>
<area shape="rect" title=" " alt="" coords="87,5,251,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a8cd1328863b1a1f750bfba56f283b6a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> = T</td></tr>
<tr class="separator:a8cd1328863b1a1f750bfba56f283b6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b19ddca37e3eea2d6dc86db452eb03a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a1b19ddca37e3eea2d6dc86db452eb03a">size_type</a> = SizeT</td></tr>
<tr class="separator:a1b19ddca37e3eea2d6dc86db452eb03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:a651ab0f384f575a4d4cf4a21add0d6ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a651ab0f384f575a4d4cf4a21add0d6ce">read</a> ()</td></tr>
<tr class="memdesc:a651ab0f384f575a4d4cf4a21add0d6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking read from the pipe.  <a href="group__data.html#a651ab0f384f575a4d4cf4a21add0d6ce">More...</a><br /></td></tr>
<tr class="separator:a651ab0f384f575a4d4cf4a21add0d6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535e579dc00e19a64faccc960eae2e3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a0535e579dc00e19a64faccc960eae2e3">write</a> (const <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> &amp;value)</td></tr>
<tr class="memdesc:a0535e579dc00e19a64faccc960eae2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking write to the pipe.  <a href="group__data.html#a0535e579dc00e19a64faccc960eae2e3">More...</a><br /></td></tr>
<tr class="separator:a0535e579dc00e19a64faccc960eae2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe36f7002ba00721ffcddfb4f58aba3e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#abe36f7002ba00721ffcddfb4f58aba3e">read</a> (<a class="el" href="classbool.html">bool</a> &amp;success_code)</td></tr>
<tr class="memdesc:abe36f7002ba00721ffcddfb4f58aba3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking read from the pipe.  <a href="group__data.html#abe36f7002ba00721ffcddfb4f58aba3e">More...</a><br /></td></tr>
<tr class="separator:abe36f7002ba00721ffcddfb4f58aba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33685d9ac2ff6f06dc7a94de8a29abc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ac33685d9ac2ff6f06dc7a94de8a29abc">write</a> (const <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> &amp;data, <a class="el" href="classbool.html">bool</a> &amp;success_code)</td></tr>
<tr class="memdesc:ac33685d9ac2ff6f06dc7a94de8a29abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking write to the pipe.  <a href="group__data.html#ac33685d9ac2ff6f06dc7a94de8a29abc">More...</a><br /></td></tr>
<tr class="separator:ac33685d9ac2ff6f06dc7a94de8a29abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Attributes</h3></td></tr>
<tr class="memitem:a331736c836801f97e86fea13073f6e64"><td class="memItemLeft" align="right" valign="top">static constexpr SizeT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a331736c836801f97e86fea13073f6e64">min_capacity</a> = <a class="el" href="group__data.html#a0d0bb6a6be12840672c044aa865b5288">bit_ceil_at_least_2</a>(MinCapacity)</td></tr>
<tr class="memdesc:a331736c836801f97e86fea13073f6e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum capacity in value_type of this pipe.  <a href="group__data.html#a331736c836801f97e86fea13073f6e64">More...</a><br /></td></tr>
<tr class="separator:a331736c836801f97e86fea13073f6e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Private Member Functions</h3></td></tr>
<tr class="memitem:a0d0bb6a6be12840672c044aa865b5288"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#a0d0bb6a6be12840672c044aa865b5288">bit_ceil_at_least_2</a> (std::size_t value)</td></tr>
<tr class="memdesc:a0d0bb6a6be12840672c044aa865b5288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the smallest integral power of two not less than the given value but at least 2 to fit the requirement from boost::fibers::buffered_channel.  <a href="group__data.html#a0d0bb6a6be12840672c044aa865b5288">More...</a><br /></td></tr>
<tr class="separator:a0d0bb6a6be12840672c044aa865b5288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Private Attributes</h3></td></tr>
<tr class="memitem:ae1e51be3b71586383a3e1552a2116be3"><td class="memItemLeft" align="right" valign="top">static boost::fibers::buffered_channel&lt; <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">channel</a> { <a class="el" href="group__data.html#a331736c836801f97e86fea13073f6e64">min_capacity</a> }</td></tr>
<tr class="memdesc:ae1e51be3b71586383a3e1552a2116be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A FIFO used to implement the pipe.  <a href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">More...</a><br /></td></tr>
<tr class="separator:ae1e51be3b71586383a3e1552a2116be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a1b19ddca37e3eea2d6dc86db452eb03a" name="a1b19ddca37e3eea2d6dc86db452eb03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b19ddca37e3eea2d6dc86db452eb03a">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::size_type =  SizeT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00073">73</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>

</div>
</div>
<a id="a8cd1328863b1a1f750bfba56f283b6a8" name="a8cd1328863b1a1f750bfba56f283b6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd1328863b1a1f750bfba56f283b6a8">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00065">65</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a0d0bb6a6be12840672c044aa865b5288" name="a0d0bb6a6be12840672c044aa865b5288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0bb6a6be12840672c044aa865b5288">&#9670;&nbsp;</a></span>bit_ceil_at_least_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::bit_ceil_at_least_2 </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the smallest integral power of two not less than the given value but at least 2 to fit the requirement from boost::fibers::buffered_channel. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000249">Todo:</a></b></dt><dd>At some point use C++20 std::bit_ceil instead of this DIY function </dd></dl>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00055">55</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   55</span>                                                                  {</div>
<div class="line"><span class="lineno">   56</span>    std::size_t result = 2;</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">while</span> (value &gt; result)</div>
<div class="line"><span class="lineno">   58</span>      result *= 2;</div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">   60</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a651ab0f384f575a4d4cf4a21add0d6ce" name="a651ab0f384f575a4d4cf4a21add0d6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651ab0f384f575a4d4cf4a21add0d6ce">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking read from the pipe. </p>
<dl class="section return"><dt>Returns</dt><dd>the value </dd></dl>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00087">87</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   87</span>                           {</div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">channel</a>.value_pop();</div>
<div class="line"><span class="lineno">   89</span>  }</div>
<div class="ttc" id="agroup__data_html_ae1e51be3b71586383a3e1552a2116be3"><div class="ttname"><a href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">trisycl::pipe::channel</a></div><div class="ttdeci">static boost::fibers::buffered_channel&lt; value_type &gt; channel</div><div class="ttdoc">A FIFO used to implement the pipe.</div><div class="ttdef"><b>Definition:</b> <a href="pipe_8hpp_source.html#l00079">pipe.hpp:79</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe_8hpp_source.html#l00079">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;::channel</a>.</p>

</div>
</div>
<a id="abe36f7002ba00721ffcddfb4f58aba3e" name="abe36f7002ba00721ffcddfb4f58aba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe36f7002ba00721ffcddfb4f58aba3e">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>success_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking read from the pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">success_code</td><td>is true iff the read was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value read from the pipe or the default one </dd></dl>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00107">107</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  107</span>                                             {</div>
<div class="line"><span class="lineno">  108</span>    <a class="code hl_typedef" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> value;</div>
<div class="line"><span class="lineno">  109</span>    success_code =</div>
<div class="line"><span class="lineno">  110</span>      <a class="code hl_variable" href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">channel</a>.try_pop(value) == boost::fibers::channel_op_status::success;</div>
<div class="line"><span class="lineno">  111</span>    <span class="comment">/* The current API might be inefficient if we copy always value back.</span></div>
<div class="line"><span class="lineno">  112</span><span class="comment">       But we should have a copy elision... */</span></div>
<div class="line"><span class="lineno">  113</span>    <span class="keywordflow">return</span> value;</div>
<div class="line"><span class="lineno">  114</span>  }</div>
<div class="ttc" id="agroup__data_html_a8cd1328863b1a1f750bfba56f283b6a8"><div class="ttname"><a href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">trisycl::pipe::value_type</a></div><div class="ttdeci">T value_type</div><div class="ttdef"><b>Definition:</b> <a href="pipe_8hpp_source.html#l00065">pipe.hpp:65</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe_8hpp_source.html#l00079">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;::channel</a>.</p>

</div>
</div>
<a id="ac33685d9ac2ff6f06dc7a94de8a29abc" name="ac33685d9ac2ff6f06dc7a94de8a29abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33685d9ac2ff6f06dc7a94de8a29abc">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>success_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non-blocking write to the pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">success_code</td><td>is true iff the read was successful</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value read from the pipe or the default one </dd></dl>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00123">123</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  123</span>                                                                {</div>
<div class="line"><span class="lineno">  124</span>      success_code =</div>
<div class="line"><span class="lineno">  125</span>        <a class="code hl_variable" href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">channel</a>.try_push(data) != boost::fibers::channel_op_status::full;</div>
<div class="line"><span class="lineno">  126</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe_8hpp_source.html#l00079">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;::channel</a>.</p>

</div>
</div>
<a id="a0535e579dc00e19a64faccc960eae2e3" name="a0535e579dc00e19a64faccc960eae2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0535e579dc00e19a64faccc960eae2e3">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking write to the pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>is the data to send to the pipe </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00096">96</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   96</span>                                             {</div>
<div class="line"><span class="lineno">   97</span>    <a class="code hl_variable" href="group__data.html#ae1e51be3b71586383a3e1552a2116be3">channel</a>.push(value);</div>
<div class="line"><span class="lineno">   98</span>  }</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe_8hpp_source.html#l00079">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;::channel</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="ae1e51be3b71586383a3e1552a2116be3" name="ae1e51be3b71586383a3e1552a2116be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e51be3b71586383a3e1552a2116be3">&#9670;&nbsp;</a></span>channel</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::fibers::buffered_channel&lt;<a class="el" href="group__data.html#a8cd1328863b1a1f750bfba56f283b6a8">value_type</a>&gt; <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::channel { <a class="el" href="group__data.html#a331736c836801f97e86fea13073f6e64">min_capacity</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A FIFO used to implement the pipe. </p>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00079">79</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="pipe_8hpp_source.html#l00087">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;::read()</a>, and <a class="el" href="pipe_8hpp_source.html#l00096">trisycl::pipe&lt; Name, T, MinCapacity, SizeT &gt;::write()</a>.</p>

</div>
</div>
<a id="a331736c836801f97e86fea13073f6e64" name="a331736c836801f97e86fea13073f6e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331736c836801f97e86fea13073f6e64">&#9670;&nbsp;</a></span>min_capacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Name , typename T , std::size_t MinCapacity = 0, typename SizeT  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SizeT <a class="el" href="group__data.html#classtrisycl_1_1pipe">trisycl::pipe</a>&lt; Name, T, MinCapacity, SizeT &gt;::min_capacity = <a class="el" href="group__data.html#a0d0bb6a6be12840672c044aa865b5288">bit_ceil_at_least_2</a>(MinCapacity)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The minimum capacity in value_type of this pipe. </p>
<p >The underlying implementation requires a power of 2 </p>

<p class="definition">Definition at line <a class="el" href="pipe_8hpp_source.html#l00070">70</a> of file <a class="el" href="pipe_8hpp_source.html">pipe.hpp</a>.</p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga97d78bc6e06d272d46df6824d686cf45" name="ga97d78bc6e06d272d46df6824d686cf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d78bc6e06d272d46df6824d686cf45">&#9670;&nbsp;</a></span>buffer_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#ga97d78bc6e06d272d46df6824d686cf45">trisycl::buffer_allocator</a> = typedef std::allocator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="allocator_8hpp.html">include/triSYCL/allocator.hpp</a>&gt;</code></p>

<p>The allocator objects give the programmer some control on how the memory is allocated inside SYCL. </p>
<p >The default buffer allocator used by the runtime, when no allocator is defined by the user.</p>
<p >The allocator used for the <code>buffer</code> inside SYCL</p>
<p >Just use the default allocator for now.</p>
<p >Reuse the C++ default allocator. </p>

<p class="definition">Definition at line <a class="el" href="allocator_8hpp_source.html#l00029">29</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a id="ga2d70ad5a942e9f5796851e699254ac57" name="ga2d70ad5a942e9f5796851e699254ac57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d70ad5a942e9f5796851e699254ac57">&#9670;&nbsp;</a></span>image_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#ga2d70ad5a942e9f5796851e699254ac57">trisycl::image_allocator</a> = typedef std::allocator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="allocator_8hpp.html">include/triSYCL/allocator.hpp</a>&gt;</code></p>

<p>The allocator used for the <code>image</code> inside SYCL. </p>
<p >Just use the default allocator for now. </p>

<p class="definition">Definition at line <a class="el" href="allocator_8hpp_source.html#l00037">37</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<a id="gae530ec4a956b74088b45ee1ef2f5e492" name="gae530ec4a956b74088b45ee1ef2f5e492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae530ec4a956b74088b45ee1ef2f5e492">&#9670;&nbsp;</a></span>map_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__data.html#gae530ec4a956b74088b45ee1ef2f5e492">trisycl::map_allocator</a> = typedef std::allocator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="allocator_8hpp.html">include/triSYCL/allocator.hpp</a>&gt;</code></p>

<p>The allocator used to map the memory at the same place. </p>
<p >Just use the default allocator for now.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000106">Todo:</a></b></dt><dd>: implement and clarify the specification. It looks like it is not really an allocator according the current spec </dd></dl>

<p class="definition">Definition at line <a class="el" href="allocator_8hpp_source.html#l00048">48</a> of file <a class="el" href="allocator_8hpp_source.html">allocator.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaae79251ae2eb2eb3f5f1418acf0f1c2f" name="gaae79251ae2eb2eb3f5f1418acf0f1c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae79251ae2eb2eb3f5f1418acf0f1c2f">&#9670;&nbsp;</a></span>add_buffer_to_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; trisycl::detail::add_buffer_to_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *&#160;</td>
          <td class="paramname"><em>command_group_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_write_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="buffer__base_8hpp.html">include/triSYCL/buffer/detail/buffer_base.hpp</a>&gt;</code></p>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00153">trisycl::detail::buffer_base::add_to_task()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_gaae79251ae2eb2eb3f5f1418acf0f1c2f_icgraph.png" border="0" usemap="#agroup__data_gaae79251ae2eb2eb3f5f1418acf0f1c2f_icgraph" alt=""/></div>
<map name="agroup__data_gaae79251ae2eb2eb3f5f1418acf0f1c2f_icgraph" id="agroup__data_gaae79251ae2eb2eb3f5f1418acf0f1c2f_icgraph">
<area shape="rect" title=" " alt="" coords="191,5,316,47"/>
<area shape="rect" href="group__data.html#afa6b63a27d571669233aa06255628fc4" title="Add a buffer to the task running the command group." alt="" coords="5,5,143,47"/>
</map>
</div>

</div>
</div>
<a id="ga9490f033582adcc4b953b1942929af9e" name="ga9490f033582adcc4b953b1942929af9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9490f033582adcc4b953b1942929af9e">&#9670;&nbsp;</a></span>buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a> </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>host_data</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; std::ranges::range_value_t&lt; decltype(host_data)&gt;, 1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="buffer_8hpp.html">include/triSYCL/buffer.hpp</a>&gt;</code></p>

<p>A deduction guide to infer the buffer type from the read-write range. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000115">Todo:</a></b></dt><dd>Use some standard concepts</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000116">Todo:</a></b></dt><dd>Add this to SYCL Next </dd></dl>

</div>
</div>
<a id="gacb39bd9d956d552c0a7b811158d6c31d" name="gacb39bd9d956d552c0a7b811158d6c31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb39bd9d956d552c0a7b811158d6c31d">&#9670;&nbsp;</a></span>buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::forward_iterator FIB, std::forward_iterator FIE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__data.html#classtrisycl_1_1buffer">trisycl::buffer</a> </td>
          <td>(</td>
          <td class="paramtype">FIB&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FIE&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="group__data.html#classtrisycl_1_1buffer">buffer</a>&lt; typename std::iterator_traits&lt; FIB &gt;::value_type, 1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="buffer_8hpp.html">include/triSYCL/buffer.hpp</a>&gt;</code></p>

<p>A deduction guide to infer the buffer type from the read-write forward iterators into a copy-in on construction and copy-back on destruction. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000113">Todo:</a></b></dt><dd>Use some standard concepts</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000114">Todo:</a></b></dt><dd>Add this to SYCL Next </dd></dl>

<p class="reference">Referenced by <a class="el" href="buffer__base_8hpp_source.html#l00176">trisycl::detail::buffer_base::create_in_cache()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_gacb39bd9d956d552c0a7b811158d6c31d_icgraph.png" border="0" usemap="#agroup__data_gacb39bd9d956d552c0a7b811158d6c31d_icgraph" alt=""/></div>
<map name="agroup__data_gacb39bd9d956d552c0a7b811158d6c31d_icgraph" id="agroup__data_gacb39bd9d956d552c0a7b811158d6c31d_icgraph">
<area shape="rect" title="A deduction guide to infer the buffer type from the read&#45;write forward iterators into a copy&#45;in on co..." alt="" coords="441,13,540,39"/>
<area shape="rect" href="group__data.html#a31930d97b31c40b843a1de541060cc24" title="Create a boost::compute::buffer for this trisycl::buffer in the cache and associate it with a given c..." alt="" coords="233,5,393,47"/>
<area shape="rect" href="group__data.html#aad6218af1679f6e4f06ae001a36a86bb" title="When a transfer is requested this function is called, it will update the state of the buffer accordin..." alt="" coords="5,5,185,47"/>
</map>
</div>

</div>
</div>
<a id="gae5b7896e8e1e3224f735bd410e98b7e7" name="gae5b7896e8e1e3224f735bd410e98b7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b7896e8e1e3224f735bd410e98b7e7">&#9670;&nbsp;</a></span>buffer_add_to_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferDetail &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; trisycl::detail::buffer_add_to_task </td>
          <td>(</td>
          <td class="paramtype">BufferDetail&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *&#160;</td>
          <td class="paramname"><em>command_group_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_write_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="buffer_2detail_2buffer_8hpp.html">include/triSYCL/buffer/detail/buffer.hpp</a>&gt;</code></p>

<p>Proxy function to avoid some circular type recursion. </p>
<dl class="section return"><dt>Returns</dt><dd>a shared_ptr&lt;task&gt;</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000146">Todo:</a></b></dt><dd>To remove with some refactoring </dd></dl>

<p class="definition">Definition at line <a class="el" href="buffer_2detail_2buffer_8hpp_source.html#l00352">352</a> of file <a class="el" href="buffer_2detail_2buffer_8hpp_source.html">buffer.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  353</span>                                       {</div>
<div class="line"><span class="lineno">  354</span>  <span class="keywordflow">return</span> buf-&gt;add_to_task(command_group_handler, is_write_mode);</div>
<div class="line"><span class="lineno">  355</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="triSYCL_2buffer_2detail_2accessor_8hpp_source.html#l00118">trisycl::detail::accessor&lt; T, Dimensions, Mode, Target &gt;::accessor()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__data_gae5b7896e8e1e3224f735bd410e98b7e7_icgraph.png" border="0" usemap="#agroup__data_gae5b7896e8e1e3224f735bd410e98b7e7_icgraph" alt=""/></div>
<map name="agroup__data_gae5b7896e8e1e3224f735bd410e98b7e7_icgraph" id="agroup__data_gae5b7896e8e1e3224f735bd410e98b7e7_icgraph">
<area shape="rect" title="Proxy function to avoid some circular type recursion." alt="" coords="211,5,348,47"/>
<area shape="rect" href="group__data.html#a9a0ea8db6d7a56a5226b59c7127e6d1d" title="Construct a device accessor from an existing buffer." alt="" coords="5,5,163,47"/>
</map>
</div>

</div>
</div>
<a id="ga39aab9a5c74f01bd53de448ab7d9048a" name="ga39aab9a5c74f01bd53de448ab7d9048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39aab9a5c74f01bd53de448ab7d9048a">&#9670;&nbsp;</a></span>waiter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto trisycl::detail::waiter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="buffer__waiter_8hpp.html">include/triSYCL/buffer/detail/buffer_waiter.hpp</a>&gt;</code></p>

<p>Helper function to create a new <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a>. </p>

<p class="definition">Definition at line <a class="el" href="buffer__waiter_8hpp_source.html#l00077">77</a> of file <a class="el" href="buffer__waiter_8hpp_source.html">buffer_waiter.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   77</span>                                                   {</div>
<div class="line"><span class="lineno">   78</span>  <span class="keywordflow">return</span> <span class="keyword">new</span> buffer_waiter&lt;T, Dimensions, Allocator&gt; { <a class="code hl_variable" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a> };</div>
<div class="line"><span class="lineno">   79</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="opencl__spir_8h_source.html#l00915">b</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 9 2023 11:27:39 for triSYCL implementation of SYCL by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
