<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>triSYCL implementation of SYCL: trisycl::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">triSYCL implementation of SYCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrisycl.html">trisycl</a></li><li class="navelem"><a class="el" href="namespacetrisycl_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">trisycl::detail Namespace Reference<div class="ingroups"><a class="el" href="group__execution.html">Platforms, contexts, devices and queues</a> &#124; <a class="el" href="group__parallelism.html">Expressing parallelism through kernels</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetrisycl_1_1detail_1_1spir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail_1_1spir.html">spir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">accessor</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional variable length array way.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">accessor&lt; T, Dimensions, Mode, access::target::local &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local accessor specialization abstracts the way local memory is allocated to a kernel to be shared between work-items of the same work-group.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">accessor_base</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer data types.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__array"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__array">address_space_array</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an array variable with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__array">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__base">address_space_base</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the base infrastructure to wrap something in an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__base">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__fundamental"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__fundamental">address_space_fundamental</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__fundamental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a fundamental type with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__fundamental">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__fundamental"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__object"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__object">address_space_object</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an object type with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__object">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__ptr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__ptr">address_space_ptr</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__ptr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for an OpenCL address space pointer.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__ptr">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__ptr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__variable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__variable">address_space_variable</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a variable with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__variable">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1alignment.html">alignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1alignment_3_1_1trisycl_1_1vec_3_01DataType_00_01NumElements_01_4_01_4.html">alignment&lt;::trisycl::vec&lt; DataType, NumElements &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1buffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">buffer</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SYCL buffer is a multidimensional variable length array (Ã  la C99 VLA or even Fortran before) that is used to store data to work on.  <a href="group__data.html#classtrisycl_1_1detail_1_1buffer">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1buffer__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">buffer_base</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1buffer__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize some template independent buffer aspects in a base class.  <a href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1buffer__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1buffer__waiter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">buffer_waiter</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1buffer__waiter"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to wait for the final buffer destruction if the conditions for blocking are met.  <a href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1buffer__waiter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1cache.html">cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple thread safe cache mechanism to cache std::shared_ptr of values indexed by keys.  <a href="classtrisycl_1_1detail_1_1cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1container__element__aspect"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1container__element__aspect">container_element_aspect</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1container__element__aspect"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mix-in to add some container element aspects.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1container__element__aspect">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1container__element__aspect"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1context"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1context">context</a></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1debug"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#structtrisycl_1_1detail_1_1debug">debug</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1debug"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to trace the construction, copy-construction, move-construction and destruction of classes that inherit from it.  <a href="group__debug__trace.html#structtrisycl_1_1detail_1_1debug">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1debug"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1device"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1device">device</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1device"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class representing various models of SYCL devices.  <a href="group__execution.html#classtrisycl_1_1detail_1_1device">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1display__vector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#structtrisycl_1_1detail_1_1display__vector">display_vector</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1display__vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to display a vector-like type of classes that inherit from it.  <a href="group__debug__trace.html#structtrisycl_1_1detail_1_1display__vector">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1display__vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1event.html">event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1expand__to__vector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector">expand_to_vector</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1expand__to__vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows optional expansion of a 1-element tuple to a V::dimension tuple to replicate scalar values in vector initialization.  <a href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1expand__to__vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4">expand_to_vector&lt; V, Tuple, true &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization in the case we ask for expansion.  <a href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1host__context"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1host__context">host_context</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1host__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL host context.  <a href="group__execution.html#classtrisycl_1_1detail_1_1host__context">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1host__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1host__device.html">host_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL host device.  <a href="classtrisycl_1_1detail_1_1host__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1host__event.html">host_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1host__platform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1host__platform">host_platform</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1host__platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL host platform.  <a href="group__execution.html#classtrisycl_1_1detail_1_1host__platform">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1host__platform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1host__queue.html">host_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation details about the SYCL queue.  <a href="classtrisycl_1_1detail_1_1host__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1kernel"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1kernel">kernel</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1kernel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract SYCL kernel.  <a href="group__execution.html#classtrisycl_1_1detail_1_1kernel">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1kernel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type">ocl_type</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a type with some real OpenCL 2 attribute if we are on an OpenCL device.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4">ocl_type&lt; T, access::address_space::constant_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __constant address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4">ocl_type&lt; T, access::address_space::global_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __global address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4">ocl_type&lt; T, access::address_space::local_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __local address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4">ocl_type&lt; T, access::address_space::private_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __private address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__context.html">opencl_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL OpenCL context.  <a href="classtrisycl_1_1detail_1_1opencl__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__device.html">opencl_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL OpenCL device.  <a href="classtrisycl_1_1detail_1_1opencl__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__event.html">opencl_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__kernel.html">opencl_kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction of the OpenCL kernel.  <a href="classtrisycl_1_1detail_1_1opencl__kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1opencl__platform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1opencl__platform">opencl_platform</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1opencl__platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL OpenCL platform.  <a href="group__execution.html#classtrisycl_1_1detail_1_1opencl__platform">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1opencl__platform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__queue.html">opencl_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation details about the SYCL queue.  <a href="classtrisycl_1_1detail_1_1opencl__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1parallel__for__iterate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate">parallel_for_iterate</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1parallel__for__iterate"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recursive multi-dimensional iterator that ends up calling f.  <a href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1parallel__for__iterate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4">parallel_for_iterate&lt; 0, Range, ParallelForFunctor, Id &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the recursion when level reaches 0 by simply calling the kernel functor with the constructed id.  <a href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1pipe"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1pipe">pipe</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1pipe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a pipe object.  <a href="group__data.html#classtrisycl_1_1detail_1_1pipe">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1pipe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1pipe__accessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1pipe__accessor">pipe_accessor</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1pipe__accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accessor abstracts the way pipe data are accessed inside a kernel.  <a href="group__data.html#classtrisycl_1_1detail_1_1pipe__accessor">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1pipe__accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1pipe__reservation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1pipe__reservation">pipe_reservation</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1pipe__reservation"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the pipe reservation station.  <a href="group__data.html#classtrisycl_1_1detail_1_1pipe__reservation">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1pipe__reservation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1platform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1platform">platform</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class representing various models of SYCL platforms.  <a href="group__execution.html#classtrisycl_1_1detail_1_1platform">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1platform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1program.html">program</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1property.html">property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1queue.html">queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation details about the SYCL queue.  <a href="structtrisycl_1_1detail_1_1queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1reserve__id"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#structtrisycl_1_1detail_1_1reserve__id">reserve_id</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1reserve__id"><td class="mdescLeft">&#160;</td><td class="mdescRight">A private description of a reservation station.  <a href="group__data.html#structtrisycl_1_1detail_1_1reserve__id">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1reserve__id"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html">shared_ptr_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an implementation as shared_ptr with total ordering and hashing to be used with algorithms and in (un)ordered containers.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1singleton.html">singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a singleton factory.  <a href="structtrisycl_1_1detail_1_1singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">small_array</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1small__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a multi-dimensional index, used for example to locate a work item or a buffer element.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array__123"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__123">small_array_123</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1small__array__123"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small array of 1, 2 or 3 elements with the implicit constructors.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__123">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array__123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_011_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_011_01_4">small_array_123&lt; BasicType, FinalType, 1 &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_011_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use some specializations so that some function overloads can be determined according to some implicit constructors and to have an implicit conversion from/to BasicType (such as an int typically) if Dimensions = 1.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_011_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_011_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_012_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_012_01_4">small_array_123&lt; BasicType, FinalType, 2 &gt;</a></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_012_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_013_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_013_01_4">small_array_123&lt; BasicType, FinalType, 3 &gt;</a></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array__123_3_01BasicType_00_01FinalType_00_013_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1task.html">task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstraction to represent SYCL tasks executing inside command_group.  <a href="structtrisycl_1_1detail_1_1task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small OpenCL vector class.  <a href="classtrisycl_1_1detail_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga867c55e988890039a4dd7eff76b8c9df"><td class="memTemplParams" colspan="2">template&lt;typename T , access::address_space AS&gt; </td></tr>
<tr class="memitem:ga867c55e988890039a4dd7eff76b8c9df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#ga867c55e988890039a4dd7eff76b8c9df">addr_space</a> = typename std::conditional&lt; std::is_pointer&lt; T &gt;::value, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__ptr">address_space_ptr</a>&lt; T, AS &gt;, typename std::conditional&lt; std::is_class&lt; T &gt;::value, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__object">address_space_object</a>&lt; T, AS &gt;, typename std::conditional&lt; std::is_array&lt; T &gt;::value, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__array">address_space_array</a>&lt; T, AS &gt;, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__fundamental">address_space_fundamental</a>&lt; T, AS &gt; &gt;::type &gt;::type &gt;::type</td></tr>
<tr class="memdesc:ga867c55e988890039a4dd7eff76b8c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch the address space implementation according to the requested type.  <a href="group__address__spaces.html#ga867c55e988890039a4dd7eff76b8c9df">More...</a><br /></td></tr>
<tr class="separator:ga867c55e988890039a4dd7eff76b8c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b15596fd271fd6da762939850ff500"><td class="memTemplParams" colspan="2">template&lt;bool... v&gt; </td></tr>
<tr class="memitem:ac1b15596fd271fd6da762939850ff500"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#ac1b15596fd271fd6da762939850ff500">all_true</a> = std::is_same&lt; <a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt; true, v... &gt;, <a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt; v..., true &gt; &gt;</td></tr>
<tr class="separator:ac1b15596fd271fd6da762939850ff500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef746371302a22b7f6a4bc5512fdae2"><td class="memTemplParams" colspan="2">template&lt;typename DataType , int numElements&gt; </td></tr>
<tr class="memitem:a6ef746371302a22b7f6a4bc5512fdae2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a6ef746371302a22b7f6a4bc5512fdae2">__swizzled_base_vec__</a> = <a class="el" href="classtrisycl_1_1detail_1_1vec.html">detail::vec</a>&lt; DataType, numElements &gt;</td></tr>
<tr class="separator:a6ef746371302a22b7f6a4bc5512fdae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0bfb3fecc61ee391e268331b495caecc"><td class="memTemplParams" colspan="2">template&lt;typename BufferDetail &gt; </td></tr>
<tr class="memitem:ga0bfb3fecc61ee391e268331b495caecc"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga0bfb3fecc61ee391e268331b495caecc">buffer_add_to_task</a> (BufferDetail buf, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:ga0bfb3fecc61ee391e268331b495caecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function to avoid some circular type recursion.  <a href="group__data.html#ga0bfb3fecc61ee391e268331b495caecc">More...</a><br /></td></tr>
<tr class="separator:ga0bfb3fecc61ee391e268331b495caecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b25506d2c4446a60b20cab9a322b8a"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#ga68b25506d2c4446a60b20cab9a322b8a">add_buffer_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="separator:ga68b25506d2c4446a60b20cab9a322b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">waiter</a> (<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; *<a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>)</td></tr>
<tr class="memdesc:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a new <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met...">buffer_waiter</a>.  <a href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">More...</a><br /></td></tr>
<tr class="separator:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33281f2ed98b50007a50194c02279712"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Tuple , size_t... Is&gt; </td></tr>
<tr class="memitem:ga33281f2ed98b50007a50194c02279712"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; typename V::element_type, V::dimension &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#ga33281f2ed98b50007a50194c02279712">tuple_to_array_iterate</a> (Tuple t, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ga33281f2ed98b50007a50194c02279712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to construct an array from initializer elements provided as a tuple.  <a href="group__array__tuple__helpers.html#ga33281f2ed98b50007a50194c02279712">More...</a><br /></td></tr>
<tr class="separator:ga33281f2ed98b50007a50194c02279712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed83198fc898b21e61f2b7bd4161633"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Tuple &gt; </td></tr>
<tr class="memitem:ga8ed83198fc898b21e61f2b7bd4161633"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#ga8ed83198fc898b21e61f2b7bd4161633">tuple_to_array</a> (Tuple t)</td></tr>
<tr class="memdesc:ga8ed83198fc898b21e61f2b7bd4161633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from initializer elements provided as a tuple.  <a href="group__array__tuple__helpers.html#ga8ed83198fc898b21e61f2b7bd4161633">More...</a><br /></td></tr>
<tr class="separator:ga8ed83198fc898b21e61f2b7bd4161633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Tuple &gt; </td></tr>
<tr class="memitem:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#ga5e4d419d6fb4d6531d5e14f3c8b99c7c">expand</a> (Tuple t)</td></tr>
<tr class="memdesc:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the array data of V from a tuple of initializer.  <a href="group__array__tuple__helpers.html#ga5e4d419d6fb4d6531d5e14f3c8b99c7c">More...</a><br /></td></tr>
<tr class="separator:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc56276c38cb71d1901b332a4d3380d"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , typename Functor &gt; </td></tr>
<tr class="memitem:ga9fc56276c38cb71d1901b332a4d3380d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#ga9fc56276c38cb71d1901b332a4d3380d">trace_kernel</a> (Functor f)</td></tr>
<tr class="memdesc:ga9fc56276c38cb71d1901b332a4d3380d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a kernel functor in some tracing messages to have start/stop information when TRISYCL_TRACE_KERNEL macro is defined.  <a href="group__debug__trace.html#ga9fc56276c38cb71d1901b332a4d3380d">More...</a><br /></td></tr>
<tr class="separator:ga9fc56276c38cb71d1901b332a4d3380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d01848d953e86732e3b6773720426"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , typename Functor &gt; </td></tr>
<tr class="memitem:a306d01848d953e86732e3b6773720426"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a306d01848d953e86732e3b6773720426">__attribute__</a> ((noinline)) void instantiate_kernel(Functor f) noexcept</td></tr>
<tr class="memdesc:a306d01848d953e86732e3b6773720426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the kernel code.  <a href="#a306d01848d953e86732e3b6773720426">More...</a><br /></td></tr>
<tr class="separator:a306d01848d953e86732e3b6773720426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3e2db0e50d1419c67d55346253137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global__config_8hpp.html#a2618b1336076abbe7158ea65cdb274c7">TRISYCL_WEAK_ATTRIB_PREFIX</a> void <a class="el" href="group__execution.html#ga70512575d55211271de3605c1fc21032">TRISYCL_WEAK_ATTRIB_SUFFIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137">set_kernel_task_marker</a> (<a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &amp;) noexcept</td></tr>
<tr class="memdesc:ae7f3e2db0e50d1419c67d55346253137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the task to be used to launch the kernel.  <a href="#ae7f3e2db0e50d1419c67d55346253137">More...</a><br /></td></tr>
<tr class="separator:ae7f3e2db0e50d1419c67d55346253137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Id &gt; </td></tr>
<tr class="memitem:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="memTemplItemLeft" align="right" valign="top">size_t constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__helpers.html#ga185ce9faf9e1d586e4f57871ac4c3058">linear_id</a> (Range <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>, Id <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>, Id <a class="el" href="opencl__spir_8h.html#a30c1789509ffb2ea07b060fc6e1344c1">offset</a>={})</td></tr>
<tr class="memdesc:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a linearized array access used in the OpenCL 2 world.  <a href="group__helpers.html#ga185ce9faf9e1d586e4f57871ac4c3058">More...</a><br /></td></tr>
<tr class="separator:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd7e00b76f5b2bef1deb898507f1f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#ga7bd7e00b76f5b2bef1deb898507f1f37">unimplemented</a> (const char *func, const char *file, int line)</td></tr>
<tr class="memdesc:ga7bd7e00b76f5b2bef1deb898507f1f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display an "unimplemented" message.  <a href="group__helpers.html#ga7bd7e00b76f5b2bef1deb898507f1f37">More...</a><br /></td></tr>
<tr class="separator:ga7bd7e00b76f5b2bef1deb898507f1f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876d173bd185aefef8daf2459267fe9f"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga876d173bd185aefef8daf2459267fe9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga876d173bd185aefef8daf2459267fe9f">parallel_for_workitem_in_group</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1group">group</a>&lt; Dimensions &gt; &amp;g, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga876d173bd185aefef8daf2459267fe9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the loop on the work-items inside a work-group.  <a href="group__parallelism.html#ga876d173bd185aefef8daf2459267fe9f">More...</a><br /></td></tr>
<tr class="separator:ga876d173bd185aefef8daf2459267fe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b25506d2c4446a60b20cab9a322b8a"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a68b25506d2c4446a60b20cab9a322b8a">add_buffer_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:a68b25506d2c4446a60b20cab9a322b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a buffer as used by a task.  <a href="#a68b25506d2c4446a60b20cab9a322b8a">More...</a><br /></td></tr>
<tr class="separator:a68b25506d2c4446a60b20cab9a322b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade69cd4aa408811c685ac3b3168271ae"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor , typename Id &gt; </td></tr>
<tr class="memitem:gade69cd4aa408811c685ac3b3168271ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gade69cd4aa408811c685ac3b3168271ae">parallel_for</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; r, ParallelForFunctor f, Id)</td></tr>
<tr class="memdesc:gade69cd4aa408811c685ac3b3168271ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a data parallel computation with parallelism specified at launch time by a range&lt;&gt;.  <a href="group__parallelism.html#gade69cd4aa408811c685ac3b3168271ae">More...</a><br /></td></tr>
<tr class="separator:gade69cd4aa408811c685ac3b3168271ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aff644adc97685e67d6828875bea705"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga3aff644adc97685e67d6828875bea705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga3aff644adc97685e67d6828875bea705">parallel_for</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; r, ParallelForFunctor f, <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; Dimensions &gt;)</td></tr>
<tr class="memdesc:ga3aff644adc97685e67d6828875bea705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a data parallel computation with parallelism specified at launch time by a range&lt;&gt;.  <a href="group__parallelism.html#ga3aff644adc97685e67d6828875bea705">More...</a><br /></td></tr>
<tr class="separator:ga3aff644adc97685e67d6828875bea705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab787598215b6a61f160c46a90be1f526"><td class="memTemplParams" colspan="2">template&lt;typename F , typename R , typename A &gt; </td></tr>
<tr class="memitem:gab787598215b6a61f160c46a90be1f526"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gab787598215b6a61f160c46a90be1f526">capture_arg_v</a> (R(F::*)(A))</td></tr>
<tr class="separator:gab787598215b6a61f160c46a90be1f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga94abf805a744cff3fdf77c04aa0a7c63">parallel_for</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; r, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the appropriate ternary parallel_for overload based on the index type of the kernel function object f.  <a href="group__parallelism.html#ga94abf805a744cff3fdf77c04aa0a7c63">More...</a><br /></td></tr>
<tr class="separator:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga33858ef5d1b5893ad47bf7397905d6e0">parallel_for_global_offset</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; global_size, <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; Dimensions &gt; <a class="el" href="opencl__spir_8h.html#a30c1789509ffb2ea07b060fc6e1344c1">offset</a>, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of parallel_for with a range&lt;&gt; and an offset.  <a href="group__parallelism.html#ga33858ef5d1b5893ad47bf7397905d6e0">More...</a><br /></td></tr>
<tr class="separator:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d85d211443af84683e6126ad69eb216"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga1d85d211443af84683e6126ad69eb216"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga1d85d211443af84683e6126ad69eb216">parallel_for_workgroup</a> (<a class="el" href="group__parallelism.html#structtrisycl_1_1nd__range">nd_range</a>&lt; Dimensions &gt; r, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga1d85d211443af84683e6126ad69eb216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the loop on the work-groups.  <a href="group__parallelism.html#ga1d85d211443af84683e6126ad69eb216">More...</a><br /></td></tr>
<tr class="separator:ga1d85d211443af84683e6126ad69eb216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="memTemplParams" colspan="2">template&lt;int Dimensions, typename T_Item , typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gae45ef8f8ab2c96ae4f647e10f656c13a">parallel_for_workitem</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1group">group</a>&lt; Dimensions &gt; &amp;g, ParallelForFunctor f)</td></tr>
<tr class="memdesc:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the loop on the work-items inside a work-group.  <a href="group__parallelism.html#gae45ef8f8ab2c96ae4f647e10f656c13a">More...</a><br /></td></tr>
<tr class="separator:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d38178288f87c00720c90adf099b12"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga51d38178288f87c00720c90adf099b12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga51d38178288f87c00720c90adf099b12">parallel_for</a> (<a class="el" href="group__parallelism.html#structtrisycl_1_1nd__range">nd_range</a>&lt; Dimensions &gt; r, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga51d38178288f87c00720c90adf099b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a variation of parallel_for to take into account a nd_range&lt;&gt;  <a href="group__parallelism.html#ga51d38178288f87c00720c90adf099b12">More...</a><br /></td></tr>
<tr class="separator:ga51d38178288f87c00720c90adf099b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7dd035f097ecb053e2518ff8655dcc"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga9b7dd035f097ecb053e2518ff8655dcc">to_tbb_range</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; 1 &gt; &amp;r)</td></tr>
<tr class="separator:ga9b7dd035f097ecb053e2518ff8655dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4949ebb14452ca925c178763ac9c5442"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga4949ebb14452ca925c178763ac9c5442">to_tbb_range</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; 2 &gt; &amp;r)</td></tr>
<tr class="separator:ga4949ebb14452ca925c178763ac9c5442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0847de6116d48c133a4bbc2a9b74455c"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga0847de6116d48c133a4bbc2a9b74455c">to_tbb_range</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; 3 &gt; &amp;r)</td></tr>
<tr class="separator:ga0847de6116d48c133a4bbc2a9b74455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad88e5860ae877dd4484ce388005691"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga2ad88e5860ae877dd4484ce388005691">to_sycl_id</a> (const tbb::blocked_range&lt; size_t &gt; &amp;in)</td></tr>
<tr class="separator:ga2ad88e5860ae877dd4484ce388005691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4884a7b5f4a244f5c16cd8ab52686d"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gaef4884a7b5f4a244f5c16cd8ab52686d">to_sycl_id</a> (const tbb::blocked_range2d&lt; size_t &gt; &amp;in)</td></tr>
<tr class="separator:gaef4884a7b5f4a244f5c16cd8ab52686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d5eee9c3c31acc8f7b4ddb377c4188"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gad0d5eee9c3c31acc8f7b4ddb377c4188">to_sycl_id</a> (const tbb::blocked_range3d&lt; size_t &gt; &amp;in)</td></tr>
<tr class="separator:gad0d5eee9c3c31acc8f7b4ddb377c4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003201ce3c2a95af831b1c58fbb3804c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga003201ce3c2a95af831b1c58fbb3804c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga003201ce3c2a95af831b1c58fbb3804c">parallel_for_iterate</a> (Range r, ParallelForFunctor &amp;f)</td></tr>
<tr class="separator:ga003201ce3c2a95af831b1c58fbb3804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga70512575d55211271de3605c1fc21032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global__config_8hpp.html#a2618b1336076abbe7158ea65cdb274c7">TRISYCL_WEAK_ATTRIB_PREFIX</a> <a class="el" href="classtrisycl_1_1detail_1_1cache.html">detail::cache</a>&lt; cl_context, <a class="el" href="classtrisycl_1_1detail_1_1opencl__context.html">detail::opencl_context</a> &gt; <a class="el" href="classtrisycl_1_1detail_1_1opencl__context.html#a77cb43a70a15be7480adcac4d05a9412">opencl_context::cache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ga70512575d55211271de3605c1fc21032">TRISYCL_WEAK_ATTRIB_SUFFIX</a></td></tr>
<tr class="separator:ga70512575d55211271de3605c1fc21032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792746be38e2d14492e3cef8d69806fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a792746be38e2d14492e3cef8d69806fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a792746be38e2d14492e3cef8d69806fe">alignment_v</a> = <a class="el" href="classtrisycl_1_1detail_1_1alignment.html">alignment</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a792746be38e2d14492e3cef8d69806fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b9cd14ace3a07bc7c2fb794246165"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#adb8b9cd14ace3a07bc7c2fb794246165">prevent_arguments_from_optimization</a></td></tr>
<tr class="memdesc:adb8b9cd14ace3a07bc7c2fb794246165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid the interprocedural optimization to remove these arguments in the kernel instantiation by relying on some dummy static variables.  <a href="#adb8b9cd14ace3a07bc7c2fb794246165">More...</a><br /></td></tr>
<tr class="separator:adb8b9cd14ace3a07bc7c2fb794246165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6ef746371302a22b7f6a4bc5512fdae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef746371302a22b7f6a4bc5512fdae2">&#9670;&nbsp;</a></span>__swizzled_base_vec__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int numElements&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetrisycl_1_1detail.html#a6ef746371302a22b7f6a4bc5512fdae2">trisycl::detail::__swizzled_base_vec__</a> = typedef <a class="el" href="classtrisycl_1_1detail_1_1vec.html">detail::vec</a>&lt;DataType, numElements&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vec_2detail_2vec_8hpp_source.html#l00026">26</a> of file <a class="el" href="vec_2detail_2vec_8hpp_source.html">vec.hpp</a>.</p>

</div>
</div>
<a id="ac1b15596fd271fd6da762939850ff500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b15596fd271fd6da762939850ff500">&#9670;&nbsp;</a></span>all_true</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... v&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetrisycl_1_1detail.html#ac1b15596fd271fd6da762939850ff500">trisycl::detail::all_true</a> = typedef std::is_same&lt;<a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt;true, v...&gt;, <a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt;v..., true&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="all__true_8hpp_source.html#l00016">16</a> of file <a class="el" href="all__true_8hpp_source.html">all_true.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a306d01848d953e86732e3b6773720426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d01848d953e86732e3b6773720426">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">trisycl::detail::__attribute__ </td>
          <td>(</td>
          <td class="paramtype">(noinline)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate the kernel code. </p>
<p>To have a clear view of what a kernel is at the LLVM IR level even when a lot of optimizations are done (-O3), call the kernel from this function marked as <code>noinline</code>, otherwise the kernel code is inlined directly where it is used.</p>
<p>Actually some optimizations/code restructuring might duplicate the call to <code>instantiate_kernel</code> but the <code>noduplicate</code> attribute seems incompatible with <code>noinline</code> in Clang/LLVM 3.9.1, because the inlining happen when both attributes are used... </p>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00050">50</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>

<p class="reference">References <a class="el" href="global__config_8hpp_source.html#l00089">TRISYCL_WEAK_ATTRIB_PREFIX</a>, and <a class="el" href="opencl__context_8hpp_source.html#l00146">TRISYCL_WEAK_ATTRIB_SUFFIX</a>.</p>

<p class="reference">Referenced by <a class="el" href="instantiate__kernel_8hpp_source.html#l00077">set_kernel_task_marker()</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                                       {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  <span class="comment">/* The outlining compiler is expected to do some massage here or</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">     around and to insert some calls to \c serialize_arg and so on */</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  f();</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacetrisycl_1_1detail_a306d01848d953e86732e3b6773720426_icgraph.png" border="0" usemap="#namespacetrisycl_1_1detail_a306d01848d953e86732e3b6773720426_icgraph" alt=""/></div>
<map name="namespacetrisycl_1_1detail_a306d01848d953e86732e3b6773720426_icgraph" id="namespacetrisycl_1_1detail_a306d01848d953e86732e3b6773720426_icgraph">
<area shape="rect" id="node2" href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137" title="Set the task to be used to launch the kernel. " alt="" coords="164,5,307,47"/>
</map>
</div>

</div>
</div>
<a id="a68b25506d2c4446a60b20cab9a322b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b25506d2c4446a60b20cab9a322b8a">&#9670;&nbsp;</a></span>add_buffer_to_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a>&gt; trisycl::detail::add_buffer_to_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *&#160;</td>
          <td class="paramname"><em>command_group_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_write_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a buffer as used by a task. </p>
<p>This is a proxy function to avoid complicated type recursion. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l00505">505</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>

<p class="reference">References <a class="el" href="handler_8hpp_source.html#l00051">trisycl::handler::task</a>.</p>
<div class="fragment"><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                                       {</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;  command_group_handler-&gt;task-&gt;add_buffer(<a class="code" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, is_write_mode);</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  <span class="keywordflow">return</span> command_group_handler-&gt;task;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;}</div><div class="ttc" id="opencl__spir_8h_html_a3fd8c63fddfb0d3ba796ef725a8cc5ce"><div class="ttname"><a href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a></div><div class="ttdeci">float const_func float b</div><div class="ttdef"><b>Definition:</b> <a href="opencl__spir_8h_source.html#l00915">opencl_spir.h:915</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7f3e2db0e50d1419c67d55346253137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f3e2db0e50d1419c67d55346253137">&#9670;&nbsp;</a></span>set_kernel_task_marker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global__config_8hpp.html#a2618b1336076abbe7158ea65cdb274c7">TRISYCL_WEAK_ATTRIB_PREFIX</a> void <a class="el" href="group__execution.html#ga70512575d55211271de3605c1fc21032">TRISYCL_WEAK_ATTRIB_SUFFIX</a> trisycl::detail::set_kernel_task_marker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the task to be used to launch the kernel. </p>
<p>This is actually a dummy function so that the device compiler can just grab the task for passing it to the argument serialization functions from the device runtime.</p>
<p>It is better to use a weak linkage than having this function with extern linkage:</p>
<ul>
<li>if the device compiler is used the function is kept by the compiler because full link and LTO is not applied before the device compiler passes are applied. So there is no partial evaluation in the compiler according to what is returned by this function;</li>
<li>if the device compiler is not used, the code still links and can be compiled. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00077">77</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>

<p class="reference">References <a class="el" href="instantiate__kernel_8hpp_source.html#l00050">__attribute__()</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                                              {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_cgraph.png" border="0" usemap="#namespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_cgraph" alt=""/></div>
<map name="namespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_cgraph" id="namespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_cgraph">
<area shape="rect" id="node2" href="namespacetrisycl_1_1detail.html#a306d01848d953e86732e3b6773720426" title="Instantiate the kernel code. " alt="" coords="196,5,307,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a792746be38e2d14492e3cef8d69806fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792746be38e2d14492e3cef8d69806fe">&#9670;&nbsp;</a></span>alignment_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto trisycl::detail::alignment_v = <a class="el" href="classtrisycl_1_1detail_1_1alignment.html">alignment</a>&lt;T&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="alignment__helper_8hpp_source.html#l00036">36</a> of file <a class="el" href="alignment__helper_8hpp_source.html">alignment_helper.hpp</a>.</p>

</div>
</div>
<a id="adb8b9cd14ace3a07bc7c2fb794246165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8b9cd14ace3a07bc7c2fb794246165">&#9670;&nbsp;</a></span>prevent_arguments_from_optimization</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto trisycl::detail::prevent_arguments_from_optimization</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] (<span class="keyword">auto</span> &amp; ...args) {</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> <a class="code" href="namespacetrisycl_1_1detail.html#a306d01848d953e86732e3b6773720426">__attribute__</a>((used)) keep = std::make_tuple(&amp; args...);</div><div class="line">}</div><div class="ttc" id="namespacetrisycl_1_1detail_html_a306d01848d953e86732e3b6773720426"><div class="ttname"><a href="namespacetrisycl_1_1detail.html#a306d01848d953e86732e3b6773720426">trisycl::detail::__attribute__</a></div><div class="ttdeci">__attribute__((noinline)) void instantiate_kernel(Functor f) noexcept</div><div class="ttdoc">Instantiate the kernel code. </div><div class="ttdef"><b>Definition:</b> <a href="instantiate__kernel_8hpp_source.html#l00050">instantiate_kernel.hpp:50</a></div></div>
</div><!-- fragment -->
<p>Avoid the interprocedural optimization to remove these arguments in the kernel instantiation by relying on some dummy static variables. </p>
<p>Using <code><b>attribute</b></code>((used)) does not work on arguments but only on static variable, so use this function. </p>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00028">28</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 16 2020 13:26:36 for triSYCL implementation of SYCL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
