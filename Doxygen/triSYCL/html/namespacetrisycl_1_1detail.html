<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>triSYCL implementation of SYCL: trisycl::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">triSYCL implementation of SYCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetrisycl.html">trisycl</a></li><li class="navelem"><a class="el" href="namespacetrisycl_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">trisycl::detail Namespace Reference<div class="ingroups"><a class="el" href="group__defaults.html">Manage default configuration and types</a> &#124; <a class="el" href="group__opencl__spir__helpers.html">Opencl_spir_helpers</a> &#124; <a class="el" href="group__execution.html">Platforms, contexts, accessors and queues</a> &#124; <a class="el" href="group__parallelism.html">Expressing parallelism through kernels</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Some global triSYCL configuration.  
<a href="namespacetrisycl_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetrisycl_1_1detail_1_1spir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail_1_1spir.html">spir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetrisycl_1_1detail_1_1sycl__2__2"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail_1_1sycl__2__2.html">sycl_2_2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor">accessor</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer accessor abstracts the way buffer data are accessed inside a kernel in a multidimensional variable length array way.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">accessor&lt; T, Dimensions, Mode, access::target::local &gt;</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local accessor specialization abstracts the way local memory is allocated to a kernel to be shared between work-items of the same work-group.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor_3_01T_00_01Dimensions_00_01Mode_00_01access_1_1target_1_1local_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1accessor__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">accessor_base</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1accessor__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer accessor base is here mainly to be accessed from the task without dependency on the buffer data types.  <a href="group__data.html#classtrisycl_1_1detail_1_1accessor__base">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1accessor__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__array"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__array">address_space_array</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an array variable with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__array">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__base">address_space_base</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the base infrastructure to wrap something in an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__base">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__fundamental"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__fundamental">address_space_fundamental</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__fundamental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a fundamental type with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__fundamental">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__fundamental"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__object"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__object">address_space_object</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an object type with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__object">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__ptr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__ptr">address_space_ptr</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__ptr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation for an OpenCL address space pointer.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__ptr">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__ptr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1address__space__variable"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__variable">address_space_variable</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1address__space__variable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a variable with an OpenCL address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__variable">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1address__space__variable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1alignment.html">alignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1alignment_3_1_1trisycl_1_1vec_3_01DataType_00_01NumElements_01_4_01_4.html">alignment&lt;::trisycl::vec&lt; DataType, NumElements &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1buffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">buffer</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SYCL buffer is a multidimensional variable length array (à la C99 VLA or even Fortran before) that is used to store data to work on.  <a href="group__data.html#classtrisycl_1_1detail_1_1buffer">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1buffer__base"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">buffer_base</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1buffer__base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize some template independent buffer aspects in a base class.  <a href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1buffer__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1buffer__waiter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">buffer_waiter</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1buffer__waiter"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to wait for the final buffer destruction if the conditions for blocking are met.  <a href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1buffer__waiter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1cache.html">cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple thread safe cache mechanism to cache std::shared_ptr of values indexed by keys.  <a href="classtrisycl_1_1detail_1_1cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1container__element__aspect"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1container__element__aspect">container_element_aspect</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1container__element__aspect"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mix-in to add some container element aspects.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1container__element__aspect">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1container__element__aspect"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1context"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1context">context</a></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1debug"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#structtrisycl_1_1detail_1_1debug">debug</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1debug"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to trace the construction, copy-construction, move-construction and destruction of classes that inherit from it.  <a href="group__debug__trace.html#structtrisycl_1_1detail_1_1debug">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1debug"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1device"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1device">device</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1device"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class representing various models of SYCL devices.  <a href="group__execution.html#classtrisycl_1_1detail_1_1device">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1display__vector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#structtrisycl_1_1detail_1_1display__vector">display_vector</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1display__vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to display a vector-like type of classes that inherit from it.  <a href="group__debug__trace.html#structtrisycl_1_1detail_1_1display__vector">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1display__vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1event.html">event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1expand__to__vector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector">expand_to_vector</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1expand__to__vector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows optional expansion of a 1-element tuple to a V::dimension tuple to replicate scalar values in vector initialization.  <a href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1expand__to__vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4">expand_to_vector&lt; V, Tuple, true &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization in the case we ask for expansion.  <a href="group__array__tuple__helpers.html#structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1expand__to__vector_3_01V_00_01Tuple_00_01true_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1fiber__pool.html">fiber_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1host__context"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1host__context">host_context</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1host__context"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL host context.  <a href="group__execution.html#classtrisycl_1_1detail_1_1host__context">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1host__context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1host__device.html">host_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL host device.  <a href="classtrisycl_1_1detail_1_1host__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1host__event.html">host_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1host__platform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1host__platform">host_platform</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1host__platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL host platform.  <a href="group__execution.html#classtrisycl_1_1detail_1_1host__platform">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1host__platform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1host__queue.html">host_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation details about the SYCL queue.  <a href="classtrisycl_1_1detail_1_1host__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1is__range.html">is_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait to check if a type it a sycl::range or not.  <a href="structtrisycl_1_1detail_1_1is__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1is__range_3_01range_3_01Dimensions_01_4_01_4.html">is_range&lt; range&lt; Dimensions &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if template instantiating match a sycl::range.  <a href="structtrisycl_1_1detail_1_1is__range_3_01range_3_01Dimensions_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1kernel"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1kernel">kernel</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1kernel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract SYCL kernel.  <a href="group__execution.html#classtrisycl_1_1detail_1_1kernel">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1kernel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type">ocl_type</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a type with some real OpenCL 2 attribute if we are on an OpenCL device.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4">ocl_type&lt; T, access::address_space::constant_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __constant address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1constant__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4">ocl_type&lt; T, access::address_space::global_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __global address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1global__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4">ocl_type&lt; T, access::address_space::local_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __local address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1local__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4">ocl_type&lt; T, access::address_space::private_space &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute for __private address space.  <a href="group__address__spaces.html#structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1ocl__type_3_01T_00_01access_1_1address__space_1_1private__space_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__context.html">opencl_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL OpenCL context.  <a href="classtrisycl_1_1detail_1_1opencl__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__device.html">opencl_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL OpenCL device.  <a href="classtrisycl_1_1detail_1_1opencl__device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__event.html">opencl_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__kernel.html">opencl_kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction of the OpenCL kernel.  <a href="classtrisycl_1_1detail_1_1opencl__kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1opencl__platform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1opencl__platform">opencl_platform</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1opencl__platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">SYCL OpenCL platform.  <a href="group__execution.html#classtrisycl_1_1detail_1_1opencl__platform">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1opencl__platform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1opencl__queue.html">opencl_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation details about the SYCL queue.  <a href="classtrisycl_1_1detail_1_1opencl__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1overloaded"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1overloaded">overloaded</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1overloaded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for the visitor to do pattern matching on invocables <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">https://en.cppreference.com/w/cpp/utility/variant/visit</a>.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1overloaded">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1overloaded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1parallel__for__iterate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate">parallel_for_iterate</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1parallel__for__iterate"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recursive multi-dimensional iterator that ends up calling f.  <a href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1parallel__for__iterate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4">parallel_for_iterate&lt; 0, Range, ParallelForFunctor, Id &gt;</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the recursion when level reaches 0 by simply calling the kernel functor with the constructed id.  <a href="group__parallelism.html#structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1parallel__for__iterate_3_010_00_01Range_00_01ParallelForFunctor_00_01Id_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classtrisycl_1_1detail_1_1platform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#classtrisycl_1_1detail_1_1platform">platform</a></td></tr>
<tr class="memdesc:classtrisycl_1_1detail_1_1platform"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class representing various models of SYCL platforms.  <a href="group__execution.html#classtrisycl_1_1detail_1_1platform">More...</a><br /></td></tr>
<tr class="separator:classtrisycl_1_1detail_1_1platform"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1pooled__shared__work.html">pooled_shared_work</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1pooled__work__stealing.html">pooled_work_stealing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1program.html">program</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1property.html">property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1queue.html">queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some implementation details about the SYCL queue.  <a href="structtrisycl_1_1detail_1_1queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html">shared_ptr_implementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an implementation as shared_ptr with total ordering and hashing to be used with algorithms and in (un)ordered containers.  <a href="structtrisycl_1_1detail_1_1shared__ptr__implementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1singleton.html">singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a singleton factory.  <a href="structtrisycl_1_1detail_1_1singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">small_array</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1small__array"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a multi-dimensional index, used for example to locate a work item or a buffer element.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1small__array">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array__sycl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__sycl">small_array_sycl</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1small__array__sycl"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small array to implement SYCL objects like id, range, item... with 1, 2 or 3 elements (or even more if <a class="el" href="namespacetrisycl_1_1detail.html#a8e4132dcb7f38fbccdda281ce3685069" title="Map TRISYCL_ALLOW_ANY_DIMENSION to a constexpr variable.">detail::allow_any_dimension</a> is true), with the implicit constructors.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__sycl">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array__sycl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structtrisycl_1_1detail_1_1small__array__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__tag">small_array_tag</a></td></tr>
<tr class="memdesc:structtrisycl_1_1detail_1_1small__array__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to define simply inheritance from <a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1small__array" title="Define a multi-dimensional index, used for example to locate a work item or a buffer element.">small_array</a>.  <a href="group__helpers.html#structtrisycl_1_1detail_1_1small__array__tag">More...</a><br /></td></tr>
<tr class="separator:structtrisycl_1_1detail_1_1small__array__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrisycl_1_1detail_1_1task.html">task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstraction to represent SYCL tasks executing inside command_group.  <a href="structtrisycl_1_1detail_1_1task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrisycl_1_1detail_1_1vec.html">vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration to use in the detail class  <a href="classtrisycl_1_1detail_1_1vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concepttrisycl_1_1detail_1_1is__small__array.html">is_small_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept describing a class inheriting from small_array. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga867c55e988890039a4dd7eff76b8c9df"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacetrisycl_1_1access.html#ae0c4ce371692500c7d0e4ccbcf5771fb">access::address_space</a> AS&gt; </td></tr>
<tr class="memitem:ga867c55e988890039a4dd7eff76b8c9df"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__address__spaces.html#ga867c55e988890039a4dd7eff76b8c9df">addr_space</a> = typename std::conditional&lt; std::is_pointer&lt; T &gt;::value, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__ptr">address_space_ptr</a>&lt; T, AS &gt;, typename std::conditional&lt; std::is_class&lt; T &gt;::value, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__object">address_space_object</a>&lt; T, AS &gt;, typename std::conditional&lt; std::is_array&lt; T &gt;::value, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__array">address_space_array</a>&lt; T, AS &gt;, <a class="el" href="group__address__spaces.html#structtrisycl_1_1detail_1_1address__space__fundamental">address_space_fundamental</a>&lt; T, AS &gt; &gt;::type &gt;::type &gt;::type</td></tr>
<tr class="memdesc:ga867c55e988890039a4dd7eff76b8c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch the address space implementation according to the requested type.  <a href="group__address__spaces.html#ga867c55e988890039a4dd7eff76b8c9df">More...</a><br /></td></tr>
<tr class="separator:ga867c55e988890039a4dd7eff76b8c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b15596fd271fd6da762939850ff500"><td class="memTemplParams" colspan="2">template&lt;bool... v&gt; </td></tr>
<tr class="memitem:ac1b15596fd271fd6da762939850ff500"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#ac1b15596fd271fd6da762939850ff500">all_true</a> = std::is_same&lt; <a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt; true, v... &gt;, <a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt; v..., true &gt; &gt;</td></tr>
<tr class="separator:ac1b15596fd271fd6da762939850ff500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7841a75467a1e1bb143749fd29abeb73"><td class="memTemplParams" colspan="2">template&lt;typename DataType , int numElements&gt; </td></tr>
<tr class="memitem:a7841a75467a1e1bb143749fd29abeb73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a7841a75467a1e1bb143749fd29abeb73">__swizzled_base_vec__</a> = <a class="el" href="classtrisycl_1_1detail_1_1vec.html">vec</a>&lt; DataType, numElements &gt;</td></tr>
<tr class="separator:a7841a75467a1e1bb143749fd29abeb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="memTemplParams" colspan="2">template&lt;typename BufferDetail &gt; </td></tr>
<tr class="memitem:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="memTemplItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7">buffer_add_to_task</a> (BufferDetail buf, <a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy function to avoid some circular type recursion.  <a href="group__data.html#gae5b7896e8e1e3224f735bd410e98b7e7">More...</a><br /></td></tr>
<tr class="separator:gae5b7896e8e1e3224f735bd410e98b7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__data.html#gaae79251ae2eb2eb3f5f1418acf0f1c2f">add_buffer_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="separator:gaae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memTemplParams" colspan="2">template&lt;typename T , int Dimensions = 1, typename Allocator  = buffer_allocator&lt;std::remove_const_t&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">waiter</a> (<a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer">detail::buffer</a>&lt; T, Dimensions &gt; *<a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>)</td></tr>
<tr class="memdesc:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a new <a class="el" href="group__data.html#classtrisycl_1_1detail_1_1buffer__waiter" title="A helper class to wait for the final buffer destruction if the conditions for blocking are met.">buffer_waiter</a>.  <a href="group__data.html#ga39aab9a5c74f01bd53de448ab7d9048a">More...</a><br /></td></tr>
<tr class="separator:ga39aab9a5c74f01bd53de448ab7d9048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60768347205ca976e5ea4f9821ad9bfa"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Tuple , std::size_t... Is&gt; </td></tr>
<tr class="memitem:ga60768347205ca976e5ea4f9821ad9bfa"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; typename V::element_type, V::dimension &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#ga60768347205ca976e5ea4f9821ad9bfa">tuple_to_array_iterate</a> (Tuple t, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ga60768347205ca976e5ea4f9821ad9bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to construct an array from initializer elements provided as a tuple.  <a href="group__array__tuple__helpers.html#ga60768347205ca976e5ea4f9821ad9bfa">More...</a><br /></td></tr>
<tr class="separator:ga60768347205ca976e5ea4f9821ad9bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed83198fc898b21e61f2b7bd4161633"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Tuple &gt; </td></tr>
<tr class="memitem:ga8ed83198fc898b21e61f2b7bd4161633"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#ga8ed83198fc898b21e61f2b7bd4161633">tuple_to_array</a> (Tuple t)</td></tr>
<tr class="memdesc:ga8ed83198fc898b21e61f2b7bd4161633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from initializer elements provided as a tuple.  <a href="group__array__tuple__helpers.html#ga8ed83198fc898b21e61f2b7bd4161633">More...</a><br /></td></tr>
<tr class="separator:ga8ed83198fc898b21e61f2b7bd4161633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="memTemplParams" colspan="2">template&lt;typename V , typename Tuple &gt; </td></tr>
<tr class="memitem:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__array__tuple__helpers.html#ga5e4d419d6fb4d6531d5e14f3c8b99c7c">expand</a> (Tuple t)</td></tr>
<tr class="memdesc:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the array data of V from a tuple of initializer.  <a href="group__array__tuple__helpers.html#ga5e4d419d6fb4d6531d5e14f3c8b99c7c">More...</a><br /></td></tr>
<tr class="separator:ga5e4d419d6fb4d6531d5e14f3c8b99c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fc56276c38cb71d1901b332a4d3380d"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , typename Functor &gt; </td></tr>
<tr class="memitem:ga9fc56276c38cb71d1901b332a4d3380d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__debug__trace.html#ga9fc56276c38cb71d1901b332a4d3380d">trace_kernel</a> (Functor f)</td></tr>
<tr class="memdesc:ga9fc56276c38cb71d1901b332a4d3380d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a kernel functor in some tracing messages to have start/stop information when TRISYCL_TRACE_KERNEL macro is defined.  <a href="group__debug__trace.html#ga9fc56276c38cb71d1901b332a4d3380d">More...</a><br /></td></tr>
<tr class="separator:ga9fc56276c38cb71d1901b332a4d3380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf371d5b403131e992b56db5e96f7b50"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , typename Functor &gt; </td></tr>
<tr class="memitem:aaf371d5b403131e992b56db5e96f7b50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#aaf371d5b403131e992b56db5e96f7b50">instantiate_kernel</a> (Functor f) noexcept</td></tr>
<tr class="memdesc:aaf371d5b403131e992b56db5e96f7b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the kernel code.  <a href="namespacetrisycl_1_1detail.html#aaf371d5b403131e992b56db5e96f7b50">More...</a><br /></td></tr>
<tr class="separator:aaf371d5b403131e992b56db5e96f7b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3e2db0e50d1419c67d55346253137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global__config_8hpp.html#a2618b1336076abbe7158ea65cdb274c7">TRISYCL_WEAK_ATTRIB_PREFIX</a> void <a class="el" href="group__execution.html#ga70512575d55211271de3605c1fc21032">TRISYCL_WEAK_ATTRIB_SUFFIX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137">set_kernel_task_marker</a> (<a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &amp;) noexcept</td></tr>
<tr class="memdesc:ae7f3e2db0e50d1419c67d55346253137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the task to be used to launch the kernel.  <a href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137">More...</a><br /></td></tr>
<tr class="separator:ae7f3e2db0e50d1419c67d55346253137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f83d81ec55bc6b9930ae1cf9197462"><td class="memTemplParams" colspan="2">template&lt;typename KernelName , typename Kernel &gt; </td></tr>
<tr class="memitem:a47f83d81ec55bc6b9930ae1cf9197462"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a47f83d81ec55bc6b9930ae1cf9197462">launch_device_kernel</a> (<a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &amp;t, Kernel k) noexcept</td></tr>
<tr class="memdesc:a47f83d81ec55bc6b9930ae1cf9197462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather in a single function what is necessary for the device compiler to outline the kernel or to set up the kernel and serialize the arguments.  <a href="namespacetrisycl_1_1detail.html#a47f83d81ec55bc6b9930ae1cf9197462">More...</a><br /></td></tr>
<tr class="separator:a47f83d81ec55bc6b9930ae1cf9197462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Id &gt; </td></tr>
<tr class="memitem:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="memTemplItemLeft" align="right" valign="top">size_t constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__helpers.html#ga185ce9faf9e1d586e4f57871ac4c3058">linear_id</a> (Range <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>, Id <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>, Id <a class="el" href="opencl__spir_8h.html#a30c1789509ffb2ea07b060fc6e1344c1">offset</a>={})</td></tr>
<tr class="memdesc:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a linearized array access used in the OpenCL 2 world.  <a href="group__helpers.html#ga185ce9faf9e1d586e4f57871ac4c3058">More...</a><br /></td></tr>
<tr class="separator:ga185ce9faf9e1d586e4f57871ac4c3058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67927bda247fd79f6646b0644e39d4af"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a67927bda247fd79f6646b0644e39d4af">assign_from_tuple</a> (auto &amp;dest, auto &amp;&amp;tuple)</td></tr>
<tr class="memdesc:a67927bda247fd79f6646b0644e39d4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign arguments from a tuple.  <a href="namespacetrisycl_1_1detail.html#a67927bda247fd79f6646b0644e39d4af">More...</a><br /></td></tr>
<tr class="separator:a67927bda247fd79f6646b0644e39d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1bab75cc6992da5f1fa534384c95d8c"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:gac1bab75cc6992da5f1fa534384c95d8c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__helpers.html#gac1bab75cc6992da5f1fa534384c95d8c">overloaded</a> (Ts...) -&gt; <a class="el" href="group__helpers.html#structtrisycl_1_1detail_1_1overloaded">overloaded</a>&lt; Ts... &gt;</td></tr>
<tr class="separator:gac1bab75cc6992da5f1fa534384c95d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd7e00b76f5b2bef1deb898507f1f37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__helpers.html#ga7bd7e00b76f5b2bef1deb898507f1f37">unimplemented</a> (const char *func, const char *file, int line)</td></tr>
<tr class="memdesc:ga7bd7e00b76f5b2bef1deb898507f1f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display an "unimplemented" message.  <a href="group__helpers.html#ga7bd7e00b76f5b2bef1deb898507f1f37">More...</a><br /></td></tr>
<tr class="separator:ga7bd7e00b76f5b2bef1deb898507f1f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876d173bd185aefef8daf2459267fe9f"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga876d173bd185aefef8daf2459267fe9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga876d173bd185aefef8daf2459267fe9f">parallel_for_workitem_in_group</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1group">group</a>&lt; Dimensions &gt; &amp;g, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga876d173bd185aefef8daf2459267fe9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the loop on the work-items inside a work-group.  <a href="group__parallelism.html#ga876d173bd185aefef8daf2459267fe9f">More...</a><br /></td></tr>
<tr class="separator:ga876d173bd185aefef8daf2459267fe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#aae79251ae2eb2eb3f5f1418acf0f1c2f">add_buffer_to_task</a> (<a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *command_group_handler, std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt; <a class="el" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, <a class="el" href="classbool.html">bool</a> is_write_mode)</td></tr>
<tr class="memdesc:aae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a buffer as used by a task.  <a href="namespacetrisycl_1_1detail.html#aae79251ae2eb2eb3f5f1418acf0f1c2f">More...</a><br /></td></tr>
<tr class="separator:aae79251ae2eb2eb3f5f1418acf0f1c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade69cd4aa408811c685ac3b3168271ae"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor , typename Id &gt; </td></tr>
<tr class="memitem:gade69cd4aa408811c685ac3b3168271ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gade69cd4aa408811c685ac3b3168271ae">parallel_for</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; r, ParallelForFunctor f, Id)</td></tr>
<tr class="memdesc:gade69cd4aa408811c685ac3b3168271ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a data parallel computation with parallelism specified at launch time by a range&lt;&gt;.  <a href="group__parallelism.html#gade69cd4aa408811c685ac3b3168271ae">More...</a><br /></td></tr>
<tr class="separator:gade69cd4aa408811c685ac3b3168271ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aff644adc97685e67d6828875bea705"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga3aff644adc97685e67d6828875bea705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga3aff644adc97685e67d6828875bea705">parallel_for</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; r, ParallelForFunctor f, <a class="el" href="group__parallelism.html#classtrisycl_1_1item">item</a>&lt; Dimensions &gt;)</td></tr>
<tr class="memdesc:ga3aff644adc97685e67d6828875bea705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a data parallel computation with parallelism specified at launch time by a range&lt;&gt;.  <a href="group__parallelism.html#ga3aff644adc97685e67d6828875bea705">More...</a><br /></td></tr>
<tr class="separator:ga3aff644adc97685e67d6828875bea705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab787598215b6a61f160c46a90be1f526"><td class="memTemplParams" colspan="2">template&lt;typename F , typename R , typename A &gt; </td></tr>
<tr class="memitem:gab787598215b6a61f160c46a90be1f526"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gab787598215b6a61f160c46a90be1f526">capture_arg_v</a> (R(F::*)(A))</td></tr>
<tr class="separator:gab787598215b6a61f160c46a90be1f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga94abf805a744cff3fdf77c04aa0a7c63">parallel_for</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; r, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the appropriate ternary parallel_for overload based on the index type of the kernel function object f.  <a href="group__parallelism.html#ga94abf805a744cff3fdf77c04aa0a7c63">More...</a><br /></td></tr>
<tr class="separator:ga94abf805a744cff3fdf77c04aa0a7c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga33858ef5d1b5893ad47bf7397905d6e0">parallel_for_global_offset</a> (<a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; Dimensions &gt; global_size, <a class="el" href="group__parallelism.html#classtrisycl_1_1id">id</a>&lt; Dimensions &gt; <a class="el" href="opencl__spir_8h.html#a30c1789509ffb2ea07b060fc6e1344c1">offset</a>, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of parallel_for with a range&lt;&gt; and an offset.  <a href="group__parallelism.html#ga33858ef5d1b5893ad47bf7397905d6e0">More...</a><br /></td></tr>
<tr class="separator:ga33858ef5d1b5893ad47bf7397905d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d85d211443af84683e6126ad69eb216"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga1d85d211443af84683e6126ad69eb216"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga1d85d211443af84683e6126ad69eb216">parallel_for_workgroup</a> (<a class="el" href="group__parallelism.html#structtrisycl_1_1nd__range">nd_range</a>&lt; Dimensions &gt; r, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga1d85d211443af84683e6126ad69eb216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the loop on the work-groups.  <a href="group__parallelism.html#ga1d85d211443af84683e6126ad69eb216">More...</a><br /></td></tr>
<tr class="separator:ga1d85d211443af84683e6126ad69eb216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="memTemplParams" colspan="2">template&lt;int Dimensions, typename T_Item , typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gae45ef8f8ab2c96ae4f647e10f656c13a">parallel_for_workitem</a> (const <a class="el" href="group__parallelism.html#structtrisycl_1_1group">group</a>&lt; Dimensions &gt; &amp;g, ParallelForFunctor f)</td></tr>
<tr class="memdesc:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the loop on the work-items inside a work-group.  <a href="group__parallelism.html#gae45ef8f8ab2c96ae4f647e10f656c13a">More...</a><br /></td></tr>
<tr class="separator:gae45ef8f8ab2c96ae4f647e10f656c13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51d38178288f87c00720c90adf099b12"><td class="memTemplParams" colspan="2">template&lt;int Dimensions = 1, typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga51d38178288f87c00720c90adf099b12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga51d38178288f87c00720c90adf099b12">parallel_for</a> (<a class="el" href="group__parallelism.html#structtrisycl_1_1nd__range">nd_range</a>&lt; Dimensions &gt; r, ParallelForFunctor f)</td></tr>
<tr class="memdesc:ga51d38178288f87c00720c90adf099b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a variation of parallel_for to take into account a nd_range&lt;&gt;  <a href="group__parallelism.html#ga51d38178288f87c00720c90adf099b12">More...</a><br /></td></tr>
<tr class="separator:ga51d38178288f87c00720c90adf099b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b7dd035f097ecb053e2518ff8655dcc"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga9b7dd035f097ecb053e2518ff8655dcc">to_tbb_range</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; 1 &gt; &amp;r)</td></tr>
<tr class="separator:ga9b7dd035f097ecb053e2518ff8655dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4949ebb14452ca925c178763ac9c5442"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga4949ebb14452ca925c178763ac9c5442">to_tbb_range</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; 2 &gt; &amp;r)</td></tr>
<tr class="separator:ga4949ebb14452ca925c178763ac9c5442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0847de6116d48c133a4bbc2a9b74455c"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga0847de6116d48c133a4bbc2a9b74455c">to_tbb_range</a> (const <a class="el" href="group__parallelism.html#classtrisycl_1_1range">range</a>&lt; 3 &gt; &amp;r)</td></tr>
<tr class="separator:ga0847de6116d48c133a4bbc2a9b74455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad88e5860ae877dd4484ce388005691"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga2ad88e5860ae877dd4484ce388005691">to_sycl_id</a> (const tbb::blocked_range&lt; size_t &gt; &amp;in)</td></tr>
<tr class="separator:ga2ad88e5860ae877dd4484ce388005691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4884a7b5f4a244f5c16cd8ab52686d"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gaef4884a7b5f4a244f5c16cd8ab52686d">to_sycl_id</a> (const tbb::blocked_range2d&lt; size_t &gt; &amp;in)</td></tr>
<tr class="separator:gaef4884a7b5f4a244f5c16cd8ab52686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d5eee9c3c31acc8f7b4ddb377c4188"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parallelism.html#gad0d5eee9c3c31acc8f7b4ddb377c4188">to_sycl_id</a> (const tbb::blocked_range3d&lt; size_t &gt; &amp;in)</td></tr>
<tr class="separator:gad0d5eee9c3c31acc8f7b4ddb377c4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003201ce3c2a95af831b1c58fbb3804c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename ParallelForFunctor &gt; </td></tr>
<tr class="memitem:ga003201ce3c2a95af831b1c58fbb3804c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelism.html#ga003201ce3c2a95af831b1c58fbb3804c">parallel_for_iterate</a> (Range r, ParallelForFunctor &amp;f)</td></tr>
<tr class="separator:ga003201ce3c2a95af831b1c58fbb3804c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad938eeb65b13d38543d5dd16fbace6b3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#ad938eeb65b13d38543d5dd16fbace6b3">rangeify</a> (auto r)</td></tr>
<tr class="memdesc:ad938eeb65b13d38543d5dd16fbace6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an explicit <a class="el" href="group__parallelism.html">range&lt;1&gt;</a> when an integral is provided or pass the value unchanged.  <a href="namespacetrisycl_1_1detail.html#ad938eeb65b13d38543d5dd16fbace6b3">More...</a><br /></td></tr>
<tr class="separator:ad938eeb65b13d38543d5dd16fbace6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga70512575d55211271de3605c1fc21032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="global__config_8hpp.html#a2618b1336076abbe7158ea65cdb274c7">TRISYCL_WEAK_ATTRIB_PREFIX</a> <a class="el" href="classtrisycl_1_1detail_1_1cache.html">detail::cache</a>&lt; cl_context, <a class="el" href="classtrisycl_1_1detail_1_1opencl__context.html">detail::opencl_context</a> &gt; <a class="el" href="classtrisycl_1_1detail_1_1opencl__context.html#a77cb43a70a15be7480adcac4d05a9412">opencl_context::cache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__execution.html#ga70512575d55211271de3605c1fc21032">TRISYCL_WEAK_ATTRIB_SUFFIX</a></td></tr>
<tr class="separator:ga70512575d55211271de3605c1fc21032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792746be38e2d14492e3cef8d69806fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a792746be38e2d14492e3cef8d69806fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a792746be38e2d14492e3cef8d69806fe">alignment_v</a> = <a class="el" href="classtrisycl_1_1detail_1_1alignment.html">alignment</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a792746be38e2d14492e3cef8d69806fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6a3bd304cf35f3ea76b6fdbe45fab7"><td class="memItemLeft" align="right" valign="top">auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a9d6a3bd304cf35f3ea76b6fdbe45fab7">underlying_value</a></td></tr>
<tr class="memdesc:a9d6a3bd304cf35f3ea76b6fdbe45fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the enum value as an integral value of the underlying integer type.  <a href="namespacetrisycl_1_1detail.html#a9d6a3bd304cf35f3ea76b6fdbe45fab7">More...</a><br /></td></tr>
<tr class="separator:a9d6a3bd304cf35f3ea76b6fdbe45fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed50f30c92c9246d58d7ce448d511f07"><td class="memItemLeft" align="right" valign="top">auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#aed50f30c92c9246d58d7ce448d511f07">enum_distance</a></td></tr>
<tr class="memdesc:aed50f30c92c9246d58d7ce448d511f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance between 2 enum underlying values.  <a href="namespacetrisycl_1_1detail.html#aed50f30c92c9246d58d7ce448d511f07">More...</a><br /></td></tr>
<tr class="separator:aed50f30c92c9246d58d7ce448d511f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0c17dc79de5a90f41d4fe6c70c5a67"><td class="memItemLeft" align="right" valign="top">auto constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a1e0c17dc79de5a90f41d4fe6c70c5a67">enum_count</a></td></tr>
<tr class="memdesc:a1e0c17dc79de5a90f41d4fe6c70c5a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of enums between 2 enum boundaries, including the boundaries.  <a href="namespacetrisycl_1_1detail.html#a1e0c17dc79de5a90f41d4fe6c70c5a67">More...</a><br /></td></tr>
<tr class="separator:a1e0c17dc79de5a90f41d4fe6c70c5a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4132dcb7f38fbccdda281ce3685069"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a8e4132dcb7f38fbccdda281ce3685069">allow_any_dimension</a></td></tr>
<tr class="memdesc:a8e4132dcb7f38fbccdda281ce3685069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map TRISYCL_ALLOW_ANY_DIMENSION to a constexpr variable.  <a href="namespacetrisycl_1_1detail.html#a8e4132dcb7f38fbccdda281ce3685069">More...</a><br /></td></tr>
<tr class="separator:a8e4132dcb7f38fbccdda281ce3685069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b36cdcf4170235b1c3f0aacac15f28"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a40b36cdcf4170235b1c3f0aacac15f28">use_native_work_item</a></td></tr>
<tr class="memdesc:a40b36cdcf4170235b1c3f0aacac15f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map TRISYCL_USE_OPENCL_ND_RANGE to a constexpr variable.  <a href="namespacetrisycl_1_1detail.html#a40b36cdcf4170235b1c3f0aacac15f28">More...</a><br /></td></tr>
<tr class="separator:a40b36cdcf4170235b1c3f0aacac15f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b9cd14ace3a07bc7c2fb794246165"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#adb8b9cd14ace3a07bc7c2fb794246165">prevent_arguments_from_optimization</a></td></tr>
<tr class="memdesc:adb8b9cd14ace3a07bc7c2fb794246165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoid the interprocedural optimization to remove these arguments in the kernel instantiation by relying on some dummy static variables.  <a href="namespacetrisycl_1_1detail.html#adb8b9cd14ace3a07bc7c2fb794246165">More...</a><br /></td></tr>
<tr class="separator:adb8b9cd14ace3a07bc7c2fb794246165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839412f45f55b79e2b0557514de898b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a839412f45f55b79e2b0557514de898b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetrisycl_1_1detail.html#a839412f45f55b79e2b0557514de898b6">is_range_v</a> = <a class="el" href="structtrisycl_1_1detail_1_1is__range.html">is_range</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a839412f45f55b79e2b0557514de898b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable to check if a type is a sycl::range or not.  <a href="namespacetrisycl_1_1detail.html#a839412f45f55b79e2b0557514de898b6">More...</a><br /></td></tr>
<tr class="separator:a839412f45f55b79e2b0557514de898b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Some global triSYCL configuration. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7841a75467a1e1bb143749fd29abeb73" name="a7841a75467a1e1bb143749fd29abeb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7841a75467a1e1bb143749fd29abeb73">&#9670;&nbsp;</a></span>__swizzled_base_vec__</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , int numElements&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetrisycl_1_1detail.html#a7841a75467a1e1bb143749fd29abeb73">trisycl::detail::__swizzled_base_vec__</a> = typedef <a class="el" href="classtrisycl_1_1detail_1_1vec.html">vec</a>&lt;DataType, numElements&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vec_2detail_2vec_8hpp_source.html#l00037">37</a> of file <a class="el" href="vec_2detail_2vec_8hpp_source.html">vec.hpp</a>.</p>

</div>
</div>
<a id="ac1b15596fd271fd6da762939850ff500" name="ac1b15596fd271fd6da762939850ff500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b15596fd271fd6da762939850ff500">&#9670;&nbsp;</a></span>all_true</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... v&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetrisycl_1_1detail.html#ac1b15596fd271fd6da762939850ff500">trisycl::detail::all_true</a> = typedef std::is_same&lt;<a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt;true, v...&gt;, <a class="el" href="structtrisycl_1_1detail_1_1bool__pack.html">bool_pack</a>&lt;v..., true&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="all__true_8hpp_source.html#l00016">16</a> of file <a class="el" href="all__true_8hpp_source.html">all_true.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae79251ae2eb2eb3f5f1418acf0f1c2f" name="aae79251ae2eb2eb3f5f1418acf0f1c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae79251ae2eb2eb3f5f1418acf0f1c2f">&#9670;&nbsp;</a></span>add_buffer_to_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &gt; trisycl::detail::add_buffer_to_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__execution.html#classtrisycl_1_1handler">handler</a> *&#160;</td>
          <td class="paramname"><em>command_group_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="group__data.html#structtrisycl_1_1detail_1_1buffer__base">detail::buffer_base</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_write_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a buffer as used by a task. </p>
<p >This is a proxy function to avoid complicated type recursion. </p>

<p class="definition">Definition at line <a class="el" href="handler_8hpp_source.html#l00532">532</a> of file <a class="el" href="handler_8hpp_source.html">handler.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  534</span>                                       {</div>
<div class="line"><span class="lineno">  535</span>  command_group_handler-&gt;<a class="code hl_variable" href="group__execution.html#a905f3edff6d74f38fe4555b86c4e485b">task</a>-&gt;add_buffer(<a class="code hl_variable" href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a>, is_write_mode);</div>
<div class="line"><span class="lineno">  536</span>  <span class="keywordflow">return</span> command_group_handler-&gt;<a class="code hl_variable" href="group__execution.html#a905f3edff6d74f38fe4555b86c4e485b">task</a>;</div>
<div class="line"><span class="lineno">  537</span>}</div>
<div class="ttc" id="agroup__execution_html_a905f3edff6d74f38fe4555b86c4e485b"><div class="ttname"><a href="group__execution.html#a905f3edff6d74f38fe4555b86c4e485b">trisycl::handler::task</a></div><div class="ttdeci">std::shared_ptr&lt; detail::task &gt; task</div><div class="ttdoc">Attach the task and accessors to it.</div><div class="ttdef"><b>Definition:</b> <a href="handler_8hpp_source.html#l00052">handler.hpp:52</a></div></div>
<div class="ttc" id="aopencl__spir_8h_html_a3fd8c63fddfb0d3ba796ef725a8cc5ce"><div class="ttname"><a href="opencl__spir_8h.html#a3fd8c63fddfb0d3ba796ef725a8cc5ce">b</a></div><div class="ttdeci">float const_func float b</div><div class="ttdef"><b>Definition:</b> <a href="opencl__spir_8h_source.html#l00915">opencl_spir.h:915</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="opencl__spir_8h_source.html#l00915">b</a>, and <a class="el" href="handler_8hpp_source.html#l00052">trisycl::handler::task</a>.</p>

</div>
</div>
<a id="a67927bda247fd79f6646b0644e39d4af" name="a67927bda247fd79f6646b0644e39d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67927bda247fd79f6646b0644e39d4af">&#9670;&nbsp;</a></span>assign_from_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; trisycl::detail::assign_from_tuple </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign arguments from a tuple. </p>

<p class="definition">Definition at line <a class="el" href="metaprogramming_8hpp_source.html#l00014">14</a> of file <a class="el" href="metaprogramming_8hpp_source.html">metaprogramming.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   14</span>                                                  {</div>
<div class="line"><span class="lineno">   15</span>  <span class="keyword">auto</span> expanded_assign = [&amp;](<span class="keyword">auto</span>&amp;&amp;... elems) <span class="keyword">mutable</span> {</div>
<div class="line"><span class="lineno">   16</span>    <span class="comment">// Assign from each tuple element expanded</span></div>
<div class="line"><span class="lineno">   17</span>    dest = { std::forward&lt;decltype(elems)&gt;(elems)... };</div>
<div class="line"><span class="lineno">   18</span>  };</div>
<div class="line"><span class="lineno">   19</span>  std::apply(expanded_assign, std::forward&lt;<span class="keyword">decltype</span>(tuple)&gt;(tuple));</div>
<div class="line"><span class="lineno">   20</span>  <span class="comment">// So we can use the result of the assignment expression if needed</span></div>
<div class="line"><span class="lineno">   21</span>  <span class="keywordflow">return</span> dest;</div>
<div class="line"><span class="lineno">   22</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf371d5b403131e992b56db5e96f7b50" name="aaf371d5b403131e992b56db5e96f7b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf371d5b403131e992b56db5e96f7b50">&#9670;&nbsp;</a></span>instantiate_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::instantiate_kernel </td>
          <td>(</td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate the kernel code. </p>
<p >To have a clear view of what a kernel is at the LLVM IR level even when a lot of optimizations are done (-O3), call the kernel from this function marked as <code>noinline</code>, otherwise the kernel code is inlined directly where it is used.</p>
<p >Actually some optimizations/code restructuring might duplicate the call to <code>instantiate_kernel</code> but the <code>noduplicate</code> attribute seems incompatible with <code>noinline</code> in Clang/LLVM 3.9.1, because the inlining happen when both attributes are used... </p>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00051">51</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   51</span>                                       {</div>
<div class="line"><span class="lineno">   52</span>  <span class="comment">/* The outlining compiler is expected to do some massage here or</span></div>
<div class="line"><span class="lineno">   53</span><span class="comment">     around and to insert some calls to \c serialize_arg and so on */</span></div>
<div class="line"><span class="lineno">   54</span>  f();</div>
<div class="line"><span class="lineno">   55</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a47f83d81ec55bc6b9930ae1cf9197462" name="a47f83d81ec55bc6b9930ae1cf9197462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f83d81ec55bc6b9930ae1cf9197462">&#9670;&nbsp;</a></span>launch_device_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelName , typename Kernel &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void trisycl::detail::launch_device_kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gather in a single function what is necessary for the device compiler to outline the kernel or to set up the kernel and serialize the arguments. </p>
<p >The <code>noinline</code> attribute is used to force this to appear as a real function the device compiler can massage. </p>
<p >Setup the task to be used to launch the kernel.</p>
<p >This is used by the outlining compiler.</p>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00091">91</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   92</span>                                             {<span class="comment"></span></div>
<div class="line"><span class="lineno">   93</span><span class="comment">  /** Setup the task to be used to launch the kernel.</span></div>
<div class="line"><span class="lineno">   94</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">   95</span><span class="comment">      This is used by the outlining compiler. */</span></div>
<div class="line"><span class="lineno">   96</span>  <a class="code hl_function" href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137">detail::set_kernel_task_marker</a>(t);</div>
<div class="line"><span class="lineno">   97</span>  <span class="comment">/* A simplified version for the device just to be able to extract</span></div>
<div class="line"><span class="lineno">   98</span><span class="comment">     the kernel itself.</span></div>
<div class="line"><span class="lineno">   99</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="comment">     It is not a real outlining but a good approximation to be</span></div>
<div class="line"><span class="lineno">  101</span><span class="comment">     massaged by a compiler later.</span></div>
<div class="line"><span class="lineno">  102</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  103</span><span class="comment">     Put the iteration space loops in the kernels for now, which makes</span></div>
<div class="line"><span class="lineno">  104</span><span class="comment">     sense for CPU emulation or FPGA pipelined execution.</span></div>
<div class="line"><span class="lineno">  105</span><span class="comment">  */</span></div>
<div class="line"><span class="lineno">  106</span>  instantiate_kernel&lt;KernelName&gt;(k);</div>
<div class="line"><span class="lineno">  107</span>}</div>
<div class="ttc" id="anamespacetrisycl_1_1detail_html_ae7f3e2db0e50d1419c67d55346253137"><div class="ttname"><a href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137">trisycl::detail::set_kernel_task_marker</a></div><div class="ttdeci">TRISYCL_WEAK_ATTRIB_PREFIX void TRISYCL_WEAK_ATTRIB_SUFFIX set_kernel_task_marker(detail::task &amp;) noexcept</div><div class="ttdoc">Set the task to be used to launch the kernel.</div><div class="ttdef"><b>Definition:</b> <a href="instantiate__kernel_8hpp_source.html#l00077">instantiate_kernel.hpp:77</a></div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="instantiate__kernel_8hpp_source.html#l00077">set_kernel_task_marker()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacetrisycl_1_1detail_a47f83d81ec55bc6b9930ae1cf9197462_cgraph.png" border="0" usemap="#anamespacetrisycl_1_1detail_a47f83d81ec55bc6b9930ae1cf9197462_cgraph" alt=""/></div>
<map name="anamespacetrisycl_1_1detail_a47f83d81ec55bc6b9930ae1cf9197462_cgraph" id="anamespacetrisycl_1_1detail_a47f83d81ec55bc6b9930ae1cf9197462_cgraph">
<area shape="rect" title="Gather in a single function what is necessary for the device compiler to outline the kernel or to set..." alt="" coords="5,5,148,47"/>
<area shape="rect" href="namespacetrisycl_1_1detail.html#ae7f3e2db0e50d1419c67d55346253137" title="Set the task to be used to launch the kernel." alt="" coords="196,5,339,47"/>
</map>
</div>

</div>
</div>
<a id="ad938eeb65b13d38543d5dd16fbace6b3" name="ad938eeb65b13d38543d5dd16fbace6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad938eeb65b13d38543d5dd16fbace6b3">&#9670;&nbsp;</a></span>rangeify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto trisycl::detail::rangeify </td>
          <td>(</td>
          <td class="paramtype">auto&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an explicit <a class="el" href="group__parallelism.html">range&lt;1&gt;</a> when an integral is provided or pass the value unchanged. </p>

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00075">75</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   75</span>                          {</div>
<div class="line"><span class="lineno">   76</span>      <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::integral&lt;<span class="keyword">decltype</span>(r)&gt;)</div>
<div class="line"><span class="lineno">   77</span>        <span class="keywordflow">return</span> <a class="code hl_class" href="group__parallelism.html#classtrisycl_1_1range">range</a> { r };</div>
<div class="line"><span class="lineno">   78</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   79</span>        <span class="keywordflow">return</span> r;</div>
<div class="line"><span class="lineno">   80</span>    };</div>
<div class="ttc" id="agroup__parallelism_html_classtrisycl_1_1range"><div class="ttname"><a href="group__parallelism.html#classtrisycl_1_1range">trisycl::range</a></div><div class="ttdoc">A SYCL range defines a multi-dimensional index range that can be used to define launch parallel compu...</div><div class="ttdef"><b>Definition:</b> <a href="range_8hpp_source.html#l00035">range.hpp:37</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="handler_8hpp_source.html#l00489">trisycl::handler::parallel_for()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacetrisycl_1_1detail_ad938eeb65b13d38543d5dd16fbace6b3_icgraph.png" border="0" usemap="#anamespacetrisycl_1_1detail_ad938eeb65b13d38543d5dd16fbace6b3_icgraph" alt=""/></div>
<map name="anamespacetrisycl_1_1detail_ad938eeb65b13d38543d5dd16fbace6b3_icgraph" id="anamespacetrisycl_1_1detail_ad938eeb65b13d38543d5dd16fbace6b3_icgraph">
<area shape="rect" title="Make an explicit range&lt;1&gt; when an integral is provided or pass the value unchanged." alt="" coords="232,5,383,32"/>
<area shape="rect" href="group__execution.html#a7ae93eadc5be8fd20273dd46172bc0ad" title="Kernel invocation method of a kernel defined as a kernel object, for the specified range and given an..." alt="" coords="5,5,184,32"/>
</map>
</div>

</div>
</div>
<a id="ae7f3e2db0e50d1419c67d55346253137" name="ae7f3e2db0e50d1419c67d55346253137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f3e2db0e50d1419c67d55346253137">&#9670;&nbsp;</a></span>set_kernel_task_marker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="global__config_8hpp.html#a2618b1336076abbe7158ea65cdb274c7">TRISYCL_WEAK_ATTRIB_PREFIX</a> void <a class="el" href="group__execution.html#ga70512575d55211271de3605c1fc21032">TRISYCL_WEAK_ATTRIB_SUFFIX</a> trisycl::detail::set_kernel_task_marker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrisycl_1_1detail_1_1task.html">detail::task</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the task to be used to launch the kernel. </p>
<p >This is actually a dummy function so that the device compiler can just grab the task for passing it to the argument serialization functions from the device runtime.</p>
<p >It is better to use a weak linkage than having this function with extern linkage:</p>
<ul>
<li>if the device compiler is used the function is kept by the compiler because full link and LTO is not applied before the device compiler passes are applied. So there is no partial evaluation in the compiler according to what is returned by this function;</li>
<li>if the device compiler is not used, the code still links and can be compiled. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00077">77</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   77</span>                                              {</div>
<div class="line"><span class="lineno">   78</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="instantiate__kernel_8hpp_source.html#l00091">launch_device_kernel()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_icgraph.png" border="0" usemap="#anamespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_icgraph" alt=""/></div>
<map name="anamespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_icgraph" id="anamespacetrisycl_1_1detail_ae7f3e2db0e50d1419c67d55346253137_icgraph">
<area shape="rect" title="Set the task to be used to launch the kernel." alt="" coords="196,5,339,47"/>
<area shape="rect" href="namespacetrisycl_1_1detail.html#a47f83d81ec55bc6b9930ae1cf9197462" title="Gather in a single function what is necessary for the device compiler to outline the kernel or to set..." alt="" coords="5,5,148,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a792746be38e2d14492e3cef8d69806fe" name="a792746be38e2d14492e3cef8d69806fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792746be38e2d14492e3cef8d69806fe">&#9670;&nbsp;</a></span>alignment_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto trisycl::detail::alignment_v = <a class="el" href="classtrisycl_1_1detail_1_1alignment.html">alignment</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="alignment__helper_8hpp_source.html#l00042">42</a> of file <a class="el" href="alignment__helper_8hpp_source.html">alignment_helper.hpp</a>.</p>

</div>
</div>
<a id="a8e4132dcb7f38fbccdda281ce3685069" name="a8e4132dcb7f38fbccdda281ce3685069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4132dcb7f38fbccdda281ce3685069">&#9670;&nbsp;</a></span>allow_any_dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> trisycl::detail::allow_any_dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">false</span></div>
</div><!-- fragment -->
<p>Map TRISYCL_ALLOW_ANY_DIMENSION to a constexpr variable. </p>

<p class="definition">Definition at line <a class="el" href="global__config_8hpp_source.html#l00033">33</a> of file <a class="el" href="global__config_8hpp_source.html">global_config.hpp</a>.</p>

</div>
</div>
<a id="a1e0c17dc79de5a90f41d4fe6c70c5a67" name="a1e0c17dc79de5a90f41d4fe6c70c5a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0c17dc79de5a90f41d4fe6c70c5a67">&#9670;&nbsp;</a></span>enum_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto constexpr trisycl::detail::enum_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] (<span class="keyword">auto</span> enum_start, <span class="keyword">auto</span> enum_end) {</div>
<div class="line">  <span class="keywordflow">return</span> 1 + <a class="code hl_variable" href="namespacetrisycl_1_1detail.html#aed50f30c92c9246d58d7ce448d511f07">enum_distance</a>(enum_start, enum_end);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacetrisycl_1_1detail_html_aed50f30c92c9246d58d7ce448d511f07"><div class="ttname"><a href="namespacetrisycl_1_1detail.html#aed50f30c92c9246d58d7ce448d511f07">trisycl::detail::enum_distance</a></div><div class="ttdeci">auto constexpr enum_distance</div><div class="ttdoc">Get the distance between 2 enum underlying values.</div><div class="ttdef"><b>Definition:</b> <a href="enum_8hpp_source.html#l00028">enum.hpp:28</a></div></div>
</div><!-- fragment -->
<p>Count the number of enums between 2 enum boundaries, including the boundaries. </p>

<p class="definition">Definition at line <a class="el" href="enum_8hpp_source.html#l00037">37</a> of file <a class="el" href="enum_8hpp_source.html">enum.hpp</a>.</p>

</div>
</div>
<a id="aed50f30c92c9246d58d7ce448d511f07" name="aed50f30c92c9246d58d7ce448d511f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed50f30c92c9246d58d7ce448d511f07">&#9670;&nbsp;</a></span>enum_distance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto constexpr trisycl::detail::enum_distance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] (<span class="keyword">auto</span> enum_start, <span class="keyword">auto</span> enum_end) {</div>
<div class="line">  <span class="keyword">static_assert</span>(std::is_same_v&lt;<span class="keyword">decltype</span>(enum_start), <span class="keyword">decltype</span>(enum_end)&gt;,</div>
<div class="line">                <span class="stringliteral">&quot;enum_start and auto enum_end should have the same type&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="namespacetrisycl_1_1detail.html#a9d6a3bd304cf35f3ea76b6fdbe45fab7">underlying_value</a>(enum_end) - <a class="code hl_variable" href="namespacetrisycl_1_1detail.html#a9d6a3bd304cf35f3ea76b6fdbe45fab7">underlying_value</a>(enum_start);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacetrisycl_1_1detail_html_a9d6a3bd304cf35f3ea76b6fdbe45fab7"><div class="ttname"><a href="namespacetrisycl_1_1detail.html#a9d6a3bd304cf35f3ea76b6fdbe45fab7">trisycl::detail::underlying_value</a></div><div class="ttdeci">auto constexpr underlying_value</div><div class="ttdoc">Get the enum value as an integral value of the underlying integer type.</div><div class="ttdef"><b>Definition:</b> <a href="enum_8hpp_source.html#l00021">enum.hpp:21</a></div></div>
</div><!-- fragment -->
<p>Get the distance between 2 enum underlying values. </p>

<p class="definition">Definition at line <a class="el" href="enum_8hpp_source.html#l00028">28</a> of file <a class="el" href="enum_8hpp_source.html">enum.hpp</a>.</p>

</div>
</div>
<a id="a839412f45f55b79e2b0557514de898b6" name="a839412f45f55b79e2b0557514de898b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839412f45f55b79e2b0557514de898b6">&#9670;&nbsp;</a></span>is_range_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto trisycl::detail::is_range_v = <a class="el" href="structtrisycl_1_1detail_1_1is__range.html">is_range</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variable to check if a type is a sycl::range or not. </p>

<p class="definition">Definition at line <a class="el" href="range_8hpp_source.html#l00090">90</a> of file <a class="el" href="range_8hpp_source.html">range.hpp</a>.</p>

</div>
</div>
<a id="adb8b9cd14ace3a07bc7c2fb794246165" name="adb8b9cd14ace3a07bc7c2fb794246165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8b9cd14ace3a07bc7c2fb794246165">&#9670;&nbsp;</a></span>prevent_arguments_from_optimization</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto trisycl::detail::prevent_arguments_from_optimization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] (<span class="keyword">auto</span> &amp; ...args) {</div>
<div class="line">  </div>
<div class="line">  [[gnu::used]] <span class="keyword">static</span> <span class="keyword">auto</span> keep = std::make_tuple(&amp; args...);</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Avoid the interprocedural optimization to remove these arguments in the kernel instantiation by relying on some dummy static variables. </p>
<p >Using <code></code>[[gnu::used]] does not work on arguments but only on static variable, so use this function. </p>

<p class="definition">Definition at line <a class="el" href="instantiate__kernel_8hpp_source.html#l00028">28</a> of file <a class="el" href="instantiate__kernel_8hpp_source.html">instantiate_kernel.hpp</a>.</p>

</div>
</div>
<a id="a9d6a3bd304cf35f3ea76b6fdbe45fab7" name="a9d6a3bd304cf35f3ea76b6fdbe45fab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6a3bd304cf35f3ea76b6fdbe45fab7">&#9670;&nbsp;</a></span>underlying_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto constexpr trisycl::detail::underlying_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [] (<span class="keyword">auto</span> e) {</div>
<div class="line">  <span class="keyword">using </span>value_t = std::underlying_type_t&lt;<span class="keyword">decltype</span>(e)&gt;;</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>value_t<span class="keyword">&gt;</span>(e);</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Get the enum value as an integral value of the underlying integer type. </p>

<p class="definition">Definition at line <a class="el" href="enum_8hpp_source.html#l00021">21</a> of file <a class="el" href="enum_8hpp_source.html">enum.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="sycl_2vendor_2Xilinx_2acap_2aie_2axi__stream__switch_8hpp_source.html#l00373">trisycl::vendor::xilinx::acap::aie::axi_stream_switch&lt; AXIStreamGeography &gt;::input()</a>, and <a class="el" href="sycl_2vendor_2Xilinx_2acap_2aie_2axi__stream__switch_8hpp_source.html#l00383">trisycl::vendor::xilinx::acap::aie::axi_stream_switch&lt; AXIStreamGeography &gt;::output()</a>.</p>

</div>
</div>
<a id="a40b36cdcf4170235b1c3f0aacac15f28" name="a40b36cdcf4170235b1c3f0aacac15f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b36cdcf4170235b1c3f0aacac15f28">&#9670;&nbsp;</a></span>use_native_work_item</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> trisycl::detail::use_native_work_item</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    <span class="keyword">false</span></div>
</div><!-- fragment -->
<p>Map TRISYCL_USE_OPENCL_ND_RANGE to a constexpr variable. </p>

<p class="definition">Definition at line <a class="el" href="global__config_8hpp_source.html#l00048">48</a> of file <a class="el" href="global__config_8hpp_source.html">global_config.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="handler_8hpp_source.html#l00264">trisycl::handler::parallel_for()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 9 2023 11:27:40 for triSYCL implementation of SYCL by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
