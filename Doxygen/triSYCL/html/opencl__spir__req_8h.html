<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>triSYCL implementation of SYCL: include/triSYCL/detail/SPIR/opencl_spir_req.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">triSYCL implementation of SYCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_aaf3c766ec178046651f3200d7a96209.html">triSYCL</a></li><li class="navelem"><a class="el" href="dir_f344767bae51d34c648f686d6eb83a10.html">detail</a></li><li class="navelem"><a class="el" href="dir_bef60b290399884c93f61e40e2025bbb.html">SPIR</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">opencl_spir_req.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cstddef&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for opencl_spir_req.h:</div>
<div class="dyncontent">
<div class="center"><img src="opencl__spir__req_8h__incl.png" border="0" usemap="#ainclude_2triSYCL_2detail_2SPIR_2opencl__spir__req_8h" alt=""/></div>
<map name="ainclude_2triSYCL_2detail_2SPIR_2opencl__spir__req_8h" id="ainclude_2triSYCL_2detail_2SPIR_2opencl__spir__req_8h">
<area shape="rect" title=" " alt="" coords="5,5,169,47"/>
<area shape="rect" title=" " alt="" coords="55,95,120,121"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="opencl__spir__req_8h__dep__incl.png" border="0" usemap="#ainclude_2triSYCL_2detail_2SPIR_2opencl__spir__req_8hdep" alt=""/></div>
<map name="ainclude_2triSYCL_2detail_2SPIR_2opencl__spir__req_8hdep" id="ainclude_2triSYCL_2detail_2SPIR_2opencl__spir__req_8hdep">
<area shape="rect" title=" " alt="" coords="25,5,189,47"/>
<area shape="rect" href="opencl__spir__helpers_8hpp.html" title="Adds helper functions to populate Id&#39;s and Range&#39;s with OpenCL SPIR intrinsics data: e...." alt="" coords="5,95,208,136"/>
</map>
</div>
</div>
<p><a href="opencl__spir__req_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0bcdca9f6e5923ea191d934ec3400d9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a0bcdca9f6e5923ea191d934ec3400d9e">__global</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(1)))</td></tr>
<tr class="memdesc:a0bcdca9f6e5923ea191d934ec3400d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Added according to pocl/examples/example1-spir64/generate_spir.sh.  <a href="opencl__spir__req_8h.html#a0bcdca9f6e5923ea191d934ec3400d9e">More...</a><br /></td></tr>
<tr class="separator:a0bcdca9f6e5923ea191d934ec3400d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d401f6ba8f83048211693549eba342"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a16d401f6ba8f83048211693549eba342">__local</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(2)))</td></tr>
<tr class="separator:a16d401f6ba8f83048211693549eba342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b608b5ba1de1611f39147081570d4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a27b608b5ba1de1611f39147081570d4e">__constant</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(3)))</td></tr>
<tr class="separator:a27b608b5ba1de1611f39147081570d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a45efe1ccd4ca18b19e5584bd0254c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a82a45efe1ccd4ca18b19e5584bd0254c">__private</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(4)))</td></tr>
<tr class="separator:a82a45efe1ccd4ca18b19e5584bd0254c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347d1af1cbc03c4b42216c49353868bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a347d1af1cbc03c4b42216c49353868bf">__generic</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(5)))</td></tr>
<tr class="separator:a347d1af1cbc03c4b42216c49353868bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581bf62ead660af113e4c2dd690b13a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a581bf62ead660af113e4c2dd690b13a4">const_func</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((const))</td></tr>
<tr class="separator:a581bf62ead660af113e4c2dd690b13a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfb79d07b035c8a13fdfa16287088af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a5cfb79d07b035c8a13fdfa16287088af">readonly</a>&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((pure))</td></tr>
<tr class="separator:a5cfb79d07b035c8a13fdfa16287088af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a273f952356867fd091b72013fd8072ae"><td class="memItemLeft" align="right" valign="top">std::size_t <a class="el" href="opencl__spir__req_8h.html#a581bf62ead660af113e4c2dd690b13a4">const_func</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a> ((overloadable)) get_local_id(unsigned int dimindx)</td></tr>
<tr class="memdesc:a273f952356867fd091b72013fd8072ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unique local work-item ID i.e.  <a href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">More...</a><br /></td></tr>
<tr class="separator:a273f952356867fd091b72013fd8072ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04577b2fc18a306a881fd5e33e5b40ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="opencl__spir__req_8h.html#a04577b2fc18a306a881fd5e33e5b40ba">printf</a> (<a class="el" href="opencl__spir__req_8h.html#a27b608b5ba1de1611f39147081570d4e">__constant</a> const char *st,...)</td></tr>
<tr class="separator:a04577b2fc18a306a881fd5e33e5b40ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a27b608b5ba1de1611f39147081570d4e" name="a27b608b5ba1de1611f39147081570d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b608b5ba1de1611f39147081570d4e">&#9670;&nbsp;</a></span>__constant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __constant&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(3)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00043">43</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<a id="a347d1af1cbc03c4b42216c49353868bf" name="a347d1af1cbc03c4b42216c49353868bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347d1af1cbc03c4b42216c49353868bf">&#9670;&nbsp;</a></span>__generic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __generic&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(5)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00045">45</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<a id="a0bcdca9f6e5923ea191d934ec3400d9e" name="a0bcdca9f6e5923ea191d934ec3400d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcdca9f6e5923ea191d934ec3400d9e">&#9670;&nbsp;</a></span>__global</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __global&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Added according to pocl/examples/example1-spir64/generate_spir.sh. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000171">Todo:</a></b></dt><dd>avoid this hack </dd></dl>

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00041">41</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<a id="a16d401f6ba8f83048211693549eba342" name="a16d401f6ba8f83048211693549eba342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d401f6ba8f83048211693549eba342">&#9670;&nbsp;</a></span>__local</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __local&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(2)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00042">42</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<a id="a82a45efe1ccd4ca18b19e5584bd0254c" name="a82a45efe1ccd4ca18b19e5584bd0254c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a45efe1ccd4ca18b19e5584bd0254c">&#9670;&nbsp;</a></span>__private</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __private&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((address_space(4)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00044">44</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<a id="a581bf62ead660af113e4c2dd690b13a4" name="a581bf62ead660af113e4c2dd690b13a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581bf62ead660af113e4c2dd690b13a4">&#9670;&nbsp;</a></span>const_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define const_func&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((const))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00047">47</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<a id="a5cfb79d07b035c8a13fdfa16287088af" name="a5cfb79d07b035c8a13fdfa16287088af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfb79d07b035c8a13fdfa16287088af">&#9670;&nbsp;</a></span>readonly</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define readonly&#160;&#160;&#160;<a class="el" href="opencl__spir__req_8h.html#a273f952356867fd091b72013fd8072ae">__attribute__</a>((pure))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="opencl__spir__req_8h_source.html#l00048">48</a> of file <a class="el" href="opencl__spir__req_8h_source.html">opencl_spir_req.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a273f952356867fd091b72013fd8072ae" name="a273f952356867fd091b72013fd8072ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273f952356867fd091b72013fd8072ae">&#9670;&nbsp;</a></span>__attribute__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="opencl__spir__req_8h.html#a581bf62ead660af113e4c2dd690b13a4">const_func</a> __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(overloadable)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unique local work-item ID i.e. </p>
<p >get_global_offset returns the offset values specified in global_work_offset argument to clEnqueueNDRangeKernel.</p>
<p >get_group_id returns the work-group ID which is a number from 0 .</p>
<p >Returns the number of work-groups that will execute a kernel for dimension identified by dimindx.</p>
<p >Returns the number of local work-items specified in dimension identified by dimindx.</p>
<p >Returns the number of global work-items specified for dimension identified by dimindx.</p>
<p >Returns the unique global work-item ID value for dimension identified by dimindx.</p>
<p >a work-item within a specific work-group for dimension identified by dimindx. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_local_id() returns 0. For clEnqueueTask, this returns 0.</p>
<p >The global work-item ID specifies the work-item ID based on the number of global work-items specified to execute the kernel. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_global_id() returns 0. For clEnqueueTask, this returns 0.</p>
<p >This value is given by the global_work_size argument to clEnqueueNDRangeKernel. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_global_size() returns 1. For clEnqueueTask, this always returns 1.</p>
<p >This value is given by the local_work_size argument to clEnqueueNDRangeKernel if local_work_size is not NULL; otherwise the OpenCL implementation chooses an appropriate local_work_size value which is returned by this function. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_local_size() returns 1. For clEnqueueTask, this always returns 1.</p>
<p >Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_num_groups () returns 1. For clEnqueueTask, this always returns 1.</p>
<p >. get_num_groups(dimindx) – 1. Valid values of dimindx are 0 to get_work_dim() – 1. For other values, get_group_id() returns 0. For clEnqueueTask, this returns 0.</p>
<p >Valid values of dimindx are 0 to get_work_dim() – 1. For other values, get_global_offset() returns 0. For clEnqueueTask, this returns 0.</p>
<p >Write color value to location specified by coord.xy in the 2D image layer identified by index coord.z in the 2D image array.</p>
<p >Use coord.xy to do an element lookup in the 2D image layer identified by index coord.z in the 2D image array.</p>
<p >Return the number of images in the 1D image array.</p>
<p >Return the number of images in the 2D image array.</p>
<p >Return the 3D image width, height, and depth as an int4 type.</p>
<p >Return the 2D image width and height as an int2 type.</p>
<p >Return the image channel order.</p>
<p >Return the image depth in pixels.</p>
<p >Return the image height in pixels.</p>
<p >Return the image width in pixels.</p>
<p >Write color value to location specified by coordinate (x, y, z) in the 3D image object specified by image.</p>
<p >Use the coordinate (coord.x, coord.y, coord.z) to do an element lookup in the 3D image object specified by image.</p>
<p >Write color value to location specified by coordinate (x, y) in the 2D image object specified by image.</p>
<p >Use the coordinate (x, y) to do an element lookup in the 2D image object specified by image.</p>
<p >The shuffle and shuffle2 built-in functions construct a permutation of elements from one or two input vectors respectively that are of the same type, returning a vector with the same element type as the input and length that is the same as the shuffle mask.</p>
<p >Swaps the old value stored at location p with new value given by val.</p>
<p >unsigned int atomic_sub ( volatile __global unsigned int *p, unsigned int val) int atomic_sub (volatile __local int *p, int val) unsigned int atomic_sub ( volatile __local unsigned int *p, unsigned int val) Read the 32-bit value (referred to as old) stored at location pointed by p.</p>
<p >Read the 32-bit value (referred to as old) stored at location pointed by p.</p>
<p >Prefetch num_elements * sizeof(gentype) bytes into the global cache.</p>
<p >Wait for events that identify the async_work_group_copy operations to complete.</p>
<p >Perform an async gather of num_elements gentype elements from src to dst.</p>
<p >event_t async_work_group_copy ( __global gentype *dst, const __local gentype *src, size_t num_elements, event_t event) Perform an async copy of num_elements gentype elements from src to dst.</p>
<p >Write memory barrier that orders only stores.</p>
<p >Read memory barrier that orders only loads.</p>
<p >Orders loads and stores of a work-item executing a kernel.</p>
<p >For n = 1, 2, 4, 8 and 16 read sizeof (halfn) bytes of data from address (p + (offset * n)).</p>
<p >The floatn value given by data is converted to a halfn value using the appropriate rounding mode.</p>
<p >The float value given by data is first converted to a half value using the appropriate rounding mode.</p>
<p >Read sizeof (halfn) bytes of data from address (p + (offset * n)).</p>
<p >Read sizeof (half) bytes of data from address (p + offset).</p>
<p >Write sizeof (gentypen) bytes given by data to address (p + (offset * n)).</p>
<p >Return sizeof (gentypen) bytes of data read from address (p + (offset * n)).</p>
<p >For each component of a vector type, result[i] = if MSB of c[i] is set ? b[i] : a[i].</p>
<p >Each bit of the result is the corresponding bit of a if the corresponding bit of c is 0.</p>
<p >Returns 1 if the most significant bit in all components of x is set; otherwise returns 0.</p>
<p >Returns 1 if the most significant bit in any component of x is set; otherwise returns 0.</p>
<p >Test for sign bit.</p>
<p >Test if arguments are unordered.</p>
<p >Test if arguments are ordered.</p>
<p >Test for a normal value.</p>
<p >Test for a NaN.</p>
<p >Test for infinity value (+ve or –ve) .</p>
<p >Test for finite value.</p>
<p >Returns the component-wise compare of (x &lt; y) || (x &gt; y) .</p>
<p >Returns the component-wise compare of x &lt;= y.</p>
<p >Returns the component-wise compare of x &lt; y.</p>
<p >Returns the component-wise compare of x &gt;= y.</p>
<p >Returns the component-wise compare of x &gt; y.</p>
<p >Returns the component-wise compare of x != y.</p>
<p >intn isequal (floatn x, floatn y) Returns the component-wise compare of x == y.</p>
<p >Returns the length of vector p computed as: half_sqrt(p.x2 + p.y2 + ...)</p>
<p >Returns fast_length(p0 – p1).</p>
<p >Returns a vector in the same direction as p but with a length of 1.</p>
<p >Return the length of vector p, i.e., sqrt(p.x2 + p.y 2 + ...)</p>
<p >Returns the distance between p0 and p1.</p>
<p >Compute dot product.</p>
<p >Returns the cross product of p0.xyz and p1.xyz.</p>
<p >Returns 1.0 if x &gt; 0, -0.0 if x = -0.0, +0.0 if x = +0.0, or –1.0 if x &lt; 0.</p>
<p >Returns 0.0 if x &lt;= edge0 and 1.0 if x &gt;= edge1 and performs smooth Hermite interpolation between 0 and 1when edge0 &lt; x &lt; edge1.</p>
<p >Returns 0.0 if x &lt; edge, otherwise it returns 1.0.</p>
<p >Converts degrees to radians, i.e.</p>
<p >Returns the linear blend of x &amp; y implemented as: x + (y – x) * a a must be a value in the range 0.0 … 1.0.</p>
<p >Converts radians to degrees, i.e.</p>
<p >Returns fmin(fmax(x, minval), maxval).</p>
<p >Multiply two 24-bit integer values x and y.</p>
<p >Multiply two 24-bit integer values x and y and add the 32-bit integer result to the 32-bit integer z.</p>
<p >result[i] = ((long)hi[i] &lt;&lt; 32) | lo[i] result[i] = ((ulong)hi[i] &lt;&lt; 32) | lo[i]</p>
<p >result[i] = ((int)hi[i] &lt;&lt; 16) | lo[i] result[i] = ((uint)hi[i] &lt;&lt; 16) | lo[i]</p>
<p >result[i] = ((short)hi[i] &lt;&lt; 8) | lo[i] result[i] = ((ushort)hi[i] &lt;&lt; 8) | lo[i]</p>
<p >Returns x - y and saturates the result.</p>
<p >For each element in v, the bits are shifted left by the number of bits given by the corresponding element in i (subject to usual shift modulo rules described in section 6.3).</p>
<p >Computes x * y and returns the high half of the product of x and y.</p>
<p >Returns a * b + c and saturates the result.</p>
<p >Returns mul_hi(a, b) + c.</p>
<p >Returns the number of leading 0-bits in x, starting at the most significant bit position.</p>
<p >Returns min(max(x, minval), maxval).</p>
<p >Returns (x + y + 1) &gt;&gt; 1.</p>
<p >Returns (x + y) &gt;&gt; 1.</p>
<p >Returns x + y and saturates the result.</p>
<p >Returns | x – y | without modulo overflow.</p>
<p >Returns | x |.</p>
<p >Compute tangent over an implementation-defined range.</p>
<p >Compute square root over an implementation-defined range.</p>
<p >Compute sine over an implementation-defined range.</p>
<p >Compute inverse square root over an implementationdefined range.</p>
<p >Compute reciprocal over an implementation-defined range.</p>
<p >Compute a base 10 logarithm over an implementationdefined range.</p>
<p >Compute a base 2 logarithm over an implementationdefined range.</p>
<p >Compute natural logarithm over an implementationdefined range.</p>
<p >Compute the base- 10 exponential of x over an implementation-defined range.</p>
<p >Compute the base- 2 exponential of x over an implementation-defined range.</p>
<p >Compute the base- e exponential of x over an implementation-defined range.</p>
<p >Compute x / y over an implementation-defined range.</p>
<p >Compute cosine over an implementation-defined range.</p>
<p >Compute reciprocal.</p>
<p >Compute the base- 10 exponential of x.</p>
<p >Compute the base- 2 exponential of x.</p>
<p >Compute x / y.</p>
<p >Round to integral value using the round to zero rounding mode.</p>
<p >Compute the gamma function.</p>
<p >Compute tan (PI * x).</p>
<p >Compute hyperbolic tangent.</p>
<p >Compute tangent.</p>
<p >Compute square root.</p>
<p >Compute sin (PI * x).</p>
<p >Compute hyperbolic sine.</p>
<p >Compute sine and cosine of x.</p>
<p >Compute sine.</p>
<p >Compute inverse square root.</p>
<p >Return the integral value nearest to x rounding halfway cases away from zero, regardless of the current rounding direction.</p>
<p >Compute x to the power 1/y.</p>
<p >Round to integral value (using round to nearest even rounding mode) in floating-point format.</p>
<p >The remquo function computes the value r such that r = x - n*y, where n is the integer nearest the exact value of x/y.</p>
<p >Compute the value r such that r = x - n*y, where n is the integer nearest the exact value of x/y.</p>
<p >Compute x to the power y, where x is &gt;= 0.</p>
<p >Compute x to the power y, where y is an integer.</p>
<p >Compute x to the power y.</p>
<p >Computes the next representable single-precision floating-point value following x in the direction of y.</p>
<p >Returns a quiet NaN.</p>
<p >Decompose a floating-point number.</p>
<p >Returns x if | x | &lt; | y |, y if | y | &lt; | x |, otherwise fmin(x, y).</p>
<p >Returns x if | x | &gt; | y |, y if | y | &gt; | x |, otherwise fmax(x, y).</p>
<p >mad approximates a * b + c.</p>
<p >Compute the exponent of x, which is the integral part of logr | x |.</p>
<p >Compute a base e logarithm of (1.0 + x).</p>
<p >Compute a base 10 logarithm.</p>
<p >Compute a base 2 logarithm.</p>
<p >Compute natural logarithm.</p>
<p >Log gamma function.</p>
<p >Multiply x by 2 to the power n.</p>
<p >Return the exponent as an integer value.</p>
<p >Compute the value of the square root of x^2+ y^2 without undue overflow or underflow.</p>
<p >Extract mantissa and exponent from x.</p>
<p >Returns fmin( x – floor (x), 0x1.fffffep-1f ).</p>
<p >Modulus.</p>
<p >Returns y if y &lt; x, otherwise it returns x.</p>
<p >Returns y if x &lt; y, otherwise it returns x.</p>
<p >Returns the correctly rounded floating-point representation of the sum of c with the infinitely precise product of a and b.</p>
<p >Round to integral value using the round to –ve infinity rounding mode.</p>
<p >x - y if x &gt; y, +0 if x is less than or equal to y.</p>
<p >Compute absolute value of a floating-point number.</p>
<p >Compute e^x- 1.0.</p>
<p >Exponential base 10 function.</p>
<p >Exponential base 2 function.</p>
<p >Compute the base- e exponential of x.</p>
<p >Error function encountered in integrating the normal distribution.</p>
<p >Complementary error function.</p>
<p >Compute cos (PI * x).</p>
<p >Compute hyperbolic consine.</p>
<p >Compute cosine.</p>
<p >Returns x with its sign changed to match the sign of y.</p>
<p >Round to integral value using the round to +ve infinity rounding mode.</p>
<p >Compute cube-root.</p>
<p >Compute atan2 (y, x) / PI.</p>
<p >Compute atan (x) / PI.</p>
<p >Hyperbolic arc tangent.</p>
<p >Arc tangent of y / x.</p>
<p >Arc tangent function.</p>
<p >Compute asin (x) / PI.</p>
<p >Inverse hyperbolic sine.</p>
<p >Arc sine function.</p>
<p >Compute acos (x) / PI.</p>
<p >Inverse hyperbolic cosine.</p>
<p >Arc cosine function.</p>
<p >get_global_offset returns the offset values specified in global_work_offset argument to clEnqueueNDRangeKernel.</p>
<p >get_group_id returns the work-group ID which is a number from 0 .</p>
<p >Returns the number of work-groups that will execute a kernel for dimension identified by dimindx.</p>
<p >Returns the unique local work-item ID i.e.</p>
<p >Returns the number of local work-items specified in dimension identified by dimindx.</p>
<p >Returns the unique global work-item ID value for dimension identified by dimindx.</p>
<p >Returns the number of global work-items specified for dimension identified by dimindx.</p>
<p >This is the value given to the work_dim argument specified in clEnqueueNDRangeKernel. For clEnqueueTask, this returns 1.</p>
<p >This value is given by the global_work_size argument to clEnqueueNDRangeKernel. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_global_size() returns 1. For clEnqueueTask, this always returns 1.</p>
<p >The global work-item ID specifies the work-item ID based on the number of global work-items specified to execute the kernel. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_global_id() returns 0. For clEnqueueTask, this returns 0.</p>
<p >This value is given by the local_work_size argument to clEnqueueNDRangeKernel if local_work_size is not NULL; otherwise the OpenCL implementation chooses an appropriate local_work_size value which is returned by this function. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_local_size() returns 1. For clEnqueueTask, this always returns 1.</p>
<p >a work-item within a specific work-group for dimension identified by dimindx. Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_local_id() returns 0. For clEnqueueTask, this returns 0.</p>
<p >Valid values of dimindx are 0 to get_work_dim() – 1. For other values of dimindx, get_num_groups () returns 1. For clEnqueueTask, this always returns 1.</p>
<p >. get_num_groups(dimindx) – 1. Valid values of dimindx are 0 to get_work_dim() – 1. For other values, get_group_id() returns 0. For clEnqueueTask, this returns 0.</p>
<p >Valid values of dimindx are 0 to get_work_dim() – 1. For other values, get_global_offset() returns 0. For clEnqueueTask, this returns 0.</p>
<p >Rounding of intermediate products shall not occur. Edge case behavior is per the IEEE 754-2008 standard.</p>
<p >If one argument is a NaN, <a class="el" href="namespacetrisycl.html#a9b1133b7c5faaa9a27b384865f76aa2e">fmax()</a> returns the other argument. If both arguments are NaNs, <a class="el" href="namespacetrisycl.html#a9b1133b7c5faaa9a27b384865f76aa2e">fmax()</a> returns a NaN.</p>
<p >If one argument is a NaN, <a class="el" href="namespacetrisycl.html#af84ee790b7a1b0de95fe3275096919ee">fmin()</a> returns the other argument. If both arguments are NaNs, <a class="el" href="namespacetrisycl.html#af84ee790b7a1b0de95fe3275096919ee">fmin()</a> returns a NaN.</p>
<p >Returns x – y * trunc (x/y).</p>
<p >floor(x) is returned in iptr.</p>
<p >For each component the mantissa returned is a float with magnitude in the interval [1/2, 1) or 0. Each component of x equals mantissa returned * 2^exp.</p>
<p >Returns the natural logarithm of the absolute value of the gamma function. The sign of the gamma function is returned in the signp argument of lgamma_r.</p>
<p >Whether or how the product of a * b is rounded and how supernormal or subnormal intermediate products are handled is not defined. mad is intended to be used where speed is preferred over accuracy.</p>
<p >The modf function breaks the argument x into integral and fractional parts, each of which has the same sign as the argument. It stores the integral part in the object pointed to by iptr.</p>
<p >The nancode may be placed in the significand of the resulting NaN.</p>
<p >Thus, if y is less than x, nextafter() returns the largest representable floating-point number less than x.</p>
<p >If there are two integers closest to x/y, n shall be the even one. If r is zero, it is given the same sign as x.</p>
<p >If there are two integers closest to x/y, n shall be the even one. If r is zero, it is given the same sign as x. This is the same value that is returned by the remainder function. remquo also calculates the lower seven bits of the integral quotient x/y, and gives that value the same sign as x/y. It stores this signed value in the object pointed to by quo.</p>
<p >Refer to section 7.1 for description of rounding modes.</p>
<p >The computed sine is the return value and computed cosine is returned in cosval.</p>
<p >x must be in the range -2^16 ... +2^16.</p>
<p >x must be in the range -2^16 … +2^16.</p>
<p >x must be in the range -216 … +216.</p>
<p >The maximum error is implementation-defined.</p>
<p >The maximum error is implementation defined.</p>
<p >The maximum error is implementationdefined.</p>
<p >The range of x and y are implementation-defined. The maximum error is implementation-defined.</p>
<p >The intermediate sum does not modulo overflow.</p>
<p >Results are undefined if minval &gt; maxval.</p>
<p >Bits shifted off the left side of the element are shifted back in from the right.</p>
<p >Refer to definition of mul24 to see how the 24-bit integer multiplication is performed.</p>
<p >x and y are 32-bit integers but only the low 24-bits are used to perform the multiplication. mul24 should only be used when values in x and y are in the range [- 2^23, 2^23-1] if x and y are signed integers and in the range [0, 2^24-1] if x and y are unsigned integers. If x and y are not in this range, the multiplication result is implementation-defined.</p>
<p >(180 / PI) * radians.</p>
<p >If x and y are infinite or NaN, the return values are undefined.</p>
<p >If a is not in the range 0.0 … 1.0, the return values are undefined.</p>
<p >(PI / 180) * degrees.</p>
<p >This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to: gentype t; t = clamp ((x – edge0) / (edge1 – edge0), 0, 1); return t * t * (3 – 2 * t); Results are undefined if edge0 &gt;= edge1 or if x, edge0 or edge1 is a NaN.</p>
<p >Returns 0.0 if x is a NaN.</p>
<p >The w component of float4 result returned will be 0.0.</p>
<p >This is calculated as length(p0 – p1).</p>
<p >fast_normalize is computed as: p * half_rsqrt (p.x^2 + p.y^2 + … ) The result shall be within 8192 ulps error from the infinitely precise result of if (all(p == 0.0f)) result = p; else result = p / sqrt (p.x^2 + p.y^2 + ... ); with the following exceptions: 1) If the sum of squares is greater than FLT_MAX then the value of the floating-point values in the result vector are undefined. 2) If the sum of squares is less than FLT_MIN then the implementation may return back p. 3) If the device is in “denorms are flushed to zero” mode, individual operand elements with magnitude less than sqrt(FLT_MIN) may be flushed to zero before proceeding with the calculation.</p>
<p >isordered() takes arguments x and y, and returns the result isequal(x, x) &amp;&amp; isequal(y, y).</p>
<p >isunordered() takes arguments x and y, returning non-zero if x or y is NaN, and zero otherwise.</p>
<p >The scalar version of the function returns a 1 if the sign bit in the float is set else returns 0. The vector version of the function returns the following for each component in floatn: a -1 if the sign bit in the float is set else returns 0.</p>
<p >Otherwise it is the corresponding bit of b.</p>
<p >For a scalar type, result = c ? b : a.</p>
<p >The address computed as (p + (offset * n)) must be 8-bit aligned if gentype is char, uchar; 16-bit aligned if gentype is short, ushort; 32-bit aligned if gentype is int, uint, float; 64-bit aligned if gentype is long, ulong.</p>
<p >The data read is interpreted as a half value. The half value is converted to a float value and the float value is returned. The read address computed as (p + offset) must be 16-bit aligned.</p>
<p >The data read is interpreted as a halfn value. The halfn value read is converted to a floatn value and the floatn value is returned. The read address computed as (p + (offset * n)) must be 16-bit aligned.</p>
<p >The half value is then written to address computed as (p + offset). The address computed as (p + offset) must be 16- bit aligned. vstore_half use the current rounding mode. The default current rounding mode is round to nearest even.</p>
<p >The halfn value is then written to address computed as (p + (offset * n)). The address computed as (p + (offset * n)) must be 16-bit aligned. vstore_halfn uses the current rounding mode. The default current rounding mode is round to nearest even.</p>
<p >The data read is interpreted as a halfn value. The halfn value read is converted to a floatn value and the floatn value is returned. The address computed as (p + (offset * n)) must be aligned to sizeof (halfn) bytes. For n = 3, vloada_half3 reads a half3 from address (p + (offset * 4)) and returns a float3. The address computed as (p + (offset * 4)) must be aligned to sizeof (half) * 4 bytes.</p>
<p >For n = 1, 2, 4, 8 and 16, the halfn value is written to the address computed as (p + (offset</p><ul>
<li><p class="startli">n)). The address computed as (p + (offset * n)) must be aligned to sizeof (halfn) bytes. For n = 3, the half3 value is written to the address computed as (p + (offset * 4)). The address computed as (p + (offset * 4)) must be aligned to sizeof (half) * 4 bytes. vstorea_halfn uses the current rounding mode. The default current rounding mode is round to nearest even.</p>
<p class="startli">This means that loads and stores preceding the mem_fence will be committed to memory before any loads and stores following the mem_fence. The flags argument specifies the memory address space and can be set to a combination of the following literal values: CLK_LOCAL_MEM_FENCE CLK_GLOBAL_MEM_FENCE.</p>
</li>
</ul>
<p >The flags argument specifies the memory address space and can be set to to a combination of the following literal values: CLK_LOCAL_MEM_FENCE CLK_GLOBAL_MEM_FENCE.</p>
<p >The async copy is performed by all work-items in a workgroup and this built-in function must therefore be encountered by all work-items in a workgroup executing the kernel with the same argument values; otherwise the results are undefined. Returns an event object that can be used by wait_group_events to wait for the async copy to finish. The event argument can also be used to associate the async_work_group_copy with a previous async copy allowing an event to be shared by multiple async copies; otherwise event should be zero. If event argument is non-zero, the event object supplied in event argument will be returned. This function does not perform any implicit synchronization of source data such as using a barrier before performing the copy.</p>
<p >The src_stride is the stride in elements for each gentype element read from src. The dst_stride is the stride in elements for each gentype element written to dst. The async gather is performed by all work-items in a work-group. This built-in function must therefore be encountered by all work-items in a work-group executing the kernel with the same argument values; otherwise the results are undefined. Returns an event object that can be used by wait_group_events to wait for the async copy to finish. The event argument can also be used to associate the async_work_group_strided_copy with a previous async copy allowing an event to be shared by multiple async copies; otherwise event should be zero. If event argument is non-zero, the event object supplied in event argument will be returned. This function does not perform any implicit synchronization of source data such as using a barrier before performing the copy.</p>
<p >The event objects specified in event_list will be released after the wait is performed. This function must be encountered by all workitems in a work-group executing the kernel with the same num_events and event objects specified in event_list; otherwise the results are undefined.</p>
<p >The prefetch instruction is applied to a work-item in a workgroup and does not affect the functional behavior of the kernel.</p>
<p >Compute (old + val) and store result at location pointed by p. The function returns old.</p>
<p >Compute (old - val) and store result at location pointed by p. The function returns old.</p>
<p >Returns old value.</p>
<p >Compute (old + 1) and store result at location pointed by p. The function returns old.</p>
<p >Compute (old - 1) and store result at location pointed by p. The function returns old.</p>
<p >Compute (old == cmp) ? val : old and store result at location pointed by p. The function returns old.</p>
<p >Compute min(old, val) and store minimum value at location pointed by p. The function returns old.</p>
<p >Compute max(old, val) and store maximum value at location pointed by p. The function returns old.</p>
<p >Compute (old &amp; val) and store result at location pointed by p. The function returns old.</p>
<p >Compute (old | val) and store result at location pointed by p. The function returns old.</p>
<p >Compute (old ^ val) and store result at location pointed by p. The function returns old.</p>
<p >The size of each element in the mask must match the size of each element in the result. For shuffle, only the ilogb(2m-1) least significant bits of each mask element are considered. For shuffle2, only the ilogb(2m-1)+1 least significant bits of each mask element are considered. Other bits in the mask shall be ignored. The elements of the input vectors are numbered from left to right across one or both of the vectors. For this purpose, the number of elements in a vector is given by vec_step(gentypem). The shuffle mask operand specifies, for each element of the result vector, which element of the one or two input vectors the result element gets. Examples: uint4 mask = (uint4)(3, 2, 1, 0); float4 a; float4 r = shuffle(a, mask); // r.s0123 = a.wzyx uint8 mask = (uint8)(0, 1, 2, 3, 4, 5, 6, 7); float4 a, b; float8 r = shuffle2(a, b, mask); // r.s0123 = a.xyzw // r.s4567 = b.xyzw uint4 mask; float8 a; float4 b; b = shuffle(a, mask); Examples that are not valid are: uint8 mask; short16 a; short8 b; b = shuffle(a, mask); &lt;- not valid</p>
<p >read_imagei and read_imageui return unnormalized signed integer and unsigned integer values respectively. Each channel will be stored in a 32-bit integer. read_imagei can only be used with image objects created with image_channel_data_type set to one of the following values: CL_SIGNED_INT8, CL_SIGNED_INT16 and CL_SIGNED_INT32. If the image_channel_data_type is not one of the above values, the values returned by read_imagei are undefined. read_imageui can only be used with image objects created with image_channel_data_type set to one of the following values: CL_UNSIGNED_INT8, CL_UNSIGNED_INT16 and CL_UNSIGNED_INT32. If the image_channel_data_type is not one of the above values, the values returned by read_imageui are undefined. The read_image{i|ui} calls support a nearest filter only. The filter_mode specified in sampler must be set to CLK_FILTER_NEAREST; otherwise the values returned are undefined. Furthermore, the read_image{i|ui} calls that take integer coordinates must use a sampler with normalized coordinates set to CLK_NORMALIZED_COORDS_FALSE and addressing mode set to CLK_ADDRESS_CLAMP_TO_EDGE, CLK_ADDRESS_CLAMP or CLK_ADDRESS_NONE; otherwise the values returned are undefined.</p>
<p >Appropriate data format conversion to the specified image format is done before writing the color value. x &amp; y are considered to be unnormalized coordinates and must be in the range 0 ... image width - 1, and 0 ... image height - 1. write_imagef can only be used with image objects created with image_channel_data_type set to one of the pre-defined packed formats or set to CL_SNORM_INT8, CL_UNORM_INT8, CL_SNORM_INT16, CL_UNORM_INT16, CL_HALF_FLOAT or CL_FLOAT. Appropriate data format conversion will be done to convert channel data from a floating-point value to actual data format in which the channels are stored. write_imagei can only be used with image objects created with image_channel_data_type set to one of the following values: CL_SIGNED_INT8, CL_SIGNED_INT16 and CL_SIGNED_INT32. write_imageui can only be used with image objects created with image_channel_data_type set to one of the following values: CL_UNSIGNED_INT8, CL_UNSIGNED_INT16 and CL_UNSIGNED_INT32. The behavior of write_imagef, write_imagei and write_imageui for image objects created with image_channel_data_type values not specified in the description above or with (x, y) coordinate values that are not in the range (0 ... image width - 1, 0 ... image height - 1), respectively, is undefined.</p>
<p >coord.w is ignored. read_imagef returns floating-point values in the range [0.0 ... 1.0] for image objects created with image_channel_data_type set to one of the predefined packed formats or CL_UNORM_INT8, or CL_UNORM_INT16. read_imagef returns floating-point values in the range [-1.0 ... 1.0] for image objects created with image_channel_data_type set to CL_SNORM_INT8, or CL_SNORM_INT16. read_imagef returns floating-point values for image objects created with image_channel_data_type set to CL_HALF_FLOAT or CL_FLOAT. The read_imagef calls that take integer coordinates must use a sampler with filter mode set to CLK_FILTER_NEAREST, normalized coordinates set to CLK_NORMALIZED_COORDS_FALSE and addressing mode set to CLK_ADDRESS_CLAMP_TO_EDGE, CLK_ADDRESS_CLAMP or CLK_ADDRESS_NONE; otherwise the values returned are undefined. Values returned by read_imagef for image objects with image_channel_data_type values not specified in the description are undefined.</p>
<p >coord.w is ignored. read_imagei and read_imageui return unnormalized signed integer and unsigned integer values respectively. Each channel will be stored in a 32-bit integer. read_imagei can only be used with image objects created with image_channel_data_type set to one of the following values: CL_SIGNED_INT8, CL_SIGNED_INT16 and CL_SIGNED_INT32. If the image_channel_data_type is not one of the above values, the values returned by read_imagei are undefined. read_imageui can only be used with image objects created with image_channel_data_type set to one of the following values: CL_UNSIGNED_INT8, CL_UNSIGNED_INT16 and CL_UNSIGNED_INT32. If the image_channel_data_type is not one of the above values, the values returned by read_imageui are undefined. The read_image{i|ui} calls support a nearest filter only. The filter_mode specified in sampler must be set to CLK_FILTER_NEAREST; otherwise the values returned are undefined. Furthermore, the read_image{i|ui} calls that take integer coordinates must use a sampler with normalized coordinates set to CLK_NORMALIZED_COORDS_FALSE and addressing mode set to CLK_ADDRESS_CLAMP_TO_EDGE, CLK_ADDRESS_CLAMP or CLK_ADDRESS_NONE; otherwise the values returned are undefined.</p>
<p >Valid values are: CLK_A CLK_R CLK_Rx CLK_RG CLK_RGx CLK_RA CLK_RGB CLK_RGBx CLK_RGBA CLK_ARGB CLK_BGRA CLK_INTENSITY CLK_LUMINANCE</p>
<p >The width is returned in the x component, and the height in the y component.</p>
<p >The width is returned in the x component, height in the y component, depth in the z component and the w component is 0. </p>

</div>
</div>
<a id="a04577b2fc18a306a881fd5e33e5b40ba" name="a04577b2fc18a306a881fd5e33e5b40ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04577b2fc18a306a881fd5e33e5b40ba">&#9670;&nbsp;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="opencl__spir__req_8h.html#a27b608b5ba1de1611f39147081570d4e">__constant</a> const char *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 9 2023 11:27:39 for triSYCL implementation of SYCL by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
